
build/ch.elf:     file format elf32-littlearm


Disassembly of section .vectors:

00200000 <_vectors>:
  200000:	20000400 	.word	0x20000400
  200004:	002002d9 	.word	0x002002d9
  200008:	002002db 	.word	0x002002db
  20000c:	002002da 	.word	0x002002da
  200010:	002002da 	.word	0x002002da
  200014:	002002da 	.word	0x002002da
  200018:	002002da 	.word	0x002002da
  20001c:	002002da 	.word	0x002002da
  200020:	002002da 	.word	0x002002da
  200024:	002002da 	.word	0x002002da
  200028:	002002da 	.word	0x002002da
  20002c:	00201091 	.word	0x00201091
  200030:	002002da 	.word	0x002002da
  200034:	002002da 	.word	0x002002da
  200038:	002002da 	.word	0x002002da
  20003c:	002002da 	.word	0x002002da
  200040:	002002da 	.word	0x002002da
  200044:	002002da 	.word	0x002002da
  200048:	002002da 	.word	0x002002da
  20004c:	002002da 	.word	0x002002da
  200050:	002002da 	.word	0x002002da
  200054:	002002da 	.word	0x002002da
  200058:	002022e1 	.word	0x002022e1
  20005c:	00202291 	.word	0x00202291
  200060:	00202241 	.word	0x00202241
  200064:	002021f1 	.word	0x002021f1
  200068:	002021a1 	.word	0x002021a1
  20006c:	00201dc1 	.word	0x00201dc1
  200070:	00201d91 	.word	0x00201d91
  200074:	00201d61 	.word	0x00201d61
  200078:	00201d31 	.word	0x00201d31
  20007c:	00201d01 	.word	0x00201d01
  200080:	00201cd1 	.word	0x00201cd1
  200084:	00201ca1 	.word	0x00201ca1
  200088:	00201e31 	.word	0x00201e31
  20008c:	002002da 	.word	0x002002da
  200090:	002002da 	.word	0x002002da
  200094:	002002da 	.word	0x002002da
  200098:	002002da 	.word	0x002002da
  20009c:	002020b1 	.word	0x002020b1
  2000a0:	002002da 	.word	0x002002da
  2000a4:	002002da 	.word	0x002002da
  2000a8:	002002da 	.word	0x002002da
  2000ac:	002002da 	.word	0x002002da
  2000b0:	002036d1 	.word	0x002036d1
  2000b4:	002002da 	.word	0x002002da
  2000b8:	002002da 	.word	0x002002da
  2000bc:	002002da 	.word	0x002002da
  2000c0:	002002da 	.word	0x002002da
  2000c4:	002002da 	.word	0x002002da
  2000c8:	002002da 	.word	0x002002da
  2000cc:	002002da 	.word	0x002002da
  2000d0:	002002da 	.word	0x002002da
  2000d4:	002002da 	.word	0x002002da
  2000d8:	002002da 	.word	0x002002da
  2000dc:	002002da 	.word	0x002002da
  2000e0:	00201f91 	.word	0x00201f91
  2000e4:	002002da 	.word	0x002002da
  2000e8:	002002da 	.word	0x002002da
  2000ec:	002002da 	.word	0x002002da
  2000f0:	002002da 	.word	0x002002da
  2000f4:	002002da 	.word	0x002002da
  2000f8:	002002da 	.word	0x002002da
  2000fc:	00201c71 	.word	0x00201c71
  200100:	002002da 	.word	0x002002da
  200104:	002002da 	.word	0x002002da
  200108:	002002da 	.word	0x002002da
  20010c:	002002da 	.word	0x002002da
  200110:	002002da 	.word	0x002002da
  200114:	002002da 	.word	0x002002da
  200118:	002002da 	.word	0x002002da
  20011c:	002002da 	.word	0x002002da
  200120:	00201c41 	.word	0x00201c41
  200124:	00201c11 	.word	0x00201c11
  200128:	00201be1 	.word	0x00201be1
  20012c:	00201bb1 	.word	0x00201bb1
  200130:	00201b81 	.word	0x00201b81
  200134:	002002da 	.word	0x002002da
  200138:	002002da 	.word	0x002002da
  20013c:	002002da 	.word	0x002002da
  200140:	002002da 	.word	0x002002da
  200144:	002002da 	.word	0x002002da
  200148:	002002da 	.word	0x002002da
  20014c:	002016e1 	.word	0x002016e1
  200150:	00201b51 	.word	0x00201b51
  200154:	00201b21 	.word	0x00201b21
  200158:	00201af1 	.word	0x00201af1
  20015c:	002002da 	.word	0x002002da
  200160:	002002da 	.word	0x002002da
  200164:	002002da 	.word	0x002002da
  200168:	002002da 	.word	0x002002da
  20016c:	002002da 	.word	0x002002da
  200170:	002002da 	.word	0x002002da
  200174:	002002da 	.word	0x002002da
  200178:	002002da 	.word	0x002002da
  20017c:	002002da 	.word	0x002002da
  200180:	002002da 	.word	0x002002da
  200184:	002002da 	.word	0x002002da
  200188:	002002da 	.word	0x002002da
  20018c:	002002da 	.word	0x002002da
  200190:	002002da 	.word	0x002002da
  200194:	002002da 	.word	0x002002da
  200198:	002002da 	.word	0x002002da
  20019c:	002002da 	.word	0x002002da
  2001a0:	002002da 	.word	0x002002da
  2001a4:	002002da 	.word	0x002002da
  2001a8:	002002da 	.word	0x002002da
  2001ac:	002002da 	.word	0x002002da
  2001b0:	002002da 	.word	0x002002da
  2001b4:	002002da 	.word	0x002002da
  2001b8:	002002da 	.word	0x002002da
  2001bc:	002002da 	.word	0x002002da
  2001c0:	002002da 	.word	0x002002da
  2001c4:	002002da 	.word	0x002002da
  2001c8:	002002da 	.word	0x002002da
  2001cc:	002002da 	.word	0x002002da
  2001d0:	002002da 	.word	0x002002da
  2001d4:	002002da 	.word	0x002002da
  2001d8:	002002da 	.word	0x002002da
  2001dc:	002002da 	.word	0x002002da
  2001e0:	002002da 	.word	0x002002da
  2001e4:	002002da 	.word	0x002002da
  2001e8:	002002da 	.word	0x002002da
  2001ec:	002002da 	.word	0x002002da
  2001f0:	002002da 	.word	0x002002da
  2001f4:	002002da 	.word	0x002002da
  2001f8:	002002da 	.word	0x002002da
  2001fc:	002002da 	.word	0x002002da

Disassembly of section .text:

00200200 <_crt0_entry>:
                .align  2
                .thumb_func
                .global _crt0_entry
_crt0_entry:
                /* Interrupts are globally masked initially.*/
                cpsid   i
  200200:	b672      	cpsid	i

#if CRT0_FORCE_MSP_INIT == TRUE
                /* MSP stack pointers initialization.*/
                ldr     r0, =__main_stack_end__
  200202:	4827      	ldr	r0, [pc, #156]	; (2002a0 <endfiniloop+0x4>)
                msr     MSP, r0
  200204:	f380 8808 	msr	MSP, r0
#endif

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
  200208:	4826      	ldr	r0, [pc, #152]	; (2002a4 <endfiniloop+0x8>)
                msr     PSP, r0
  20020a:	f380 8809 	msr	PSP, r0

#if CRT0_VTOR_INIT == TRUE
                ldr     r0, =_vectors
  20020e:	4826      	ldr	r0, [pc, #152]	; (2002a8 <endfiniloop+0xc>)
                movw    r1, #SCB_VTOR & 0xFFFF
  200210:	f64e 5108 	movw	r1, #60680	; 0xed08
                movt    r1, #SCB_VTOR >> 16
  200214:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
  200218:	6008      	str	r0, [r1, #0]

                /* Enforcing FPCA bit in the CONTROL register.*/
                movs    r0, #CRT0_CONTROL_INIT | CONTROL_FPCA

#else
                movs    r0, #CRT0_CONTROL_INIT
  20021a:	2002      	movs	r0, #2
#endif

                /* CONTROL register initialization as configured.*/
                msr     CONTROL, r0
  20021c:	f380 8814 	msr	CONTROL, r0
                isb
  200220:	f3bf 8f6f 	isb	sy

#if CRT0_INIT_CORE == TRUE
                /* Core initialization.*/
                bl      __core_init
  200224:	f001 f9c4 	bl	2015b0 <__core_init>
#endif

                /* Early initialization.*/
                bl      __early_init
  200228:	f003 f8f2 	bl	203410 <__early_init>

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
  20022c:	f04f 3055 	mov.w	r0, #1431655765	; 0x55555555
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
  200230:	491e      	ldr	r1, [pc, #120]	; (2002ac <endfiniloop+0x10>)
                ldr     r2, =__main_stack_end__
  200232:	4a1b      	ldr	r2, [pc, #108]	; (2002a0 <endfiniloop+0x4>)

00200234 <msloop>:
msloop:
                cmp     r1, r2
  200234:	4291      	cmp	r1, r2
                itt     lo
  200236:	bf3c      	itt	cc
                strlo   r0, [r1], #4
  200238:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     msloop
  20023c:	e7fa      	bcc.n	200234 <msloop>

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
  20023e:	491c      	ldr	r1, [pc, #112]	; (2002b0 <endfiniloop+0x14>)
                ldr     r2, =__process_stack_end__
  200240:	4a18      	ldr	r2, [pc, #96]	; (2002a4 <endfiniloop+0x8>)

00200242 <psloop>:
psloop:
                cmp     r1, r2
  200242:	4291      	cmp	r1, r2
                itt     lo
  200244:	bf3c      	itt	cc
                strlo   r0, [r1], #4
  200246:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     psloop
  20024a:	e7fa      	bcc.n	200242 <psloop>
#endif

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                ldr     r1, =_textdata_start
  20024c:	4919      	ldr	r1, [pc, #100]	; (2002b4 <endfiniloop+0x18>)
                ldr     r2, =_data_start
  20024e:	4a1a      	ldr	r2, [pc, #104]	; (2002b8 <endfiniloop+0x1c>)
                ldr     r3, =_data_end
  200250:	4b1a      	ldr	r3, [pc, #104]	; (2002bc <endfiniloop+0x20>)

00200252 <dloop>:
dloop:
                cmp     r2, r3
  200252:	429a      	cmp	r2, r3
                ittt    lo
  200254:	bf3e      	ittt	cc
                ldrlo   r0, [r1], #4
  200256:	f851 0b04 	ldrcc.w	r0, [r1], #4
                strlo   r0, [r2], #4
  20025a:	f842 0b04 	strcc.w	r0, [r2], #4
                blo     dloop
  20025e:	e7f8      	bcc.n	200252 <dloop>
#endif

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                movs    r0, #0
  200260:	2000      	movs	r0, #0
                ldr     r1, =_bss_start
  200262:	4917      	ldr	r1, [pc, #92]	; (2002c0 <endfiniloop+0x24>)
                ldr     r2, =_bss_end
  200264:	4a17      	ldr	r2, [pc, #92]	; (2002c4 <endfiniloop+0x28>)

00200266 <bloop>:
bloop:
                cmp     r1, r2
  200266:	4291      	cmp	r1, r2
                itt     lo
  200268:	bf3c      	itt	cc
                strlo   r0, [r1], #4
  20026a:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     bloop
  20026e:	e7fa      	bcc.n	200266 <bloop>
#endif

#if CRT0_INIT_RAM_AREAS == TRUE
                /* RAM areas initialization.*/
                bl      __init_ram_areas
  200270:	f001 f95e 	bl	201530 <__init_ram_areas>
#endif

                /* Late initialization..*/
                bl      __late_init
  200274:	f001 f994 	bl	2015a0 <__late_init>

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_start
  200278:	4c13      	ldr	r4, [pc, #76]	; (2002c8 <endfiniloop+0x2c>)
                ldr     r5, =__init_array_end
  20027a:	4d14      	ldr	r5, [pc, #80]	; (2002cc <endfiniloop+0x30>)

0020027c <initloop>:
initloop:
                cmp     r4, r5
  20027c:	42ac      	cmp	r4, r5
                bge     endinitloop
  20027e:	da03      	bge.n	200288 <endinitloop>
                ldr     r1, [r4], #4
  200280:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
  200284:	4788      	blx	r1
                b       initloop
  200286:	e7f9      	b.n	20027c <initloop>

00200288 <endinitloop>:
endinitloop:
#endif

                /* Main program invocation, r0 contains the returned value.*/
                bl      main
  200288:	f002 f87a 	bl	202380 <main>

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_start
  20028c:	4c10      	ldr	r4, [pc, #64]	; (2002d0 <endfiniloop+0x34>)
                ldr     r5, =__fini_array_end
  20028e:	4d11      	ldr	r5, [pc, #68]	; (2002d4 <endfiniloop+0x38>)

00200290 <finiloop>:
finiloop:
                cmp     r4, r5
  200290:	42ac      	cmp	r4, r5
                bge     endfiniloop
  200292:	da03      	bge.n	20029c <endfiniloop>
                ldr     r1, [r4], #4
  200294:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
  200298:	4788      	blx	r1
                b       finiloop
  20029a:	e7f9      	b.n	200290 <finiloop>

0020029c <endfiniloop>:
endfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                b       __default_exit
  20029c:	f001 b978 	b.w	201590 <__default_exit>
                ldr     r0, =__main_stack_end__
  2002a0:	20000400 	.word	0x20000400
                ldr     r0, =__process_stack_end__
  2002a4:	20000800 	.word	0x20000800
                ldr     r0, =_vectors
  2002a8:	00200000 	.word	0x00200000
                ldr     r1, =__main_stack_base__
  2002ac:	20000000 	.word	0x20000000
                ldr     r1, =__process_stack_base__
  2002b0:	20000400 	.word	0x20000400
                ldr     r1, =_textdata_start
  2002b4:	08003f6c 	.word	0x08003f6c
                ldr     r2, =_data_start
  2002b8:	20020000 	.word	0x20020000
                ldr     r3, =_data_end
  2002bc:	20020008 	.word	0x20020008
                ldr     r1, =_bss_start
  2002c0:	20000800 	.word	0x20000800
                ldr     r2, =_bss_end
  2002c4:	20001318 	.word	0x20001318
                ldr     r4, =__init_array_start
  2002c8:	00200200 	.word	0x00200200
                ldr     r5, =__init_array_end
  2002cc:	00200200 	.word	0x00200200
                ldr     r4, =__fini_array_start
  2002d0:	00200200 	.word	0x00200200
                ldr     r5, =__fini_array_end
  2002d4:	00200200 	.word	0x00200200

002002d8 <Reset_Handler>:

        .align      2
        .thumb_func
        .weak       Reset_Handler
Reset_Handler:
         b          _crt0_entry
  2002d8:	e792      	b.n	200200 <_crt0_entry>

002002da <NMI_Handler>:
Vector3F0:
Vector3F4:
Vector3F8:
Vector3FC:
#endif
         b          _unhandled_exception
  2002da:	e7ff      	b.n	2002dc <_unhandled_exception>

002002dc <_unhandled_exception>:

        .thumb_func
        .weak       _unhandled_exception
_unhandled_exception:
.stay:
        b           .stay
  2002dc:	e7fe      	b.n	2002dc <_unhandled_exception>
  2002de:	46c0      	nop			; (mov r8, r8)

002002e0 <_port_switch>:
 * Performs a context switch between two threads.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  _port_switch
_port_switch:
                push    {r4, r5, r6, r7, r8, r9, r10, r11, lr}
  2002e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if CORTEX_USE_FPU
                vpush   {s16-s31}
#endif

                str     sp, [r1, #CONTEXT_OFFSET]
  2002e4:	f8c1 d00c 	str.w	sp, [r1, #12]
                /* Workaround for ARM errata 752419, only applied if
                   condition exists for it to be triggered.*/
                ldr     r3, [r0, #CONTEXT_OFFSET]
                mov     sp, r3
#else
                ldr     sp, [r0, #CONTEXT_OFFSET]
  2002e8:	f8d0 d00c 	ldr.w	sp, [r0, #12]
#endif

#if CORTEX_USE_FPU
                vpop    {s16-s31}
#endif
                pop     {r4, r5, r6, r7, r8, r9, r10, r11, pc}
  2002ec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

002002f0 <_port_thread_start>:
                bl      _stats_stop_measure_crit_thd
#endif
#if CORTEX_SIMPLIFIED_PRIORITY
                cpsie   i
#else
                movs    r3, #0              /* CORTEX_BASEPRI_DISABLED */
  2002f0:	2300      	movs	r3, #0
                msr     BASEPRI, r3
  2002f2:	f383 8811 	msr	BASEPRI, r3
#endif
                mov     r0, r5
  2002f6:	4628      	mov	r0, r5
                blx     r4
  2002f8:	47a0      	blx	r4
#if defined(_CHIBIOS_RT_CONF_)
                movs    r0, #0              /* MSG_OK */
  2002fa:	2000      	movs	r0, #0
                bl      chThdExit
  2002fc:	f001 f800 	bl	201300 <chThdExit>

00200300 <_port_switch_from_isr>:
                bl      _stats_start_measure_crit_thd
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_lock
#endif
                bl      chSchDoReschedule
  200300:	f001 f826 	bl	201350 <chSchDoReschedule>

00200304 <_port_exit_from_isr>:
                movt    r3, #:upper16:SCB_ICSR
                mov     r2, ICSR_PENDSVSET
                str     r2, [r3, #0]
                cpsie   i
#else /* !CORTEX_SIMPLIFIED_PRIORITY */
                svc     #0
  200304:	df00      	svc	0
#endif /* !CORTEX_SIMPLIFIED_PRIORITY */
.L1:            b       .L1
  200306:	e7fe      	b.n	200306 <_port_exit_from_isr+0x2>
	...

00200310 <sduInterruptTransmitted>:
 *          interrupt endpoint.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 */
void sduInterruptTransmitted(USBDriver *usbp, usbep_t ep) {
  200310:	4770      	bx	lr
  200312:	bf00      	nop
	...

00200320 <sduRequestsHook>:
  if ((usbp->setup[0] & USB_RTYPE_TYPE_MASK) == USB_RTYPE_TYPE_CLASS) {
  200320:	f890 305c 	ldrb.w	r3, [r0, #92]	; 0x5c
  200324:	f003 0360 	and.w	r3, r3, #96	; 0x60
  200328:	2b20      	cmp	r3, #32
  20032a:	d001      	beq.n	200330 <sduRequestsHook+0x10>
  return false;
  20032c:	2000      	movs	r0, #0
  20032e:	4770      	bx	lr
bool sduRequestsHook(USBDriver *usbp) {
  200330:	b410      	push	{r4}
    switch (usbp->setup[1]) {
  200332:	f890 305d 	ldrb.w	r3, [r0, #93]	; 0x5d
  200336:	4602      	mov	r2, r0
  200338:	2b21      	cmp	r3, #33	; 0x21
  20033a:	d00c      	beq.n	200356 <sduRequestsHook+0x36>
  20033c:	2b22      	cmp	r3, #34	; 0x22
  20033e:	d004      	beq.n	20034a <sduRequestsHook+0x2a>
  200340:	2b20      	cmp	r3, #32
  200342:	d008      	beq.n	200356 <sduRequestsHook+0x36>
      return false;
  200344:	2000      	movs	r0, #0
}
  200346:	bc10      	pop	{r4}
  200348:	4770      	bx	lr
      usbSetupTransfer(usbp, NULL, 0, NULL);
  20034a:	2300      	movs	r3, #0
      return true;
  20034c:	2001      	movs	r0, #1
      usbSetupTransfer(usbp, NULL, 0, NULL);
  20034e:	6513      	str	r3, [r2, #80]	; 0x50
  200350:	6553      	str	r3, [r2, #84]	; 0x54
  200352:	6593      	str	r3, [r2, #88]	; 0x58
  200354:	e7f7      	b.n	200346 <sduRequestsHook+0x26>
      usbSetupTransfer(usbp, (uint8_t *)&linecoding, sizeof(linecoding), NULL);
  200356:	4c04      	ldr	r4, [pc, #16]	; (200368 <sduRequestsHook+0x48>)
  200358:	2107      	movs	r1, #7
  20035a:	2300      	movs	r3, #0
      return true;
  20035c:	2001      	movs	r0, #1
      usbSetupTransfer(usbp, (uint8_t *)&linecoding, sizeof(linecoding), NULL);
  20035e:	6514      	str	r4, [r2, #80]	; 0x50
  200360:	6551      	str	r1, [r2, #84]	; 0x54
  200362:	6593      	str	r3, [r2, #88]	; 0x58
}
  200364:	bc10      	pop	{r4}
  200366:	4770      	bx	lr
  200368:	20020000 	.word	0x20020000
  20036c:	00000000 	.word	0x00000000

00200370 <_ctl.lto_priv.58>:
}
  200370:	2000      	movs	r0, #0
  200372:	4770      	bx	lr
	...

00200380 <chCoreAllocAlignedI.lto_priv.44>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
static inline void *chCoreAllocAlignedI(size_t size, unsigned align) {
  200380:	b4f0      	push	{r4, r5, r6, r7}

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
  200382:	4d0a      	ldr	r5, [pc, #40]	; (2003ac <chCoreAllocAlignedI.lto_priv.44+0x2c>)
  size = MEM_ALIGN_NEXT(size, align);
  200384:	1e4b      	subs	r3, r1, #1
  200386:	424e      	negs	r6, r1
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
  200388:	682f      	ldr	r7, [r5, #0]
  size = MEM_ALIGN_NEXT(size, align);
  20038a:	4403      	add	r3, r0
  next = p + size;

  /* Considering also the case where there is numeric overflow.*/
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
  20038c:	686c      	ldr	r4, [r5, #4]
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
  20038e:	1e7a      	subs	r2, r7, #1
  size = MEM_ALIGN_NEXT(size, align);
  200390:	4033      	ands	r3, r6
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
  200392:	1850      	adds	r0, r2, r1
  200394:	4030      	ands	r0, r6
  next = p + size;
  200396:	4403      	add	r3, r0
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
  200398:	42a3      	cmp	r3, r4
  20039a:	d804      	bhi.n	2003a6 <chCoreAllocAlignedI.lto_priv.44+0x26>
  20039c:	429f      	cmp	r7, r3
  20039e:	d802      	bhi.n	2003a6 <chCoreAllocAlignedI.lto_priv.44+0x26>
    return NULL;
  }

  ch_memcore.nextmem = next;
  2003a0:	602b      	str	r3, [r5, #0]

  return chCoreAllocAlignedWithOffsetI(size, align, 0U);
}
  2003a2:	bcf0      	pop	{r4, r5, r6, r7}
  2003a4:	4770      	bx	lr
    return NULL;
  2003a6:	2000      	movs	r0, #0
  2003a8:	bcf0      	pop	{r4, r5, r6, r7}
  2003aa:	4770      	bx	lr
  2003ac:	20000f68 	.word	0x20000f68

002003b0 <chCoreAllocAlignedWithOffset>:
 *
 * @api
 */
void *chCoreAllocAlignedWithOffset(size_t size,
                                   unsigned align,
                                   size_t offset) {
  2003b0:	b4f0      	push	{r4, r5, r6, r7}
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__((always_inline)) __STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2003b2:	2320      	movs	r3, #32
  2003b4:	f383 8811 	msr	BASEPRI, r3
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
  2003b8:	4d0d      	ldr	r5, [pc, #52]	; (2003f0 <chCoreAllocAlignedWithOffset+0x40>)
  2003ba:	1e4e      	subs	r6, r1, #1
  size = MEM_ALIGN_NEXT(size, align);
  2003bc:	4249      	negs	r1, r1
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
  2003be:	682f      	ldr	r7, [r5, #0]
  size = MEM_ALIGN_NEXT(size, align);
  2003c0:	1983      	adds	r3, r0, r6
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
  2003c2:	686c      	ldr	r4, [r5, #4]
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
  2003c4:	18b8      	adds	r0, r7, r2
  size = MEM_ALIGN_NEXT(size, align);
  2003c6:	400b      	ands	r3, r1
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
  2003c8:	4430      	add	r0, r6
  2003ca:	4008      	ands	r0, r1
  next = p + size;
  2003cc:	4403      	add	r3, r0
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
  2003ce:	42a3      	cmp	r3, r4
  2003d0:	d807      	bhi.n	2003e2 <chCoreAllocAlignedWithOffset+0x32>
  2003d2:	429f      	cmp	r7, r3
  2003d4:	d805      	bhi.n	2003e2 <chCoreAllocAlignedWithOffset+0x32>
  ch_memcore.nextmem = next;
  2003d6:	602b      	str	r3, [r5, #0]
  2003d8:	2300      	movs	r3, #0
  2003da:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  p = chCoreAllocAlignedWithOffsetI(size, align, offset);
  chSysUnlock();

  return p;
}
  2003de:	bcf0      	pop	{r4, r5, r6, r7}
  2003e0:	4770      	bx	lr
    return NULL;
  2003e2:	2000      	movs	r0, #0
  2003e4:	2300      	movs	r3, #0
  2003e6:	f383 8811 	msr	BASEPRI, r3
}
  2003ea:	bcf0      	pop	{r4, r5, r6, r7}
  2003ec:	4770      	bx	lr
  2003ee:	bf00      	nop
  2003f0:	20000f68 	.word	0x20000f68
	...

00200400 <wakeup>:
  200400:	2320      	movs	r3, #32
  200402:	f383 8811 	msr	BASEPRI, r3
 */
static void wakeup(void *p) {
  thread_t *tp = (thread_t *)p;

  chSysLockFromISR();
  switch (tp->state) {
  200406:	f890 3020 	ldrb.w	r3, [r0, #32]
  20040a:	2b07      	cmp	r3, #7
  20040c:	d80e      	bhi.n	20042c <wakeup+0x2c>
  20040e:	e8df f003 	tbb	[pc, r3]
  200412:	0d28      	.short	0x0d28
  200414:	0408240d 	.word	0x0408240d
  200418:	080d      	.short	0x080d
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
  20041a:	6a42      	ldr	r2, [r0, #36]	; 0x24
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->cnt++;
  20041c:	6893      	ldr	r3, [r2, #8]
  20041e:	3301      	adds	r3, #1
  200420:	6093      	str	r3, [r2, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
  200422:	e890 000c 	ldmia.w	r0, {r2, r3}
  200426:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
  200428:	6802      	ldr	r2, [r0, #0]
  20042a:	6053      	str	r3, [r2, #4]
  tp->state = CH_STATE_READY;
  20042c:	2200      	movs	r2, #0
  20042e:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.queue;
  200430:	4b0e      	ldr	r3, [pc, #56]	; (20046c <wakeup+0x6c>)
  tp->state = CH_STATE_READY;
  200432:	f880 2020 	strb.w	r2, [r0, #32]
static void wakeup(void *p) {
  200436:	b410      	push	{r4}
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
  200438:	f04f 34ff 	mov.w	r4, #4294967295
  20043c:	6244      	str	r4, [r0, #36]	; 0x24
    cp = cp->queue.next;
  20043e:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
  200440:	689a      	ldr	r2, [r3, #8]
  200442:	428a      	cmp	r2, r1
  200444:	d2fb      	bcs.n	20043e <wakeup+0x3e>
  tp->queue.prev             = cp->queue.prev;
  200446:	685a      	ldr	r2, [r3, #4]
  200448:	2100      	movs	r1, #0
  tp->queue.next             = cp;
  20044a:	6003      	str	r3, [r0, #0]
  tp->queue.prev             = cp->queue.prev;
  20044c:	6042      	str	r2, [r0, #4]
  tp->queue.prev->queue.next = tp;
  20044e:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
  200450:	6058      	str	r0, [r3, #4]
  200452:	f381 8811 	msr	BASEPRI, r1
  (void) chSchReadyI(tp);
  chSysUnlockFromISR();
}
  200456:	bc10      	pop	{r4}
  200458:	4770      	bx	lr
    *tp->u.wttrp = NULL;
  20045a:	6a43      	ldr	r3, [r0, #36]	; 0x24
  20045c:	2200      	movs	r2, #0
  20045e:	601a      	str	r2, [r3, #0]
  200460:	e7e4      	b.n	20042c <wakeup+0x2c>
  200462:	2300      	movs	r3, #0
  200464:	f383 8811 	msr	BASEPRI, r3
  200468:	4770      	bx	lr
  20046a:	bf00      	nop
  20046c:	200012a0 	.word	0x200012a0

00200470 <chSchReadyI>:
thread_t *chSchReadyI(thread_t *tp) {
  200470:	b410      	push	{r4}
  tp->state = CH_STATE_READY;
  200472:	2200      	movs	r2, #0
thread_t *chSchReadyI(thread_t *tp) {
  200474:	4604      	mov	r4, r0
  cp = (thread_t *)&ch.rlist.queue;
  200476:	4b08      	ldr	r3, [pc, #32]	; (200498 <chSchReadyI+0x28>)
  200478:	6881      	ldr	r1, [r0, #8]
  tp->state = CH_STATE_READY;
  20047a:	f880 2020 	strb.w	r2, [r0, #32]
    cp = cp->queue.next;
  20047e:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
  200480:	689a      	ldr	r2, [r3, #8]
  200482:	428a      	cmp	r2, r1
  200484:	d2fb      	bcs.n	20047e <chSchReadyI+0xe>
  tp->queue.prev             = cp->queue.prev;
  200486:	685a      	ldr	r2, [r3, #4]
}
  200488:	4620      	mov	r0, r4
  tp->queue.next             = cp;
  20048a:	6023      	str	r3, [r4, #0]
  tp->queue.prev             = cp->queue.prev;
  20048c:	6062      	str	r2, [r4, #4]
  tp->queue.prev->queue.next = tp;
  20048e:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
  200490:	605c      	str	r4, [r3, #4]
}
  200492:	bc10      	pop	{r4}
  200494:	4770      	bx	lr
  200496:	bf00      	nop
  200498:	200012a0 	.word	0x200012a0
  20049c:	00000000 	.word	0x00000000

002004a0 <_idle_thread.lto_priv.59>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
  2004a0:	e7fe      	b.n	2004a0 <_idle_thread.lto_priv.59>
  2004a2:	bf00      	nop
	...

002004b0 <_usb_ep0in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
  2004b0:	b538      	push	{r3, r4, r5, lr}
  size_t max;

  (void)ep;
  switch (usbp->ep0state) {
  2004b2:	f890 304c 	ldrb.w	r3, [r0, #76]	; 0x4c
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
  2004b6:	4604      	mov	r4, r0
  switch (usbp->ep0state) {
  2004b8:	2b15      	cmp	r3, #21
  2004ba:	d821      	bhi.n	200500 <_usb_ep0in+0x50>
  2004bc:	e8df f003 	tbb	[pc, r3]
  2004c0:	2020200b 	.word	0x2020200b
  2004c4:	200b2020 	.word	0x200b2020
  2004c8:	48312120 	.word	0x48312120
  2004cc:	20202020 	.word	0x20202020
  2004d0:	20202020 	.word	0x20202020
  2004d4:	0b0b      	.short	0x0b0b
 *
 * @notapi
 */
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
  2004d6:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
    /* Error response, the state machine goes into an error state, the low
       level layer will have to reset it to USB_EP0_WAITING_SETUP after
       receiving a SETUP packet.*/
    usb_lld_stall_in(usbp, 0);
    usb_lld_stall_out(usbp, 0);
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
  2004d8:	6841      	ldr	r1, [r0, #4]
  2004da:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
  2004de:	680d      	ldr	r5, [r1, #0]
  2004e0:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
  2004e4:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
  2004e8:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	; 0xb00
  2004ec:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
  2004f0:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
  2004f4:	b10d      	cbz	r5, 2004fa <_usb_ep0in+0x4a>
  2004f6:	2106      	movs	r1, #6
  2004f8:	47a8      	blx	r5
    usbp->ep0state = USB_EP0_ERROR;
  2004fa:	2306      	movs	r3, #6
  2004fc:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
  200500:	bd38      	pop	{r3, r4, r5, pc}
  hw |= (uint16_t)*p << 8U;
  200502:	f890 1063 	ldrb.w	r1, [r0, #99]	; 0x63
  200506:	f890 3062 	ldrb.w	r3, [r0, #98]	; 0x62
    if ((usbp->ep0n < max) &&
  20050a:	6d42      	ldr	r2, [r0, #84]	; 0x54
    max = (size_t)get_hword(&usbp->setup[6]);
  20050c:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
    if ((usbp->ep0n < max) &&
  200510:	4293      	cmp	r3, r2
  200512:	d906      	bls.n	200522 <_usb_ep0in+0x72>
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
  200514:	68c3      	ldr	r3, [r0, #12]
  200516:	8a1b      	ldrh	r3, [r3, #16]
  200518:	fbb2 f5f3 	udiv	r5, r2, r3
  20051c:	fb03 2515 	mls	r5, r3, r5, r2
    if ((usbp->ep0n < max) &&
  200520:	b1ed      	cbz	r5, 20055e <_usb_ep0in+0xae>
    usbp->ep0state = USB_EP0_OUT_WAITING_STS;
  200522:	2214      	movs	r2, #20
  200524:	2320      	movs	r3, #32
  200526:	f884 204c 	strb.w	r2, [r4, #76]	; 0x4c
  20052a:	f383 8811 	msr	BASEPRI, r3
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
  20052e:	8962      	ldrh	r2, [r4, #10]
  osp->rxbuf  = buf;
  200530:	2500      	movs	r5, #0
  osp = usbp->epc[ep]->out_state;
  200532:	68e3      	ldr	r3, [r4, #12]
  usb_lld_start_out(usbp, ep);
  200534:	4620      	mov	r0, r4
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
  200536:	f042 0201 	orr.w	r2, r2, #1
  usb_lld_start_out(usbp, ep);
  20053a:	4629      	mov	r1, r5
  osp = usbp->epc[ep]->out_state;
  20053c:	699b      	ldr	r3, [r3, #24]
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
  20053e:	8162      	strh	r2, [r4, #10]
  osp->rxbuf  = buf;
  200540:	609d      	str	r5, [r3, #8]
  osp->rxsize = n;
  200542:	601d      	str	r5, [r3, #0]
  osp->rxcnt  = 0;
  200544:	605d      	str	r5, [r3, #4]
  usb_lld_start_out(usbp, ep);
  200546:	f003 f96b 	bl	203820 <usb_lld_start_out>
  20054a:	f385 8811 	msr	BASEPRI, r5
  20054e:	bd38      	pop	{r3, r4, r5, pc}
    if (usbp->ep0endcb != NULL) {
  200550:	6d83      	ldr	r3, [r0, #88]	; 0x58
  200552:	b103      	cbz	r3, 200556 <_usb_ep0in+0xa6>
      usbp->ep0endcb(usbp);
  200554:	4798      	blx	r3
    usbp->ep0state = USB_EP0_STP_WAITING;
  200556:	2300      	movs	r3, #0
  200558:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
  20055c:	bd38      	pop	{r3, r4, r5, pc}
  20055e:	2320      	movs	r3, #32
  200560:	f383 8811 	msr	BASEPRI, r3
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
  200564:	8902      	ldrh	r2, [r0, #8]
  usb_lld_start_in(usbp, ep);
  200566:	4629      	mov	r1, r5
  isp = usbp->epc[ep]->in_state;
  200568:	68c3      	ldr	r3, [r0, #12]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
  20056a:	f042 0201 	orr.w	r2, r2, #1
  isp = usbp->epc[ep]->in_state;
  20056e:	695b      	ldr	r3, [r3, #20]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
  200570:	8102      	strh	r2, [r0, #8]
  isp->txbuf  = buf;
  200572:	609d      	str	r5, [r3, #8]
  isp->txsize = n;
  200574:	601d      	str	r5, [r3, #0]
  isp->txcnt  = 0;
  200576:	605d      	str	r5, [r3, #4]
  usb_lld_start_in(usbp, ep);
  200578:	f003 f8fa 	bl	203770 <usb_lld_start_in>
  20057c:	f385 8811 	msr	BASEPRI, r5
      usbp->ep0state = USB_EP0_IN_WAITING_TX0;
  200580:	230a      	movs	r3, #10
  200582:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
  200586:	bd38      	pop	{r3, r4, r5, pc}
	...

00200590 <_usb_ep0setup>:
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
  200590:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (usbp->ep0state != USB_EP0_STP_WAITING) {
  200592:	f890 304c 	ldrb.w	r3, [r0, #76]	; 0x4c
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
  200596:	4604      	mov	r4, r0
  if (usbp->ep0state != USB_EP0_STP_WAITING) {
  200598:	b113      	cbz	r3, 2005a0 <_usb_ep0setup+0x10>
    usbp->ep0state = USB_EP0_STP_WAITING;
  20059a:	2300      	movs	r3, #0
  20059c:	f880 304c 	strb.w	r3, [r0, #76]	; 0x4c
  memcpy(buf, usbp->epc[ep]->setup_buf, 8);
  2005a0:	eb04 0181 	add.w	r1, r4, r1, lsl #2
  if ((usbp->config->requests_hook_cb == NULL) ||
  2005a4:	6862      	ldr	r2, [r4, #4]
  2005a6:	68cb      	ldr	r3, [r1, #12]
  2005a8:	6a1b      	ldr	r3, [r3, #32]
  2005aa:	6819      	ldr	r1, [r3, #0]
  2005ac:	685b      	ldr	r3, [r3, #4]
  2005ae:	65e1      	str	r1, [r4, #92]	; 0x5c
  2005b0:	6623      	str	r3, [r4, #96]	; 0x60
  2005b2:	6893      	ldr	r3, [r2, #8]
  2005b4:	b35b      	cbz	r3, 20060e <_usb_ep0setup+0x7e>
      !(usbp->config->requests_hook_cb(usbp))) {
  2005b6:	4620      	mov	r0, r4
  2005b8:	4798      	blx	r3
  if ((usbp->config->requests_hook_cb == NULL) ||
  2005ba:	b340      	cbz	r0, 20060e <_usb_ep0setup+0x7e>
  2005bc:	6d61      	ldr	r1, [r4, #84]	; 0x54
  2005be:	f894 305c 	ldrb.w	r3, [r4, #92]	; 0x5c
  hw |= (uint16_t)*p << 8U;
  2005c2:	f894 0063 	ldrb.w	r0, [r4, #99]	; 0x63
  2005c6:	f894 2062 	ldrb.w	r2, [r4, #98]	; 0x62
  max = (size_t)get_hword(&usbp->setup[6]);
  2005ca:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
  if (usbp->ep0n > max) {
  2005ce:	428a      	cmp	r2, r1
  2005d0:	bf2c      	ite	cs
  2005d2:	460a      	movcs	r2, r1
    usbp->ep0n = max;
  2005d4:	6562      	strcc	r2, [r4, #84]	; 0x54
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
  2005d6:	0619      	lsls	r1, r3, #24
  2005d8:	f100 8090 	bmi.w	2006fc <_usb_ep0setup+0x16c>
    if (usbp->ep0n != 0U) {
  2005dc:	2a00      	cmp	r2, #0
  2005de:	d15d      	bne.n	20069c <_usb_ep0setup+0x10c>
      usbp->ep0state = USB_EP0_IN_SENDING_STS;
  2005e0:	220b      	movs	r2, #11
  2005e2:	2320      	movs	r3, #32
  2005e4:	f884 204c 	strb.w	r2, [r4, #76]	; 0x4c
  2005e8:	f383 8811 	msr	BASEPRI, r3
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
  2005ec:	8922      	ldrh	r2, [r4, #8]
  isp->txbuf  = buf;
  2005ee:	2500      	movs	r5, #0
  isp = usbp->epc[ep]->in_state;
  2005f0:	68e3      	ldr	r3, [r4, #12]
  usb_lld_start_in(usbp, ep);
  2005f2:	4620      	mov	r0, r4
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
  2005f4:	f042 0201 	orr.w	r2, r2, #1
  usb_lld_start_in(usbp, ep);
  2005f8:	4629      	mov	r1, r5
  isp = usbp->epc[ep]->in_state;
  2005fa:	695b      	ldr	r3, [r3, #20]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
  2005fc:	8122      	strh	r2, [r4, #8]
  isp->txbuf  = buf;
  2005fe:	609d      	str	r5, [r3, #8]
  isp->txsize = n;
  200600:	601d      	str	r5, [r3, #0]
  isp->txcnt  = 0;
  200602:	605d      	str	r5, [r3, #4]
  usb_lld_start_in(usbp, ep);
  200604:	f003 f8b4 	bl	203770 <usb_lld_start_in>
  200608:	f385 8811 	msr	BASEPRI, r5
  20060c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (((usbp->setup[0] & USB_RTYPE_TYPE_MASK) != USB_RTYPE_TYPE_STD) ||
  20060e:	f894 305c 	ldrb.w	r3, [r4, #92]	; 0x5c
  200612:	f013 0560 	ands.w	r5, r3, #96	; 0x60
  200616:	4619      	mov	r1, r3
  200618:	d016      	beq.n	200648 <_usb_ep0setup+0xb8>
  20061a:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
  20061c:	f8d2 3900 	ldr.w	r3, [r2, #2304]	; 0x900
      _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
  200620:	6861      	ldr	r1, [r4, #4]
  200622:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
  200626:	680d      	ldr	r5, [r1, #0]
  200628:	f8c2 3900 	str.w	r3, [r2, #2304]	; 0x900
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
  20062c:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	; 0xb00
  200630:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
  200634:	f8c2 3b00 	str.w	r3, [r2, #2816]	; 0xb00
  200638:	b115      	cbz	r5, 200640 <_usb_ep0setup+0xb0>
  20063a:	2106      	movs	r1, #6
  20063c:	4620      	mov	r0, r4
  20063e:	47a8      	blx	r5
      usbp->ep0state = USB_EP0_ERROR;
  200640:	2306      	movs	r3, #6
  200642:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
  200646:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
           ((uint32_t)usbp->setup[1] << 8U))) {
  200648:	f894 605d 	ldrb.w	r6, [r4, #93]	; 0x5d
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
  20064c:	f003 027f 	and.w	r2, r3, #127	; 0x7f
  200650:	f240 3002 	movw	r0, #770	; 0x302
                                        USB_RTYPE_TYPE_MASK)) |
  200654:	ea42 2206 	orr.w	r2, r2, r6, lsl #8
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
  200658:	4282      	cmp	r2, r0
  20065a:	f000 814e 	beq.w	2008fa <_usb_ep0setup+0x36a>
  20065e:	d836      	bhi.n	2006ce <_usb_ep0setup+0x13e>
  200660:	2a02      	cmp	r2, #2
  200662:	f000 8138 	beq.w	2008d6 <_usb_ep0setup+0x346>
  200666:	f240 810a 	bls.w	20087e <_usb_ep0setup+0x2ee>
  20066a:	f5b2 7f81 	cmp.w	r2, #258	; 0x102
  20066e:	f000 810f 	beq.w	200890 <_usb_ep0setup+0x300>
  200672:	f5b2 7f40 	cmp.w	r2, #768	; 0x300
  200676:	f000 8086 	beq.w	200786 <_usb_ep0setup+0x1f6>
  20067a:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
  20067e:	d1cc      	bne.n	20061a <_usb_ep0setup+0x8a>
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
  200680:	f894 305e 	ldrb.w	r3, [r4, #94]	; 0x5e
  200684:	2b01      	cmp	r3, #1
  200686:	d1c8      	bne.n	20061a <_usb_ep0setup+0x8a>
      usbp->status &= ~2U;
  200688:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
      usbSetupTransfer(usbp, NULL, 0, NULL);
  20068c:	6525      	str	r5, [r4, #80]	; 0x50
      usbp->status &= ~2U;
  20068e:	f023 0302 	bic.w	r3, r3, #2
      usbSetupTransfer(usbp, NULL, 0, NULL);
  200692:	6565      	str	r5, [r4, #84]	; 0x54
  200694:	65a5      	str	r5, [r4, #88]	; 0x58
      usbp->status &= ~2U;
  200696:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
  20069a:	e05a      	b.n	200752 <_usb_ep0setup+0x1c2>
      usbp->ep0state = USB_EP0_OUT_RX;
  20069c:	2215      	movs	r2, #21
  20069e:	2320      	movs	r3, #32
  2006a0:	f884 204c 	strb.w	r2, [r4, #76]	; 0x4c
  2006a4:	f383 8811 	msr	BASEPRI, r3
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
  2006a8:	8962      	ldrh	r2, [r4, #10]
  osp->rxcnt  = 0;
  2006aa:	2500      	movs	r5, #0
  osp = usbp->epc[ep]->out_state;
  2006ac:	68e3      	ldr	r3, [r4, #12]
  usb_lld_start_out(usbp, ep);
  2006ae:	4620      	mov	r0, r4
      usbStartReceiveI(usbp, 0, (uint8_t *)usbp->ep0next, usbp->ep0n);
  2006b0:	6d27      	ldr	r7, [r4, #80]	; 0x50
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
  2006b2:	f042 0201 	orr.w	r2, r2, #1
  osp = usbp->epc[ep]->out_state;
  2006b6:	699b      	ldr	r3, [r3, #24]
  usb_lld_start_out(usbp, ep);
  2006b8:	4629      	mov	r1, r5
      usbStartReceiveI(usbp, 0, (uint8_t *)usbp->ep0next, usbp->ep0n);
  2006ba:	6d66      	ldr	r6, [r4, #84]	; 0x54
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
  2006bc:	8162      	strh	r2, [r4, #10]
  osp->rxbuf  = buf;
  2006be:	609f      	str	r7, [r3, #8]
  osp->rxsize = n;
  2006c0:	601e      	str	r6, [r3, #0]
  osp->rxcnt  = 0;
  2006c2:	605d      	str	r5, [r3, #4]
  usb_lld_start_out(usbp, ep);
  2006c4:	f003 f8ac 	bl	203820 <usb_lld_start_out>
  2006c8:	f385 8811 	msr	BASEPRI, r5
  2006cc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
  2006ce:	f240 6001 	movw	r0, #1537	; 0x601
  2006d2:	4282      	cmp	r2, r0
  2006d4:	d92c      	bls.n	200730 <_usb_ep0setup+0x1a0>
  2006d6:	f5b2 6f10 	cmp.w	r2, #2304	; 0x900
  2006da:	d063      	beq.n	2007a4 <_usb_ep0setup+0x214>
  2006dc:	f640 4102 	movw	r1, #3074	; 0xc02
  2006e0:	428a      	cmp	r2, r1
  2006e2:	f000 80f0 	beq.w	2008c6 <_usb_ep0setup+0x336>
  2006e6:	f5b2 6f00 	cmp.w	r2, #2048	; 0x800
  2006ea:	d196      	bne.n	20061a <_usb_ep0setup+0x8a>
    usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
  2006ec:	f104 0167 	add.w	r1, r4, #103	; 0x67
  2006f0:	2201      	movs	r2, #1
  2006f2:	65a5      	str	r5, [r4, #88]	; 0x58
  2006f4:	6521      	str	r1, [r4, #80]	; 0x50
  2006f6:	4611      	mov	r1, r2
  2006f8:	6562      	str	r2, [r4, #84]	; 0x54
  2006fa:	e762      	b.n	2005c2 <_usb_ep0setup+0x32>
    if (usbp->ep0n != 0U) {
  2006fc:	b362      	cbz	r2, 200758 <_usb_ep0setup+0x1c8>
      usbp->ep0state = USB_EP0_IN_TX;
  2006fe:	2209      	movs	r2, #9
  200700:	2320      	movs	r3, #32
  200702:	f884 204c 	strb.w	r2, [r4, #76]	; 0x4c
  200706:	f383 8811 	msr	BASEPRI, r3
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
  20070a:	8922      	ldrh	r2, [r4, #8]
  isp->txcnt  = 0;
  20070c:	2500      	movs	r5, #0
  isp = usbp->epc[ep]->in_state;
  20070e:	68e3      	ldr	r3, [r4, #12]
  usb_lld_start_in(usbp, ep);
  200710:	4620      	mov	r0, r4
      usbStartTransmitI(usbp, 0, usbp->ep0next, usbp->ep0n);
  200712:	6d27      	ldr	r7, [r4, #80]	; 0x50
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
  200714:	f042 0201 	orr.w	r2, r2, #1
  isp = usbp->epc[ep]->in_state;
  200718:	695b      	ldr	r3, [r3, #20]
  usb_lld_start_in(usbp, ep);
  20071a:	4629      	mov	r1, r5
      usbStartTransmitI(usbp, 0, usbp->ep0next, usbp->ep0n);
  20071c:	6d66      	ldr	r6, [r4, #84]	; 0x54
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
  20071e:	8122      	strh	r2, [r4, #8]
  isp->txbuf  = buf;
  200720:	609f      	str	r7, [r3, #8]
  isp->txsize = n;
  200722:	601e      	str	r6, [r3, #0]
  isp->txcnt  = 0;
  200724:	605d      	str	r5, [r3, #4]
  usb_lld_start_in(usbp, ep);
  200726:	f003 f823 	bl	203770 <usb_lld_start_in>
  20072a:	f385 8811 	msr	BASEPRI, r5
  20072e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
  200730:	f5b2 6fc0 	cmp.w	r2, #1536	; 0x600
  200734:	d24d      	bcs.n	2007d2 <_usb_ep0setup+0x242>
  200736:	f5b2 6fa0 	cmp.w	r2, #1280	; 0x500
  20073a:	f47f af6e 	bne.w	20061a <_usb_ep0setup+0x8a>
    if ((usbp->setup[0] == USB_RTYPE_RECIPIENT_DEVICE) &&
  20073e:	f8b4 305c 	ldrh.w	r3, [r4, #92]	; 0x5c
  200742:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
  200746:	f000 80f8 	beq.w	20093a <_usb_ep0setup+0x3aa>
    usbSetupTransfer(usbp, NULL, 0, NULL);
  20074a:	2300      	movs	r3, #0
  20074c:	6523      	str	r3, [r4, #80]	; 0x50
  20074e:	6563      	str	r3, [r4, #84]	; 0x54
  200750:	65a3      	str	r3, [r4, #88]	; 0x58
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
  200752:	060b      	lsls	r3, r1, #24
  200754:	f57f af44 	bpl.w	2005e0 <_usb_ep0setup+0x50>
      usbp->ep0state = USB_EP0_OUT_WAITING_STS;
  200758:	2214      	movs	r2, #20
  20075a:	2320      	movs	r3, #32
  20075c:	f884 204c 	strb.w	r2, [r4, #76]	; 0x4c
  200760:	f383 8811 	msr	BASEPRI, r3
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
  200764:	8962      	ldrh	r2, [r4, #10]
  osp->rxbuf  = buf;
  200766:	2500      	movs	r5, #0
  osp = usbp->epc[ep]->out_state;
  200768:	68e3      	ldr	r3, [r4, #12]
  usb_lld_start_out(usbp, ep);
  20076a:	4620      	mov	r0, r4
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
  20076c:	f042 0201 	orr.w	r2, r2, #1
  usb_lld_start_out(usbp, ep);
  200770:	4629      	mov	r1, r5
  osp = usbp->epc[ep]->out_state;
  200772:	699b      	ldr	r3, [r3, #24]
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
  200774:	8162      	strh	r2, [r4, #10]
  osp->rxbuf  = buf;
  200776:	609d      	str	r5, [r3, #8]
  osp->rxsize = n;
  200778:	601d      	str	r5, [r3, #0]
  osp->rxcnt  = 0;
  20077a:	605d      	str	r5, [r3, #4]
  usb_lld_start_out(usbp, ep);
  20077c:	f003 f850 	bl	203820 <usb_lld_start_out>
  200780:	f385 8811 	msr	BASEPRI, r5
  200784:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
  200786:	f894 305e 	ldrb.w	r3, [r4, #94]	; 0x5e
  20078a:	2b01      	cmp	r3, #1
  20078c:	f47f af45 	bne.w	20061a <_usb_ep0setup+0x8a>
      usbp->status |= 2U;
  200790:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
      usbSetupTransfer(usbp, NULL, 0, NULL);
  200794:	6525      	str	r5, [r4, #80]	; 0x50
      usbp->status |= 2U;
  200796:	f043 0302 	orr.w	r3, r3, #2
      usbSetupTransfer(usbp, NULL, 0, NULL);
  20079a:	6565      	str	r5, [r4, #84]	; 0x54
  20079c:	65a5      	str	r5, [r4, #88]	; 0x58
      usbp->status |= 2U;
  20079e:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
  2007a2:	e7d6      	b.n	200752 <_usb_ep0setup+0x1c2>
    if (usbp->configuration != usbp->setup[2]) {
  2007a4:	f894 305e 	ldrb.w	r3, [r4, #94]	; 0x5e
  2007a8:	f894 2067 	ldrb.w	r2, [r4, #103]	; 0x67
  2007ac:	429a      	cmp	r2, r3
  2007ae:	d0cc      	beq.n	20074a <_usb_ep0setup+0x1ba>
      if (usbp->state == USB_ACTIVE) {
  2007b0:	7822      	ldrb	r2, [r4, #0]
  2007b2:	2a04      	cmp	r2, #4
  2007b4:	d026      	beq.n	200804 <_usb_ep0setup+0x274>
      if (usbp->setup[2] != 0U) {
  2007b6:	b14b      	cbz	r3, 2007cc <_usb_ep0setup+0x23c>
        usbp->state = USB_ACTIVE;
  2007b8:	2104      	movs	r1, #4
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
  2007ba:	6862      	ldr	r2, [r4, #4]
        usbp->configuration = usbp->setup[2];
  2007bc:	f884 3067 	strb.w	r3, [r4, #103]	; 0x67
        usbp->state = USB_ACTIVE;
  2007c0:	7021      	strb	r1, [r4, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
  2007c2:	6813      	ldr	r3, [r2, #0]
  2007c4:	b113      	cbz	r3, 2007cc <_usb_ep0setup+0x23c>
  2007c6:	2102      	movs	r1, #2
  2007c8:	4620      	mov	r0, r4
  2007ca:	4798      	blx	r3
  2007cc:	f894 105c 	ldrb.w	r1, [r4, #92]	; 0x5c
  2007d0:	e7bb      	b.n	20074a <_usb_ep0setup+0x1ba>
  hw |= (uint16_t)*p << 8U;
  2007d2:	f894 2061 	ldrb.w	r2, [r4, #97]	; 0x61
    dp = usbp->config->get_descriptor_cb(usbp, usbp->setup[3],
  2007d6:	4620      	mov	r0, r4
  2007d8:	6861      	ldr	r1, [r4, #4]
  hw |= (uint16_t)*p << 8U;
  2007da:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
    dp = usbp->config->get_descriptor_cb(usbp, usbp->setup[3],
  2007de:	684e      	ldr	r6, [r1, #4]
  2007e0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  2007e4:	f894 105f 	ldrb.w	r1, [r4, #95]	; 0x5f
  2007e8:	f894 205e 	ldrb.w	r2, [r4, #94]	; 0x5e
  2007ec:	47b0      	blx	r6
    if (dp == NULL) {
  2007ee:	2800      	cmp	r0, #0
  2007f0:	f43f af13 	beq.w	20061a <_usb_ep0setup+0x8a>
    usbSetupTransfer(usbp, (uint8_t *)dp->ud_string, dp->ud_size, NULL);
  2007f4:	e890 000a 	ldmia.w	r0, {r1, r3}
  2007f8:	65a5      	str	r5, [r4, #88]	; 0x58
  2007fa:	6523      	str	r3, [r4, #80]	; 0x50
  2007fc:	6561      	str	r1, [r4, #84]	; 0x54
  2007fe:	f894 305c 	ldrb.w	r3, [r4, #92]	; 0x5c
  200802:	e6de      	b.n	2005c2 <_usb_ep0setup+0x32>
  200804:	2320      	movs	r3, #32
  200806:	f383 8811 	msr	BASEPRI, r3
  20080a:	6f26      	ldr	r6, [r4, #112]	; 0x70
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
  20080c:	4629      	mov	r1, r5
  usbp->transmitting &= 1U;
  20080e:	8927      	ldrh	r7, [r4, #8]
    otgp->ie[i].DIEPCTL = 0;
  200810:	462a      	mov	r2, r5
  usbp->pmnext = usbp->otgparams->rx_fifo_size;
  200812:	6833      	ldr	r3, [r6, #0]
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
  200814:	f04f 30ff 	mov.w	r0, #4294967295
  usbp->receiving    &= 1U;
  200818:	f8b4 e00a 	ldrh.w	lr, [r4, #10]
  usbp->transmitting &= 1U;
  20081c:	f007 0701 	and.w	r7, r7, #1
  usbp->pmnext = usbp->otgparams->rx_fifo_size;
  200820:	6763      	str	r3, [r4, #116]	; 0x74
  usbp->receiving    &= 1U;
  200822:	f00e 0301 	and.w	r3, lr, #1
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
  200826:	68b6      	ldr	r6, [r6, #8]
    usbp->epc[i] = NULL;
  200828:	6125      	str	r5, [r4, #16]
  20082a:	6165      	str	r5, [r4, #20]
  20082c:	61a5      	str	r5, [r4, #24]
  20082e:	61e5      	str	r5, [r4, #28]
  200830:	6225      	str	r5, [r4, #32]
  200832:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
  usbp->transmitting &= 1U;
  200834:	8127      	strh	r7, [r4, #8]
  usbp->receiving    &= 1U;
  200836:	8163      	strh	r3, [r4, #10]
  200838:	eb05 1341 	add.w	r3, r5, r1, lsl #5
  20083c:	3101      	adds	r1, #1
  20083e:	428e      	cmp	r6, r1
    otgp->ie[i].DIEPCTL = 0;
  200840:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
    otgp->ie[i].DIEPTSIZ = 0;
  200844:	f8c3 2910 	str.w	r2, [r3, #2320]	; 0x910
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
  200848:	f8c3 0908 	str.w	r0, [r3, #2312]	; 0x908
    otgp->oe[i].DOEPCTL = 0;
  20084c:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
    otgp->oe[i].DOEPTSIZ = 0;
  200850:	f8c3 2b10 	str.w	r2, [r3, #2832]	; 0xb10
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
  200854:	f8c3 0b08 	str.w	r0, [r3, #2824]	; 0xb08
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
  200858:	d2ee      	bcs.n	200838 <_usb_ep0setup+0x2a8>
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
  20085a:	f04f 1301 	mov.w	r3, #65537	; 0x10001
  20085e:	f8c5 381c 	str.w	r3, [r5, #2076]	; 0x81c
  200862:	f382 8811 	msr	BASEPRI, r2
        usbp->state = USB_SELECTED;
  200866:	2103      	movs	r1, #3
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
  200868:	6863      	ldr	r3, [r4, #4]
        usbp->configuration = 0U;
  20086a:	f884 2067 	strb.w	r2, [r4, #103]	; 0x67
        usbp->state = USB_SELECTED;
  20086e:	7021      	strb	r1, [r4, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
  200870:	681b      	ldr	r3, [r3, #0]
  200872:	b10b      	cbz	r3, 200878 <_usb_ep0setup+0x2e8>
  200874:	4620      	mov	r0, r4
  200876:	4798      	blx	r3
  200878:	f894 305e 	ldrb.w	r3, [r4, #94]	; 0x5e
  20087c:	e79b      	b.n	2007b6 <_usb_ep0setup+0x226>
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
  20087e:	b9fa      	cbnz	r2, 2008c0 <_usb_ep0setup+0x330>
    usbSetupTransfer(usbp, (uint8_t *)&usbp->status, 2, NULL);
  200880:	f104 0164 	add.w	r1, r4, #100	; 0x64
  200884:	2002      	movs	r0, #2
  200886:	65a2      	str	r2, [r4, #88]	; 0x58
  200888:	6521      	str	r1, [r4, #80]	; 0x50
  20088a:	4601      	mov	r1, r0
  20088c:	6560      	str	r0, [r4, #84]	; 0x54
  20088e:	e698      	b.n	2005c2 <_usb_ep0setup+0x32>
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
  200890:	f894 305e 	ldrb.w	r3, [r4, #94]	; 0x5e
  200894:	2b00      	cmp	r3, #0
  200896:	f47f aec0 	bne.w	20061a <_usb_ep0setup+0x8a>
    if ((usbp->setup[4] & 0x0FU) != 0U) {
  20089a:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
  20089e:	f013 020f 	ands.w	r2, r3, #15
  2008a2:	f43f af52 	beq.w	20074a <_usb_ep0setup+0x1ba>
      if ((usbp->setup[4] & 0x80U) != 0U) {
  2008a6:	f013 0f80 	tst.w	r3, #128	; 0x80
  2008aa:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
  2008ac:	eb03 1342 	add.w	r3, r3, r2, lsl #5
  2008b0:	d15b      	bne.n	20096a <_usb_ep0setup+0x3da>
 *
 * @notapi
 */
void usb_lld_clear_out(USBDriver *usbp, usbep_t ep) {

  usbp->otg->oe[ep].DOEPCTL &= ~DOEPCTL_STALL;
  2008b2:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	; 0xb00
  2008b6:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
  2008ba:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
  2008be:	e744      	b.n	20074a <_usb_ep0setup+0x1ba>
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
  2008c0:	2a01      	cmp	r2, #1
  2008c2:	f47f aeaa 	bne.w	20061a <_usb_ep0setup+0x8a>
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
  2008c6:	4930      	ldr	r1, [pc, #192]	; (200988 <_usb_ep0setup+0x3f8>)
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
  2008c8:	2202      	movs	r2, #2
  2008ca:	2000      	movs	r0, #0
  2008cc:	6521      	str	r1, [r4, #80]	; 0x50
  2008ce:	6562      	str	r2, [r4, #84]	; 0x54
  2008d0:	4611      	mov	r1, r2
  2008d2:	65a0      	str	r0, [r4, #88]	; 0x58
  2008d4:	e675      	b.n	2005c2 <_usb_ep0setup+0x32>
    if ((usbp->setup[4] & 0x80U) != 0U) {
  2008d6:	f894 2060 	ldrb.w	r2, [r4, #96]	; 0x60
  2008da:	f012 0f80 	tst.w	r2, #128	; 0x80
  ctl = usbp->otg->ie[ep].DIEPCTL;
  2008de:	f002 010f 	and.w	r1, r2, #15
  2008e2:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
  2008e4:	d123      	bne.n	20092e <_usb_ep0setup+0x39e>
  ctl = usbp->otg->oe[ep].DOEPCTL;
  2008e6:	3158      	adds	r1, #88	; 0x58
  2008e8:	0149      	lsls	r1, r1, #5
  2008ea:	5851      	ldr	r1, [r2, r1]
  if (!(ctl & DOEPCTL_USBAEP))
  2008ec:	040d      	lsls	r5, r1, #16
  2008ee:	f57f ae95 	bpl.w	20061c <_usb_ep0setup+0x8c>
  if (ctl & DOEPCTL_STALL)
  2008f2:	0288      	lsls	r0, r1, #10
  2008f4:	d419      	bmi.n	20092a <_usb_ep0setup+0x39a>
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
  2008f6:	4925      	ldr	r1, [pc, #148]	; (20098c <_usb_ep0setup+0x3fc>)
  2008f8:	e7e6      	b.n	2008c8 <_usb_ep0setup+0x338>
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
  2008fa:	f894 305e 	ldrb.w	r3, [r4, #94]	; 0x5e
  2008fe:	2b00      	cmp	r3, #0
  200900:	f47f ae8b 	bne.w	20061a <_usb_ep0setup+0x8a>
    if ((usbp->setup[4] & 0x0FU) != 0U) {
  200904:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
  200908:	f013 020f 	ands.w	r2, r3, #15
  20090c:	f43f af1d 	beq.w	20074a <_usb_ep0setup+0x1ba>
      if ((usbp->setup[4] & 0x80U) != 0U) {
  200910:	f013 0f80 	tst.w	r3, #128	; 0x80
  200914:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
  200916:	eb03 1342 	add.w	r3, r3, r2, lsl #5
  20091a:	d12d      	bne.n	200978 <_usb_ep0setup+0x3e8>
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
  20091c:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	; 0xb00
  200920:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
  200924:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
  200928:	e70f      	b.n	20074a <_usb_ep0setup+0x1ba>
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
  20092a:	4919      	ldr	r1, [pc, #100]	; (200990 <_usb_ep0setup+0x400>)
  20092c:	e7cc      	b.n	2008c8 <_usb_ep0setup+0x338>
  ctl = usbp->otg->ie[ep].DIEPCTL;
  20092e:	3148      	adds	r1, #72	; 0x48
  200930:	0149      	lsls	r1, r1, #5
  200932:	5851      	ldr	r1, [r2, r1]
  if (!(ctl & DIEPCTL_USBAEP))
  200934:	040e      	lsls	r6, r1, #16
  200936:	d4dc      	bmi.n	2008f2 <_usb_ep0setup+0x362>
  200938:	e670      	b.n	20061c <_usb_ep0setup+0x8c>
  usbp->address = usbp->setup[2];
  20093a:	f894 005e 	ldrb.w	r0, [r4, #94]	; 0x5e
  stm32_otg_t *otgp = usbp->otg;
  20093e:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
  200940:	f884 0066 	strb.w	r0, [r4, #102]	; 0x66
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(usbp->address);
  200944:	f8d2 3800 	ldr.w	r3, [r2, #2048]	; 0x800
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_ADDRESS);
  200948:	6865      	ldr	r5, [r4, #4]
  20094a:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
  20094e:	682d      	ldr	r5, [r5, #0]
  200950:	ea43 1300 	orr.w	r3, r3, r0, lsl #4
  200954:	f8c2 3800 	str.w	r3, [r2, #2048]	; 0x800
  200958:	b125      	cbz	r5, 200964 <_usb_ep0setup+0x3d4>
  20095a:	2101      	movs	r1, #1
  20095c:	4620      	mov	r0, r4
  20095e:	47a8      	blx	r5
  200960:	f894 105c 	ldrb.w	r1, [r4, #92]	; 0x5c
  usbp->state = USB_SELECTED;
  200964:	2303      	movs	r3, #3
  200966:	7023      	strb	r3, [r4, #0]
  200968:	e6ef      	b.n	20074a <_usb_ep0setup+0x1ba>
 *
 * @notapi
 */
void usb_lld_clear_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL &= ~DIEPCTL_STALL;
  20096a:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
  20096e:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
  200972:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
  200976:	e6e8      	b.n	20074a <_usb_ep0setup+0x1ba>
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
  200978:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
  20097c:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
  200980:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
  200984:	e6e1      	b.n	20074a <_usb_ep0setup+0x1ba>
  200986:	bf00      	nop
  200988:	08003c38 	.word	0x08003c38
  20098c:	08003bb0 	.word	0x08003bb0
  200990:	08003bb4 	.word	0x08003bb4
	...

002009a0 <chSchGoSleepS>:
  thread_t *otp = currp;
  2009a0:	4b08      	ldr	r3, [pc, #32]	; (2009c4 <chSchGoSleepS+0x24>)
  thread_t *tp = tqp->next;
  2009a2:	681a      	ldr	r2, [r3, #0]
  2009a4:	6999      	ldr	r1, [r3, #24]
void chSchGoSleepS(tstate_t newstate) {
  2009a6:	b430      	push	{r4, r5}
  otp->state = newstate;
  2009a8:	f881 0020 	strb.w	r0, [r1, #32]
  currp->state = CH_STATE_CURRENT;
  2009ac:	2501      	movs	r5, #1
  tqp->next             = tp->queue.next;
  2009ae:	6814      	ldr	r4, [r2, #0]
  chSysSwitch(currp, otp);
  2009b0:	4610      	mov	r0, r2
  tqp->next->queue.prev = (thread_t *)tqp;
  2009b2:	6063      	str	r3, [r4, #4]
  tqp->next             = tp->queue.next;
  2009b4:	601c      	str	r4, [r3, #0]
  currp->state = CH_STATE_CURRENT;
  2009b6:	f882 5020 	strb.w	r5, [r2, #32]
  currp = queue_fifo_remove(&ch.rlist.queue);
  2009ba:	619a      	str	r2, [r3, #24]
}
  2009bc:	bc30      	pop	{r4, r5}
  chSysSwitch(currp, otp);
  2009be:	f7ff bc8f 	b.w	2002e0 <_port_switch>
  2009c2:	bf00      	nop
  2009c4:	200012a0 	.word	0x200012a0
	...

002009d0 <chSchGoSleepTimeoutS>:
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {

  chDbgCheckClassS();

  if (TIME_INFINITE != timeout) {
  2009d0:	1c4b      	adds	r3, r1, #1
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
  2009d2:	b5f0      	push	{r4, r5, r6, r7, lr}
  2009d4:	b087      	sub	sp, #28
  if (TIME_INFINITE != timeout) {
  2009d6:	d049      	beq.n	200a6c <chSchGoSleepTimeoutS+0x9c>
    virtual_timer_t vt;

    chVTDoSetI(&vt, timeout, wakeup, currp);
  2009d8:	4c42      	ldr	r4, [pc, #264]	; (200ae4 <chSchGoSleepTimeoutS+0x114>)
  2009da:	2902      	cmp	r1, #2

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->par = par;
  vtp->func = vtfunc;
  2009dc:	4a42      	ldr	r2, [pc, #264]	; (200ae8 <chSchGoSleepTimeoutS+0x118>)
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
  2009de:	f04f 4e80 	mov.w	lr, #1073741824	; 0x40000000
    if (delay < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
      delay = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
  2009e2:	4625      	mov	r5, r4
  vtp->par = par;
  2009e4:	69a3      	ldr	r3, [r4, #24]
  vtp->func = vtfunc;
  2009e6:	9204      	str	r2, [sp, #16]
  2009e8:	bf38      	it	cc
  2009ea:	2102      	movcc	r1, #2
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
  2009ec:	f855 2f1c 	ldr.w	r2, [r5, #28]!
  2009f0:	4607      	mov	r7, r0
  vtp->par = par;
  2009f2:	9305      	str	r3, [sp, #20]
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
  2009f4:	42aa      	cmp	r2, r5
  2009f6:	f8de 3024 	ldr.w	r3, [lr, #36]	; 0x24
  2009fa:	d05d      	beq.n	200ab8 <chSchGoSleepTimeoutS+0xe8>
    /* Pointer to the first element in the delta list, which is non-empty.*/
    p = ch.vtlist.next;

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'now'.*/
    delta = chTimeDiffX(ch.vtlist.lasttime, now) + delay;
  2009fc:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
  2009fe:	1a1b      	subs	r3, r3, r0

    if (delta < chTimeDiffX(ch.vtlist.lasttime, now)) {
  200a00:	18c9      	adds	r1, r1, r3
      /* Scenario where a very large delay excedeed the numeric range, it
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
  200a02:	6893      	ldr	r3, [r2, #8]
    if (delta < chTimeDiffX(ch.vtlist.lasttime, now)) {
  200a04:	d22e      	bcs.n	200a64 <chSchGoSleepTimeoutS+0x94>
      p = p->next;
    }
    else if (delta < p->delta) {
  200a06:	4299      	cmp	r1, r3
  200a08:	d337      	bcc.n	200a7a <chSchGoSleepTimeoutS+0xaa>
  p = ch.vtlist.next;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
  200a0a:	4299      	cmp	r1, r3
  200a0c:	d904      	bls.n	200a18 <chSchGoSleepTimeoutS+0x48>
    /* Debug assert if the timer is already in the list.*/
    chDbgAssert(p != vtp, "timer already armed");

    delta -= p->delta;
    p = p->next;
  200a0e:	6812      	ldr	r2, [r2, #0]
    delta -= p->delta;
  200a10:	1ac9      	subs	r1, r1, r3
  while (p->delta < delta) {
  200a12:	6893      	ldr	r3, [r2, #8]
  200a14:	428b      	cmp	r3, r1
  200a16:	d3fa      	bcc.n	200a0e <chSchGoSleepTimeoutS+0x3e>
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
  vtp->prev = vtp->next->prev;
  200a18:	6853      	ldr	r3, [r2, #4]
  vtp->prev->next = vtp;
  200a1a:	ae01      	add	r6, sp, #4
  vtp->next = p;
  200a1c:	9201      	str	r2, [sp, #4]
  /* Calculate new delta for the following entry.*/
  p->delta -= delta;

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/
  ch.vtlist.delta = (sysinterval_t)-1;
  200a1e:	f04f 30ff 	mov.w	r0, #4294967295
  vtp->prev = vtp->next->prev;
  200a22:	9302      	str	r3, [sp, #8]
  vtp->prev->next = vtp;
  200a24:	601e      	str	r6, [r3, #0]
  p->prev = vtp;
  200a26:	6056      	str	r6, [r2, #4]
  vtp->delta = delta;
  200a28:	9103      	str	r1, [sp, #12]
  p->delta -= delta;
  200a2a:	6893      	ldr	r3, [r2, #8]
  200a2c:	1a59      	subs	r1, r3, r1
  200a2e:	6091      	str	r1, [r2, #8]
  ch.vtlist.delta = (sysinterval_t)-1;
  200a30:	6260      	str	r0, [r4, #36]	; 0x24
    chSchGoSleepS(newstate);
  200a32:	4638      	mov	r0, r7
  200a34:	f7ff ffb4 	bl	2009a0 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
  200a38:	9b04      	ldr	r3, [sp, #16]
  200a3a:	b17b      	cbz	r3, 200a5c <chSchGoSleepTimeoutS+0x8c>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  sysinterval_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
  200a3c:	69e3      	ldr	r3, [r4, #28]
  200a3e:	42b3      	cmp	r3, r6
  200a40:	d01f      	beq.n	200a82 <chSchGoSleepTimeoutS+0xb2>
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
  200a42:	9a02      	ldr	r2, [sp, #8]
    vtp->next->prev = vtp->prev;
    vtp->func = NULL;
  200a44:	2100      	movs	r1, #0
    vtp->prev->next = vtp->next;
  200a46:	9b01      	ldr	r3, [sp, #4]
  200a48:	6013      	str	r3, [r2, #0]
    vtp->next->prev = vtp->prev;
  200a4a:	9b01      	ldr	r3, [sp, #4]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
  200a4c:	42ab      	cmp	r3, r5
    vtp->next->prev = vtp->prev;
  200a4e:	605a      	str	r2, [r3, #4]
    vtp->func = NULL;
  200a50:	9104      	str	r1, [sp, #16]
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
  200a52:	d003      	beq.n	200a5c <chSchGoSleepTimeoutS+0x8c>
      vtp->next->delta += vtp->delta;
  200a54:	689a      	ldr	r2, [r3, #8]
  200a56:	9903      	ldr	r1, [sp, #12]
  200a58:	440a      	add	r2, r1
  200a5a:	609a      	str	r2, [r3, #8]
  }
  else {
    chSchGoSleepS(newstate);
  }

  return currp->u.rdymsg;
  200a5c:	69a3      	ldr	r3, [r4, #24]
}
  200a5e:	6a58      	ldr	r0, [r3, #36]	; 0x24
  200a60:	b007      	add	sp, #28
  200a62:	bdf0      	pop	{r4, r5, r6, r7, pc}
      p = p->next;
  200a64:	6812      	ldr	r2, [r2, #0]
      delta -= p->delta;
  200a66:	1ac9      	subs	r1, r1, r3
  200a68:	6893      	ldr	r3, [r2, #8]
  200a6a:	e7ce      	b.n	200a0a <chSchGoSleepTimeoutS+0x3a>
  200a6c:	4c1d      	ldr	r4, [pc, #116]	; (200ae4 <chSchGoSleepTimeoutS+0x114>)
    chSchGoSleepS(newstate);
  200a6e:	f7ff ff97 	bl	2009a0 <chSchGoSleepS>
  return currp->u.rdymsg;
  200a72:	69a3      	ldr	r3, [r4, #24]
}
  200a74:	6a58      	ldr	r0, [r3, #36]	; 0x24
  200a76:	b007      	add	sp, #28
  200a78:	bdf0      	pop	{r4, r5, r6, r7, pc}
  return systime + (systime_t)interval;
  200a7a:	4408      	add	r0, r1
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
  200a7c:	f8ce 0034 	str.w	r0, [lr, #52]	; 0x34
  200a80:	e7c3      	b.n	200a0a <chSchGoSleepTimeoutS+0x3a>

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
  200a82:	9b01      	ldr	r3, [sp, #4]
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
  vtp->func = NULL;
  200a84:	2200      	movs	r2, #0

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
  200a86:	42ab      	cmp	r3, r5
  ch.vtlist.next = vtp->next;
  200a88:	61e3      	str	r3, [r4, #28]
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
  200a8a:	605d      	str	r5, [r3, #4]
  vtp->func = NULL;
  200a8c:	9204      	str	r2, [sp, #16]
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
  200a8e:	d024      	beq.n	200ada <chSchGoSleepTimeoutS+0x10a>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.next->delta += vtp->delta;
  200a90:	689a      	ldr	r2, [r3, #8]
  return (systime_t)STM32_ST_TIM->CNT;
  200a92:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
  200a96:	9d03      	ldr	r5, [sp, #12]
/*  if (ch.vtlist.next->delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chTimeDiffX(ch.vtlist.lasttime, chVTGetSystemTimeX());
  200a98:	6aa1      	ldr	r1, [r4, #40]	; 0x28
  ch.vtlist.next->delta += vtp->delta;
  200a9a:	442a      	add	r2, r5
  200a9c:	609a      	str	r2, [r3, #8]
  200a9e:	6a43      	ldr	r3, [r0, #36]	; 0x24
  return (sysinterval_t)((systime_t)(end - start));
  200aa0:	1a5b      	subs	r3, r3, r1

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.next->delta) {
  200aa2:	429a      	cmp	r2, r3
  200aa4:	d9da      	bls.n	200a5c <chSchGoSleepTimeoutS+0x8c>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.next->delta - nowdelta;
  200aa6:	1ad0      	subs	r0, r2, r3

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
  200aa8:	2801      	cmp	r0, #1
    delta = nowdelta + (sysinterval_t)CH_CFG_ST_TIMEDELTA;
  200aaa:	bf98      	it	ls
  200aac:	1c9a      	addls	r2, r3, #2
  STM32_ST_TIM->CCR[0] = (uint32_t)time;
  200aae:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  return systime + (systime_t)interval;
  200ab2:	440a      	add	r2, r1
  200ab4:	635a      	str	r2, [r3, #52]	; 0x34
  200ab6:	e7d1      	b.n	200a5c <chSchGoSleepTimeoutS+0x8c>
      ch.vtlist.lasttime = now;
  200ab8:	62a3      	str	r3, [r4, #40]	; 0x28
  200aba:	18c8      	adds	r0, r1, r3
      ch.vtlist.next = vtp;
  200abc:	ae01      	add	r6, sp, #4
  STM32_ST_TIM->SR     = 0;
  200abe:	2200      	movs	r2, #0
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
  200ac0:	2302      	movs	r3, #2
      vtp->next = (virtual_timer_t *)&ch.vtlist;
  200ac2:	9501      	str	r5, [sp, #4]
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
  200ac4:	9502      	str	r5, [sp, #8]
      vtp->delta = delay;
  200ac6:	9103      	str	r1, [sp, #12]
      ch.vtlist.next = vtp;
  200ac8:	61e6      	str	r6, [r4, #28]
      ch.vtlist.prev = vtp;
  200aca:	6226      	str	r6, [r4, #32]
  STM32_ST_TIM->CCR[0] = (uint32_t)time;
  200acc:	f8ce 0034 	str.w	r0, [lr, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
  200ad0:	f8ce 2010 	str.w	r2, [lr, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
  200ad4:	f8ce 300c 	str.w	r3, [lr, #12]
  200ad8:	e7ab      	b.n	200a32 <chSchGoSleepTimeoutS+0x62>
  STM32_ST_TIM->DIER = 0;
  200ada:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  200ade:	60da      	str	r2, [r3, #12]
  200ae0:	e7bc      	b.n	200a5c <chSchGoSleepTimeoutS+0x8c>
  200ae2:	bf00      	nop
  200ae4:	200012a0 	.word	0x200012a0
  200ae8:	00200401 	.word	0x00200401
  200aec:	00000000 	.word	0x00000000

00200af0 <ibqGetFullBufferTimeoutS>:
   *                      suspended state.
   *
   * @sclass
   */
  msg_t ibqGetFullBufferTimeoutS(input_buffers_queue_t *ibqp,
                                 sysinterval_t timeout) {
  200af0:	b570      	push	{r4, r5, r6, lr}
  200af2:	4604      	mov	r4, r0
  200af4:	460d      	mov	r5, r1

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
  200af6:	4e11      	ldr	r6, [pc, #68]	; (200b3c <ibqGetFullBufferTimeoutS+0x4c>)
  200af8:	e009      	b.n	200b0e <ibqGetFullBufferTimeoutS+0x1e>
  200afa:	69b3      	ldr	r3, [r6, #24]
  tp->queue.prev             = tqp->prev;
  200afc:	6862      	ldr	r2, [r4, #4]
  tp->queue.next             = (thread_t *)tqp;
  200afe:	601c      	str	r4, [r3, #0]
  tp->queue.prev             = tqp->prev;
  200b00:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
  200b02:	6013      	str	r3, [r2, #0]
  tqp->prev                  = tp;
  200b04:	6063      	str	r3, [r4, #4]

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
  200b06:	f7ff ff63 	bl	2009d0 <chSchGoSleepTimeoutS>
  while (ibqIsEmptyI(ibqp)) {
    if (ibqp->suspended) {
      return MSG_RESET;
    }
    msg_t msg = osalThreadEnqueueTimeoutS(&ibqp->waiting, timeout);
    if (msg < MSG_OK) {
  200b0a:	2800      	cmp	r0, #0
  200b0c:	db09      	blt.n	200b22 <ibqGetFullBufferTimeoutS+0x32>
  while (ibqIsEmptyI(ibqp)) {
  200b0e:	68e3      	ldr	r3, [r4, #12]
  200b10:	4629      	mov	r1, r5
  200b12:	2004      	movs	r0, #4
  200b14:	b933      	cbnz	r3, 200b24 <ibqGetFullBufferTimeoutS+0x34>
    if (ibqp->suspended) {
  200b16:	7a23      	ldrb	r3, [r4, #8]
  200b18:	b963      	cbnz	r3, 200b34 <ibqGetFullBufferTimeoutS+0x44>
  if (TIME_IMMEDIATE == timeout) {
  200b1a:	2d00      	cmp	r5, #0
  200b1c:	d1ed      	bne.n	200afa <ibqGetFullBufferTimeoutS+0xa>
    return MSG_TIMEOUT;
  200b1e:	f04f 30ff 	mov.w	r0, #4294967295
  /* Setting up the "current" buffer and its boundary.*/
  ibqp->ptr = ibqp->brdptr + sizeof (size_t);
  ibqp->top = ibqp->ptr + *((size_t *)ibqp->brdptr);

  return MSG_OK;
}
  200b22:	bd70      	pop	{r4, r5, r6, pc}
  ibqp->ptr = ibqp->brdptr + sizeof (size_t);
  200b24:	6963      	ldr	r3, [r4, #20]
  ibqp->top = ibqp->ptr + *((size_t *)ibqp->brdptr);
  200b26:	2000      	movs	r0, #0
  ibqp->ptr = ibqp->brdptr + sizeof (size_t);
  200b28:	1d1a      	adds	r2, r3, #4
  ibqp->top = ibqp->ptr + *((size_t *)ibqp->brdptr);
  200b2a:	681b      	ldr	r3, [r3, #0]
  200b2c:	4413      	add	r3, r2
  ibqp->ptr = ibqp->brdptr + sizeof (size_t);
  200b2e:	62a2      	str	r2, [r4, #40]	; 0x28
  ibqp->top = ibqp->ptr + *((size_t *)ibqp->brdptr);
  200b30:	62e3      	str	r3, [r4, #44]	; 0x2c
  200b32:	bd70      	pop	{r4, r5, r6, pc}
      return MSG_RESET;
  200b34:	f06f 0001 	mvn.w	r0, #1
  200b38:	bd70      	pop	{r4, r5, r6, pc}
  200b3a:	bf00      	nop
  200b3c:	200012a0 	.word	0x200012a0

00200b40 <ibqReadTimeout>:
 * @retval 0            if a timeout occurred.
 *
 * @api
 */
size_t ibqReadTimeout(input_buffers_queue_t *ibqp, uint8_t *bp,
                      size_t n, sysinterval_t timeout) {
  200b40:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  200b44:	4698      	mov	r8, r3
  200b46:	b083      	sub	sp, #12
  200b48:	4604      	mov	r4, r0
  200b4a:	460d      	mov	r5, r1
  200b4c:	4616      	mov	r6, r2
  200b4e:	2320      	movs	r3, #32
  200b50:	f383 8811 	msr	BASEPRI, r3
  return (systime_t)STM32_ST_TIM->CNT;
  200b54:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  size_t r = 0;
  200b58:	f04f 0a00 	mov.w	sl, #0

  while (true) {
    size_t size;

    /* This condition indicates that a new buffer must be acquired.*/
    if (ibqp->ptr == NULL) {
  200b5c:	6aa1      	ldr	r1, [r4, #40]	; 0x28
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
  200b5e:	f108 39ff 	add.w	r9, r8, #4294967295
  200b62:	6a5a      	ldr	r2, [r3, #36]	; 0x24
  ibqp->ptr = NULL;
  200b64:	4657      	mov	r7, sl
  200b66:	9301      	str	r3, [sp, #4]
  200b68:	eb08 0302 	add.w	r3, r8, r2
  200b6c:	9300      	str	r3, [sp, #0]
    if (ibqp->ptr == NULL) {
  200b6e:	2900      	cmp	r1, #0
  200b70:	d044      	beq.n	200bfc <ibqReadTimeout+0xbc>
        return r;
      }
    }

    /* Size of the data chunk present in the current buffer.*/
    size = (size_t)ibqp->top - (size_t)ibqp->ptr;
  200b72:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    if (size > (n - r)) {
  200b74:	eba6 0b0a 	sub.w	fp, r6, sl
    size = (size_t)ibqp->top - (size_t)ibqp->ptr;
  200b78:	1a5b      	subs	r3, r3, r1
  200b7a:	459b      	cmp	fp, r3
  200b7c:	bf28      	it	cs
  200b7e:	469b      	movcs	fp, r3
      size = n - r;
    }

    /* Smaller chunks in order to not make the critical zone too long,
       this impacts throughput however.*/
    if (size > 64U) {
  200b80:	f1bb 0f40 	cmp.w	fp, #64	; 0x40
  200b84:	d94a      	bls.n	200c1c <ibqReadTimeout+0xdc>
      /* Giving the compiler a chance to optimize for a fixed size move.*/
      memcpy(bp, ibqp->ptr, 64U);
  200b86:	462b      	mov	r3, r5
  200b88:	f101 0240 	add.w	r2, r1, #64	; 0x40
  200b8c:	f8d1 b000 	ldr.w	fp, [r1]
  200b90:	3110      	adds	r1, #16
  200b92:	f851 cc0c 	ldr.w	ip, [r1, #-12]
  200b96:	3310      	adds	r3, #16
  200b98:	f851 ec08 	ldr.w	lr, [r1, #-8]
  200b9c:	f851 0c04 	ldr.w	r0, [r1, #-4]
  200ba0:	4291      	cmp	r1, r2
  200ba2:	f843 bc10 	str.w	fp, [r3, #-16]
  200ba6:	f843 cc0c 	str.w	ip, [r3, #-12]
  200baa:	f843 ec08 	str.w	lr, [r3, #-8]
  200bae:	f843 0c04 	str.w	r0, [r3, #-4]
  200bb2:	d1eb      	bne.n	200b8c <ibqReadTimeout+0x4c>
      bp        += 64U;
      ibqp->ptr += 64U;
  200bb4:	6aa3      	ldr	r3, [r4, #40]	; 0x28
      bp        += 64U;
  200bb6:	3540      	adds	r5, #64	; 0x40
      r         += 64U;
  200bb8:	f10a 0a40 	add.w	sl, sl, #64	; 0x40
      ibqp->ptr += 64U;
  200bbc:	3340      	adds	r3, #64	; 0x40
  200bbe:	62a3      	str	r3, [r4, #40]	; 0x28
      ibqp->ptr += size;
      r         += size;
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (ibqp->ptr >= ibqp->top) {
  200bc0:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  200bc2:	429a      	cmp	r2, r3
  200bc4:	d810      	bhi.n	200be8 <ibqReadTimeout+0xa8>
  ibqp->brdptr += ibqp->bsize;
  200bc6:	6963      	ldr	r3, [r4, #20]
  200bc8:	69e1      	ldr	r1, [r4, #28]
  ibqp->bcounter--;
  200bca:	68e0      	ldr	r0, [r4, #12]
  ibqp->brdptr += ibqp->bsize;
  200bcc:	440b      	add	r3, r1
  if (ibqp->brdptr >= ibqp->btop) {
  200bce:	69a2      	ldr	r2, [r4, #24]
  ibqp->bcounter--;
  200bd0:	3801      	subs	r0, #1
  if (ibqp->brdptr >= ibqp->btop) {
  200bd2:	4293      	cmp	r3, r2
  ibqp->brdptr += ibqp->bsize;
  200bd4:	6163      	str	r3, [r4, #20]
  ibqp->bcounter--;
  200bd6:	60e0      	str	r0, [r4, #12]
  if (ibqp->brdptr >= ibqp->btop) {
  200bd8:	d301      	bcc.n	200bde <ibqReadTimeout+0x9e>
    ibqp->brdptr = ibqp->buffers;
  200bda:	6a63      	ldr	r3, [r4, #36]	; 0x24
  200bdc:	6163      	str	r3, [r4, #20]
  if (ibqp->notify != NULL) {
  200bde:	6b23      	ldr	r3, [r4, #48]	; 0x30
  ibqp->ptr = NULL;
  200be0:	62a7      	str	r7, [r4, #40]	; 0x28
  if (ibqp->notify != NULL) {
  200be2:	b10b      	cbz	r3, 200be8 <ibqReadTimeout+0xa8>
    ibqp->notify(ibqp);
  200be4:	4620      	mov	r0, r4
  200be6:	4798      	blx	r3
  200be8:	f387 8811 	msr	BASEPRI, r7
      ibqReleaseEmptyBufferS(ibqp);
    }

    /* Giving a preemption chance.*/
    osalSysUnlock();
    if (r >= n) {
  200bec:	45b2      	cmp	sl, r6
  200bee:	d228      	bcs.n	200c42 <ibqReadTimeout+0x102>
  200bf0:	2320      	movs	r3, #32
  200bf2:	f383 8811 	msr	BASEPRI, r3
    if (ibqp->ptr == NULL) {
  200bf6:	6aa1      	ldr	r1, [r4, #40]	; 0x28
  200bf8:	2900      	cmp	r1, #0
  200bfa:	d1ba      	bne.n	200b72 <ibqReadTimeout+0x32>
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
  200bfc:	f119 0f03 	cmn.w	r9, #3
  200c00:	d816      	bhi.n	200c30 <ibqReadTimeout+0xf0>
  200c02:	9b01      	ldr	r3, [sp, #4]
  return (sysinterval_t)((systime_t)(end - start));
  200c04:	9a00      	ldr	r2, [sp, #0]
  200c06:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  200c08:	1ad3      	subs	r3, r2, r3
        if (next_timeout > timeout) {
  200c0a:	4598      	cmp	r8, r3
  200c0c:	d31d      	bcc.n	200c4a <ibqReadTimeout+0x10a>
        msg = ibqGetFullBufferTimeoutS(ibqp, next_timeout);
  200c0e:	4619      	mov	r1, r3
  200c10:	4620      	mov	r0, r4
  200c12:	f7ff ff6d 	bl	200af0 <ibqGetFullBufferTimeoutS>
      if (msg != MSG_OK) {
  200c16:	b988      	cbnz	r0, 200c3c <ibqReadTimeout+0xfc>
  200c18:	6aa1      	ldr	r1, [r4, #40]	; 0x28
  200c1a:	e7aa      	b.n	200b72 <ibqReadTimeout+0x32>
      memcpy(bp, ibqp->ptr, size);
  200c1c:	4628      	mov	r0, r5
  200c1e:	465a      	mov	r2, fp
  200c20:	f002 ffba 	bl	203b98 <memcpy>
      ibqp->ptr += size;
  200c24:	6aa3      	ldr	r3, [r4, #40]	; 0x28
      r         += size;
  200c26:	44da      	add	sl, fp
      bp        += size;
  200c28:	445d      	add	r5, fp
      ibqp->ptr += size;
  200c2a:	445b      	add	r3, fp
  200c2c:	62a3      	str	r3, [r4, #40]	; 0x28
  200c2e:	e7c7      	b.n	200bc0 <ibqReadTimeout+0x80>
        msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
  200c30:	4641      	mov	r1, r8
  200c32:	4620      	mov	r0, r4
  200c34:	f7ff ff5c 	bl	200af0 <ibqGetFullBufferTimeoutS>
      if (msg != MSG_OK) {
  200c38:	2800      	cmp	r0, #0
  200c3a:	d0ed      	beq.n	200c18 <ibqReadTimeout+0xd8>
  200c3c:	2300      	movs	r3, #0
  200c3e:	f383 8811 	msr	BASEPRI, r3
      return r;
    }
    osalSysLock();
  }
}
  200c42:	4650      	mov	r0, sl
  200c44:	b003      	add	sp, #12
  200c46:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  200c4a:	f381 8811 	msr	BASEPRI, r1
  200c4e:	e7f8      	b.n	200c42 <ibqReadTimeout+0x102>

00200c50 <_readt.lto_priv.57>:
  return ibqReadTimeout(&((SerialUSBDriver *)ip)->ibqueue, bp, n, timeout);
  200c50:	300c      	adds	r0, #12
  200c52:	f7ff bf75 	b.w	200b40 <ibqReadTimeout>
  200c56:	bf00      	nop
	...

00200c60 <_read.lto_priv.51>:
  return ibqReadTimeout(&((SerialUSBDriver *)ip)->ibqueue, bp,
  200c60:	300c      	adds	r0, #12
  200c62:	f04f 33ff 	mov.w	r3, #4294967295
  200c66:	f7ff bf6b 	b.w	200b40 <ibqReadTimeout>
  200c6a:	bf00      	nop
  200c6c:	0000      	movs	r0, r0
	...

00200c70 <ibqGetTimeout>:
msg_t ibqGetTimeout(input_buffers_queue_t *ibqp, sysinterval_t timeout) {
  200c70:	b530      	push	{r4, r5, lr}
  200c72:	2320      	movs	r3, #32
  200c74:	b083      	sub	sp, #12
  200c76:	4604      	mov	r4, r0
  200c78:	f383 8811 	msr	BASEPRI, r3
  if (ibqp->ptr == NULL) {
  200c7c:	6a83      	ldr	r3, [r0, #40]	; 0x28
  200c7e:	b1eb      	cbz	r3, 200cbc <ibqGetTimeout+0x4c>
  msg = (msg_t)*ibqp->ptr;
  200c80:	f813 5b01 	ldrb.w	r5, [r3], #1
  if (ibqp->ptr >= ibqp->top) {
  200c84:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  ibqp->ptr++;
  200c86:	62a3      	str	r3, [r4, #40]	; 0x28
  if (ibqp->ptr >= ibqp->top) {
  200c88:	4293      	cmp	r3, r2
  200c8a:	d311      	bcc.n	200cb0 <ibqGetTimeout+0x40>
  ibqp->brdptr += ibqp->bsize;
  200c8c:	6963      	ldr	r3, [r4, #20]
  200c8e:	69e0      	ldr	r0, [r4, #28]
  ibqp->bcounter--;
  200c90:	68e2      	ldr	r2, [r4, #12]
  ibqp->brdptr += ibqp->bsize;
  200c92:	4403      	add	r3, r0
  if (ibqp->brdptr >= ibqp->btop) {
  200c94:	69a1      	ldr	r1, [r4, #24]
  ibqp->bcounter--;
  200c96:	3a01      	subs	r2, #1
  if (ibqp->brdptr >= ibqp->btop) {
  200c98:	428b      	cmp	r3, r1
  ibqp->brdptr += ibqp->bsize;
  200c9a:	6163      	str	r3, [r4, #20]
  ibqp->bcounter--;
  200c9c:	60e2      	str	r2, [r4, #12]
  if (ibqp->brdptr >= ibqp->btop) {
  200c9e:	d301      	bcc.n	200ca4 <ibqGetTimeout+0x34>
    ibqp->brdptr = ibqp->buffers;
  200ca0:	6a63      	ldr	r3, [r4, #36]	; 0x24
  200ca2:	6163      	str	r3, [r4, #20]
  ibqp->ptr = NULL;
  200ca4:	2200      	movs	r2, #0
  if (ibqp->notify != NULL) {
  200ca6:	6b23      	ldr	r3, [r4, #48]	; 0x30
  ibqp->ptr = NULL;
  200ca8:	62a2      	str	r2, [r4, #40]	; 0x28
  if (ibqp->notify != NULL) {
  200caa:	b10b      	cbz	r3, 200cb0 <ibqGetTimeout+0x40>
    ibqp->notify(ibqp);
  200cac:	4620      	mov	r0, r4
  200cae:	4798      	blx	r3
  200cb0:	2300      	movs	r3, #0
  200cb2:	f383 8811 	msr	BASEPRI, r3
}
  200cb6:	4628      	mov	r0, r5
  200cb8:	b003      	add	sp, #12
  200cba:	bd30      	pop	{r4, r5, pc}
  200cbc:	9301      	str	r3, [sp, #4]
    msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
  200cbe:	f7ff ff17 	bl	200af0 <ibqGetFullBufferTimeoutS>
    if (msg != MSG_OK) {
  200cc2:	9b01      	ldr	r3, [sp, #4]
  200cc4:	4605      	mov	r5, r0
  200cc6:	2800      	cmp	r0, #0
  200cc8:	d1f3      	bne.n	200cb2 <ibqGetTimeout+0x42>
  200cca:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  200ccc:	e7d8      	b.n	200c80 <ibqGetTimeout+0x10>
  200cce:	bf00      	nop

00200cd0 <_gett.lto_priv.55>:
  return ibqGetTimeout(&((SerialUSBDriver *)ip)->ibqueue, timeout);
  200cd0:	300c      	adds	r0, #12
  200cd2:	f7ff bfcd 	b.w	200c70 <ibqGetTimeout>
  200cd6:	bf00      	nop
	...

00200ce0 <_get.lto_priv.53>:
  return ibqGetTimeout(&((SerialUSBDriver *)ip)->ibqueue, TIME_INFINITE);
  200ce0:	300c      	adds	r0, #12
  200ce2:	f04f 31ff 	mov.w	r1, #4294967295
  200ce6:	f7ff bfc3 	b.w	200c70 <ibqGetTimeout>
  200cea:	bf00      	nop
  200cec:	0000      	movs	r0, r0
	...

00200cf0 <obqGetEmptyBufferTimeoutS>:
 *                      suspended state.
 *
 * @sclass
 */
msg_t obqGetEmptyBufferTimeoutS(output_buffers_queue_t *obqp,
                                sysinterval_t timeout) {
  200cf0:	b570      	push	{r4, r5, r6, lr}
  200cf2:	4604      	mov	r4, r0
  200cf4:	460d      	mov	r5, r1
  queue_insert(currp, tqp);
  200cf6:	4e11      	ldr	r6, [pc, #68]	; (200d3c <obqGetEmptyBufferTimeoutS+0x4c>)
  200cf8:	e009      	b.n	200d0e <obqGetEmptyBufferTimeoutS+0x1e>
  200cfa:	69b3      	ldr	r3, [r6, #24]
  tp->queue.prev             = tqp->prev;
  200cfc:	6862      	ldr	r2, [r4, #4]
  tp->queue.next             = (thread_t *)tqp;
  200cfe:	601c      	str	r4, [r3, #0]
  tp->queue.prev             = tqp->prev;
  200d00:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
  200d02:	6013      	str	r3, [r2, #0]
  tqp->prev                  = tp;
  200d04:	6063      	str	r3, [r4, #4]
  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
  200d06:	f7ff fe63 	bl	2009d0 <chSchGoSleepTimeoutS>
  while (obqIsFullI(obqp)) {
    if (obqp->suspended) {
      return MSG_RESET;
    }
    msg_t msg = osalThreadEnqueueTimeoutS(&obqp->waiting, timeout);
    if (msg < MSG_OK) {
  200d0a:	2800      	cmp	r0, #0
  200d0c:	db09      	blt.n	200d22 <obqGetEmptyBufferTimeoutS+0x32>
  while (obqIsFullI(obqp)) {
  200d0e:	68e3      	ldr	r3, [r4, #12]
  200d10:	4629      	mov	r1, r5
  200d12:	2004      	movs	r0, #4
  200d14:	b933      	cbnz	r3, 200d24 <obqGetEmptyBufferTimeoutS+0x34>
    if (obqp->suspended) {
  200d16:	7a23      	ldrb	r3, [r4, #8]
  200d18:	b963      	cbnz	r3, 200d34 <obqGetEmptyBufferTimeoutS+0x44>
  if (TIME_IMMEDIATE == timeout) {
  200d1a:	2d00      	cmp	r5, #0
  200d1c:	d1ed      	bne.n	200cfa <obqGetEmptyBufferTimeoutS+0xa>
    return MSG_TIMEOUT;
  200d1e:	f04f 30ff 	mov.w	r0, #4294967295
  /* Setting up the "current" buffer and its boundary.*/
  obqp->ptr = obqp->bwrptr + sizeof (size_t);
  obqp->top = obqp->bwrptr + obqp->bsize;

  return MSG_OK;
}
  200d22:	bd70      	pop	{r4, r5, r6, pc}
  obqp->ptr = obqp->bwrptr + sizeof (size_t);
  200d24:	6923      	ldr	r3, [r4, #16]
  obqp->top = obqp->bwrptr + obqp->bsize;
  200d26:	2000      	movs	r0, #0
  200d28:	69e1      	ldr	r1, [r4, #28]
  obqp->ptr = obqp->bwrptr + sizeof (size_t);
  200d2a:	1d1a      	adds	r2, r3, #4
  obqp->top = obqp->bwrptr + obqp->bsize;
  200d2c:	440b      	add	r3, r1
  obqp->ptr = obqp->bwrptr + sizeof (size_t);
  200d2e:	62a2      	str	r2, [r4, #40]	; 0x28
  obqp->top = obqp->bwrptr + obqp->bsize;
  200d30:	62e3      	str	r3, [r4, #44]	; 0x2c
  200d32:	bd70      	pop	{r4, r5, r6, pc}
      return MSG_RESET;
  200d34:	f06f 0001 	mvn.w	r0, #1
  200d38:	bd70      	pop	{r4, r5, r6, pc}
  200d3a:	bf00      	nop
  200d3c:	200012a0 	.word	0x200012a0

00200d40 <obqWriteTimeout>:
 * @retval 0            if a timeout occurred.
 *
 * @api
 */
size_t obqWriteTimeout(output_buffers_queue_t *obqp, const uint8_t *bp,
                       size_t n, sysinterval_t timeout) {
  200d40:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  200d44:	4699      	mov	r9, r3
  200d46:	b083      	sub	sp, #12
  200d48:	4605      	mov	r5, r0
  200d4a:	4617      	mov	r7, r2
  200d4c:	2320      	movs	r3, #32
  200d4e:	f383 8811 	msr	BASEPRI, r3
  200d52:	f04f 4a80 	mov.w	sl, #1073741824	; 0x40000000
    if (obqp->ptr == NULL) {
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
  200d56:	f109 33ff 	add.w	r3, r9, #4294967295
  size_t w = 0;
  200d5a:	f04f 0b00 	mov.w	fp, #0
    if (obqp->ptr == NULL) {
  200d5e:	6aa8      	ldr	r0, [r5, #40]	; 0x28
  200d60:	f8da 2024 	ldr.w	r2, [sl, #36]	; 0x24
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
  200d64:	9300      	str	r3, [sp, #0]
  obqp->ptr = NULL;
  200d66:	46d8      	mov	r8, fp
  return systime + (systime_t)interval;
  200d68:	eb09 0302 	add.w	r3, r9, r2
  200d6c:	9301      	str	r3, [sp, #4]
  200d6e:	463b      	mov	r3, r7
  200d70:	460f      	mov	r7, r1
  200d72:	461e      	mov	r6, r3
    if (obqp->ptr == NULL) {
  200d74:	2800      	cmp	r0, #0
  200d76:	d047      	beq.n	200e08 <obqWriteTimeout+0xc8>
        return w;
      }
    }

    /* Size of the space available in the current buffer.*/
    size = (size_t)obqp->top - (size_t)obqp->ptr;
  200d78:	6aea      	ldr	r2, [r5, #44]	; 0x2c
    if (size > (n - w)) {
  200d7a:	eba6 040b 	sub.w	r4, r6, fp
    size = (size_t)obqp->top - (size_t)obqp->ptr;
  200d7e:	1a12      	subs	r2, r2, r0
  200d80:	4294      	cmp	r4, r2
  200d82:	bf28      	it	cs
  200d84:	4614      	movcs	r4, r2
      size = n - w;
    }

    /* Smaller chunks in order to not make the critical zone too long,
       this impacts throughput however.*/
    if (size > 64U) {
  200d86:	2c40      	cmp	r4, #64	; 0x40
  200d88:	d94d      	bls.n	200e26 <obqWriteTimeout+0xe6>
      /* Giving the compiler a chance to optimize for a fixed size move.*/
      memcpy(obqp->ptr, bp, 64U);
  200d8a:	4639      	mov	r1, r7
  200d8c:	f107 0340 	add.w	r3, r7, #64	; 0x40
  200d90:	f8d1 e000 	ldr.w	lr, [r1]
  200d94:	3110      	adds	r1, #16
  200d96:	f851 7c0c 	ldr.w	r7, [r1, #-12]
  200d9a:	3010      	adds	r0, #16
  200d9c:	f851 4c08 	ldr.w	r4, [r1, #-8]
  200da0:	f851 2c04 	ldr.w	r2, [r1, #-4]
  200da4:	4299      	cmp	r1, r3
  200da6:	f840 ec10 	str.w	lr, [r0, #-16]
  200daa:	f840 7c0c 	str.w	r7, [r0, #-12]
  200dae:	f840 4c08 	str.w	r4, [r0, #-8]
  200db2:	f840 2c04 	str.w	r2, [r0, #-4]
  200db6:	d1eb      	bne.n	200d90 <obqWriteTimeout+0x50>
      bp        += 64U;
      obqp->ptr += 64U;
  200db8:	6aac      	ldr	r4, [r5, #40]	; 0x28
      bp        += 64U;
  200dba:	460f      	mov	r7, r1
      w         += 64U;
  200dbc:	f10b 0b40 	add.w	fp, fp, #64	; 0x40
      obqp->ptr += 64U;
  200dc0:	3440      	adds	r4, #64	; 0x40
  200dc2:	62ac      	str	r4, [r5, #40]	; 0x28
      obqp->ptr += size;
      w         += size;
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (obqp->ptr >= obqp->top) {
  200dc4:	6aea      	ldr	r2, [r5, #44]	; 0x2c
  200dc6:	42a2      	cmp	r2, r4
  200dc8:	d814      	bhi.n	200df4 <obqWriteTimeout+0xb4>
      obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
  200dca:	69e9      	ldr	r1, [r5, #28]
  *((size_t *)obqp->bwrptr) = size;
  200dcc:	692a      	ldr	r2, [r5, #16]
      obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
  200dce:	3904      	subs	r1, #4
  if (obqp->bwrptr >= obqp->btop) {
  200dd0:	69a8      	ldr	r0, [r5, #24]
  *((size_t *)obqp->bwrptr) = size;
  200dd2:	6011      	str	r1, [r2, #0]
  obqp->bwrptr += obqp->bsize;
  200dd4:	69ec      	ldr	r4, [r5, #28]
  obqp->bcounter--;
  200dd6:	68e9      	ldr	r1, [r5, #12]
  obqp->bwrptr += obqp->bsize;
  200dd8:	4422      	add	r2, r4
  obqp->bcounter--;
  200dda:	3901      	subs	r1, #1
  if (obqp->bwrptr >= obqp->btop) {
  200ddc:	4282      	cmp	r2, r0
  obqp->bwrptr += obqp->bsize;
  200dde:	612a      	str	r2, [r5, #16]
  obqp->bcounter--;
  200de0:	60e9      	str	r1, [r5, #12]
  if (obqp->bwrptr >= obqp->btop) {
  200de2:	d301      	bcc.n	200de8 <obqWriteTimeout+0xa8>
    obqp->bwrptr = obqp->buffers;
  200de4:	6a6a      	ldr	r2, [r5, #36]	; 0x24
  200de6:	612a      	str	r2, [r5, #16]
  if (obqp->notify != NULL) {
  200de8:	6b2a      	ldr	r2, [r5, #48]	; 0x30
  obqp->ptr = NULL;
  200dea:	f8c5 8028 	str.w	r8, [r5, #40]	; 0x28
  if (obqp->notify != NULL) {
  200dee:	b10a      	cbz	r2, 200df4 <obqWriteTimeout+0xb4>
    obqp->notify(obqp);
  200df0:	4628      	mov	r0, r5
  200df2:	4790      	blx	r2
  200df4:	f388 8811 	msr	BASEPRI, r8
    }

    /* Giving a preemption chance.*/
    osalSysUnlock();
    if (w >= n) {
  200df8:	45b3      	cmp	fp, r6
  200dfa:	d227      	bcs.n	200e4c <obqWriteTimeout+0x10c>
  200dfc:	2220      	movs	r2, #32
  200dfe:	f382 8811 	msr	BASEPRI, r2
    if (obqp->ptr == NULL) {
  200e02:	6aa8      	ldr	r0, [r5, #40]	; 0x28
  200e04:	2800      	cmp	r0, #0
  200e06:	d1b7      	bne.n	200d78 <obqWriteTimeout+0x38>
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
  200e08:	9b00      	ldr	r3, [sp, #0]
  200e0a:	3303      	adds	r3, #3
  200e0c:	d815      	bhi.n	200e3a <obqWriteTimeout+0xfa>
  200e0e:	f8da 1024 	ldr.w	r1, [sl, #36]	; 0x24
  return (sysinterval_t)((systime_t)(end - start));
  200e12:	9b01      	ldr	r3, [sp, #4]
  200e14:	1a59      	subs	r1, r3, r1
        if (next_timeout > timeout) {
  200e16:	4589      	cmp	r9, r1
  200e18:	d31c      	bcc.n	200e54 <obqWriteTimeout+0x114>
        msg = obqGetEmptyBufferTimeoutS(obqp, next_timeout);
  200e1a:	4628      	mov	r0, r5
  200e1c:	f7ff ff68 	bl	200cf0 <obqGetEmptyBufferTimeoutS>
      if (msg != MSG_OK) {
  200e20:	b988      	cbnz	r0, 200e46 <obqWriteTimeout+0x106>
  200e22:	6aa8      	ldr	r0, [r5, #40]	; 0x28
  200e24:	e7a8      	b.n	200d78 <obqWriteTimeout+0x38>
      memcpy(obqp->ptr, bp, size);
  200e26:	4622      	mov	r2, r4
  200e28:	4639      	mov	r1, r7
  200e2a:	f002 feb5 	bl	203b98 <memcpy>
      obqp->ptr += size;
  200e2e:	6aaa      	ldr	r2, [r5, #40]	; 0x28
      w         += size;
  200e30:	44a3      	add	fp, r4
      bp        += size;
  200e32:	4427      	add	r7, r4
      obqp->ptr += size;
  200e34:	4414      	add	r4, r2
  200e36:	62ac      	str	r4, [r5, #40]	; 0x28
  200e38:	e7c4      	b.n	200dc4 <obqWriteTimeout+0x84>
        msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
  200e3a:	4649      	mov	r1, r9
  200e3c:	4628      	mov	r0, r5
  200e3e:	f7ff ff57 	bl	200cf0 <obqGetEmptyBufferTimeoutS>
      if (msg != MSG_OK) {
  200e42:	2800      	cmp	r0, #0
  200e44:	d0ed      	beq.n	200e22 <obqWriteTimeout+0xe2>
  200e46:	2200      	movs	r2, #0
  200e48:	f382 8811 	msr	BASEPRI, r2
      return w;
    }
    osalSysLock();
  }
}
  200e4c:	4658      	mov	r0, fp
  200e4e:	b003      	add	sp, #12
  200e50:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  200e54:	f380 8811 	msr	BASEPRI, r0
  200e58:	e7f8      	b.n	200e4c <obqWriteTimeout+0x10c>
  200e5a:	bf00      	nop
  200e5c:	0000      	movs	r0, r0
	...

00200e60 <_writet.lto_priv.56>:
  return obqWriteTimeout(&((SerialUSBDriver *)ip)->obqueue, bp, n, timeout);
  200e60:	3044      	adds	r0, #68	; 0x44
  200e62:	f7ff bf6d 	b.w	200d40 <obqWriteTimeout>
  200e66:	bf00      	nop
	...

00200e70 <_write.lto_priv.50>:
  return obqWriteTimeout(&((SerialUSBDriver *)ip)->obqueue, bp,
  200e70:	3044      	adds	r0, #68	; 0x44
  200e72:	f04f 33ff 	mov.w	r3, #4294967295
  200e76:	f7ff bf63 	b.w	200d40 <obqWriteTimeout>
  200e7a:	bf00      	nop
  200e7c:	0000      	movs	r0, r0
	...

00200e80 <obqPutTimeout>:
                    sysinterval_t timeout) {
  200e80:	b570      	push	{r4, r5, r6, lr}
  200e82:	2320      	movs	r3, #32
  200e84:	460e      	mov	r6, r1
  200e86:	4604      	mov	r4, r0
  200e88:	f383 8811 	msr	BASEPRI, r3
  if (obqp->ptr == NULL) {
  200e8c:	6a85      	ldr	r5, [r0, #40]	; 0x28
  200e8e:	b1fd      	cbz	r5, 200ed0 <obqPutTimeout+0x50>
  *obqp->ptr = b;
  200e90:	702e      	strb	r6, [r5, #0]
  obqp->ptr++;
  200e92:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  if (obqp->ptr >= obqp->top) {
  200e94:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  obqp->ptr++;
  200e96:	3301      	adds	r3, #1
  if (obqp->ptr >= obqp->top) {
  200e98:	4293      	cmp	r3, r2
  obqp->ptr++;
  200e9a:	62a3      	str	r3, [r4, #40]	; 0x28
  if (obqp->ptr >= obqp->top) {
  200e9c:	d314      	bcc.n	200ec8 <obqPutTimeout+0x48>
    obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
  200e9e:	69e2      	ldr	r2, [r4, #28]
  *((size_t *)obqp->bwrptr) = size;
  200ea0:	6923      	ldr	r3, [r4, #16]
    obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
  200ea2:	3a04      	subs	r2, #4
  if (obqp->bwrptr >= obqp->btop) {
  200ea4:	69a1      	ldr	r1, [r4, #24]
  *((size_t *)obqp->bwrptr) = size;
  200ea6:	601a      	str	r2, [r3, #0]
  obqp->bwrptr += obqp->bsize;
  200ea8:	69e0      	ldr	r0, [r4, #28]
  obqp->bcounter--;
  200eaa:	68e2      	ldr	r2, [r4, #12]
  obqp->bwrptr += obqp->bsize;
  200eac:	4403      	add	r3, r0
  obqp->bcounter--;
  200eae:	3a01      	subs	r2, #1
  if (obqp->bwrptr >= obqp->btop) {
  200eb0:	428b      	cmp	r3, r1
  obqp->bwrptr += obqp->bsize;
  200eb2:	6123      	str	r3, [r4, #16]
  obqp->bcounter--;
  200eb4:	60e2      	str	r2, [r4, #12]
  if (obqp->bwrptr >= obqp->btop) {
  200eb6:	d301      	bcc.n	200ebc <obqPutTimeout+0x3c>
    obqp->bwrptr = obqp->buffers;
  200eb8:	6a63      	ldr	r3, [r4, #36]	; 0x24
  200eba:	6123      	str	r3, [r4, #16]
  obqp->ptr = NULL;
  200ebc:	2200      	movs	r2, #0
  if (obqp->notify != NULL) {
  200ebe:	6b23      	ldr	r3, [r4, #48]	; 0x30
  obqp->ptr = NULL;
  200ec0:	62a2      	str	r2, [r4, #40]	; 0x28
  if (obqp->notify != NULL) {
  200ec2:	b10b      	cbz	r3, 200ec8 <obqPutTimeout+0x48>
    obqp->notify(obqp);
  200ec4:	4620      	mov	r0, r4
  200ec6:	4798      	blx	r3
  200ec8:	2000      	movs	r0, #0
  200eca:	f380 8811 	msr	BASEPRI, r0
}
  200ece:	bd70      	pop	{r4, r5, r6, pc}
    msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
  200ed0:	4611      	mov	r1, r2
  200ed2:	f7ff ff0d 	bl	200cf0 <obqGetEmptyBufferTimeoutS>
    if (msg != MSG_OK) {
  200ed6:	b908      	cbnz	r0, 200edc <obqPutTimeout+0x5c>
  200ed8:	6aa5      	ldr	r5, [r4, #40]	; 0x28
  200eda:	e7d9      	b.n	200e90 <obqPutTimeout+0x10>
  200edc:	f385 8811 	msr	BASEPRI, r5
  200ee0:	bd70      	pop	{r4, r5, r6, pc}
  200ee2:	bf00      	nop
	...

00200ef0 <_putt.lto_priv.54>:
  return obqPutTimeout(&((SerialUSBDriver *)ip)->obqueue, b, timeout);
  200ef0:	3044      	adds	r0, #68	; 0x44
  200ef2:	f7ff bfc5 	b.w	200e80 <obqPutTimeout>
  200ef6:	bf00      	nop
	...

00200f00 <_put.lto_priv.52>:
  return obqPutTimeout(&((SerialUSBDriver *)ip)->obqueue, b, TIME_INFINITE);
  200f00:	3044      	adds	r0, #68	; 0x44
  200f02:	f04f 32ff 	mov.w	r2, #4294967295
  200f06:	f7ff bfbb 	b.w	200e80 <obqPutTimeout>
  200f0a:	bf00      	nop
  200f0c:	0000      	movs	r0, r0
	...

00200f10 <usbStartTransmitI>:
                       const uint8_t *buf, size_t n) {
  200f10:	b5f0      	push	{r4, r5, r6, r7, lr}
  isp = usbp->epc[ep]->in_state;
  200f12:	eb00 0c81 	add.w	ip, r0, r1, lsl #2
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
  200f16:	2401      	movs	r4, #1
  200f18:	f8b0 e008 	ldrh.w	lr, [r0, #8]
  isp->txcnt  = 0;
  200f1c:	2700      	movs	r7, #0
  isp = usbp->epc[ep]->in_state;
  200f1e:	f8dc 500c 	ldr.w	r5, [ip, #12]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
  200f22:	408c      	lsls	r4, r1
  isp = usbp->epc[ep]->in_state;
  200f24:	696d      	ldr	r5, [r5, #20]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
  200f26:	ea44 040e 	orr.w	r4, r4, lr
  200f2a:	8104      	strh	r4, [r0, #8]
  isp->txbuf  = buf;
  200f2c:	60aa      	str	r2, [r5, #8]
  isp->txcnt  = 0;
  200f2e:	e885 0088 	stmia.w	r5, {r3, r7}
}
  200f32:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  usb_lld_start_in(usbp, ep);
  200f36:	f002 bc1b 	b.w	203770 <usb_lld_start_in>
  200f3a:	bf00      	nop
  200f3c:	0000      	movs	r0, r0
	...

00200f40 <sdu_start_receive.lto_priv.61>:
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
  200f40:	f8d0 148c 	ldr.w	r1, [r0, #1164]	; 0x48c
  200f44:	680a      	ldr	r2, [r1, #0]
static bool sdu_start_receive(SerialUSBDriver *sdup) {
  200f46:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
  200f48:	7813      	ldrb	r3, [r2, #0]
  200f4a:	2b04      	cmp	r3, #4
  200f4c:	d001      	beq.n	200f52 <sdu_start_receive.lto_priv.61+0x12>
    return true;
  200f4e:	2001      	movs	r0, #1
  200f50:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
  200f52:	7a03      	ldrb	r3, [r0, #8]
  200f54:	2b02      	cmp	r3, #2
  200f56:	d1fa      	bne.n	200f4e <sdu_start_receive.lto_priv.61+0xe>
  if (usbGetReceiveStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
  200f58:	790c      	ldrb	r4, [r1, #4]
  200f5a:	2301      	movs	r3, #1
  200f5c:	8955      	ldrh	r5, [r2, #10]
  200f5e:	fa03 f404 	lsl.w	r4, r3, r4
  200f62:	4225      	tst	r5, r4
  200f64:	d1f3      	bne.n	200f4e <sdu_start_receive.lto_priv.61+0xe>
  if (ibqIsFullI(ibqp)) {
  200f66:	69c4      	ldr	r4, [r0, #28]
  200f68:	6a06      	ldr	r6, [r0, #32]
  200f6a:	42b4      	cmp	r4, r6
  200f6c:	d015      	beq.n	200f9a <sdu_start_receive.lto_priv.61+0x5a>
  if (buf == NULL) {
  200f6e:	1d23      	adds	r3, r4, #4
  200f70:	d0ed      	beq.n	200f4e <sdu_start_receive.lto_priv.61+0xe>
  usbStartReceiveI(sdup->config->usbp, sdup->config->bulk_out,
  200f72:	7949      	ldrb	r1, [r1, #5]
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
  200f74:	2001      	movs	r0, #1
  osp->rxcnt  = 0;
  200f76:	2400      	movs	r4, #0
  osp->rxsize = n;
  200f78:	f44f 7780 	mov.w	r7, #256	; 0x100
  osp = usbp->epc[ep]->out_state;
  200f7c:	eb02 0681 	add.w	r6, r2, r1, lsl #2
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
  200f80:	4088      	lsls	r0, r1
  osp = usbp->epc[ep]->out_state;
  200f82:	68f6      	ldr	r6, [r6, #12]
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
  200f84:	4305      	orrs	r5, r0
  usb_lld_start_out(usbp, ep);
  200f86:	4610      	mov	r0, r2
  osp = usbp->epc[ep]->out_state;
  200f88:	69b6      	ldr	r6, [r6, #24]
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
  200f8a:	8155      	strh	r5, [r2, #10]
  osp->rxbuf  = buf;
  200f8c:	60b3      	str	r3, [r6, #8]
  osp->rxsize = n;
  200f8e:	6037      	str	r7, [r6, #0]
  osp->rxcnt  = 0;
  200f90:	6074      	str	r4, [r6, #4]
  usb_lld_start_out(usbp, ep);
  200f92:	f002 fc45 	bl	203820 <usb_lld_start_out>
  return false;
  200f96:	4620      	mov	r0, r4
  200f98:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  200f9a:	6980      	ldr	r0, [r0, #24]
  200f9c:	2800      	cmp	r0, #0
  200f9e:	d1d6      	bne.n	200f4e <sdu_start_receive.lto_priv.61+0xe>
  200fa0:	e7e5      	b.n	200f6e <sdu_start_receive.lto_priv.61+0x2e>
  200fa2:	bf00      	nop
	...

00200fb0 <ibnotify.lto_priv.42>:
  (void) sdu_start_receive(sdup);
  200fb0:	6b40      	ldr	r0, [r0, #52]	; 0x34
  200fb2:	f7ff bfc5 	b.w	200f40 <sdu_start_receive.lto_priv.61>
  200fb6:	bf00      	nop
	...

00200fc0 <obqGetFullBufferI>:
  if (obqIsEmptyI(obqp)) {
  200fc0:	6943      	ldr	r3, [r0, #20]
  200fc2:	6902      	ldr	r2, [r0, #16]
  200fc4:	429a      	cmp	r2, r3
  200fc6:	d004      	beq.n	200fd2 <obqGetFullBufferI+0x12>
  *sizep = *((size_t *)obqp->brdptr);
  200fc8:	4618      	mov	r0, r3
  200fca:	f850 3b04 	ldr.w	r3, [r0], #4
  200fce:	600b      	str	r3, [r1, #0]
}
  200fd0:	4770      	bx	lr
  if (obqIsEmptyI(obqp)) {
  200fd2:	68c2      	ldr	r2, [r0, #12]
  200fd4:	2a00      	cmp	r2, #0
  200fd6:	d0f7      	beq.n	200fc8 <obqGetFullBufferI+0x8>
    return NULL;
  200fd8:	2000      	movs	r0, #0
  200fda:	4770      	bx	lr
  200fdc:	0000      	movs	r0, r0
	...

00200fe0 <obnotify.lto_priv.43>:
static void obnotify(io_buffers_queue_t *bqp) {
  200fe0:	b510      	push	{r4, lr}
  SerialUSBDriver *sdup = bqGetLinkX(bqp);
  200fe2:	6b44      	ldr	r4, [r0, #52]	; 0x34
static void obnotify(io_buffers_queue_t *bqp) {
  200fe4:	b082      	sub	sp, #8
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
  200fe6:	f8d4 248c 	ldr.w	r2, [r4, #1164]	; 0x48c
  200fea:	6813      	ldr	r3, [r2, #0]
  200fec:	7819      	ldrb	r1, [r3, #0]
  200fee:	2904      	cmp	r1, #4
  200ff0:	d001      	beq.n	200ff6 <obnotify.lto_priv.43+0x16>
}
  200ff2:	b002      	add	sp, #8
  200ff4:	bd10      	pop	{r4, pc}
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
  200ff6:	7a21      	ldrb	r1, [r4, #8]
  200ff8:	2902      	cmp	r1, #2
  200ffa:	d1fa      	bne.n	200ff2 <obnotify.lto_priv.43+0x12>
  if (!usbGetTransmitStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
  200ffc:	7910      	ldrb	r0, [r2, #4]
  200ffe:	2201      	movs	r2, #1
  201000:	8919      	ldrh	r1, [r3, #8]
  201002:	fa02 f300 	lsl.w	r3, r2, r0
  201006:	420b      	tst	r3, r1
  201008:	d1f3      	bne.n	200ff2 <obnotify.lto_priv.43+0x12>
    uint8_t *buf = obqGetFullBufferI(&sdup->obqueue, &n);
  20100a:	a901      	add	r1, sp, #4
  20100c:	f104 0044 	add.w	r0, r4, #68	; 0x44
  201010:	f7ff ffd6 	bl	200fc0 <obqGetFullBufferI>
    if (buf != NULL) {
  201014:	2800      	cmp	r0, #0
  201016:	d0ec      	beq.n	200ff2 <obnotify.lto_priv.43+0x12>
      usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in, buf, n);
  201018:	f8d4 448c 	ldr.w	r4, [r4, #1164]	; 0x48c
  20101c:	4602      	mov	r2, r0
  20101e:	9b01      	ldr	r3, [sp, #4]
  201020:	7921      	ldrb	r1, [r4, #4]
  201022:	6820      	ldr	r0, [r4, #0]
  201024:	f7ff ff74 	bl	200f10 <usbStartTransmitI>
  201028:	e7e3      	b.n	200ff2 <obnotify.lto_priv.43+0x12>
  20102a:	bf00      	nop
  20102c:	0000      	movs	r0, r0
	...

00201030 <_port_irq_epilogue>:
  201030:	2320      	movs	r3, #32
  201032:	f383 8811 	msr	BASEPRI, r3
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
  201036:	4b0f      	ldr	r3, [pc, #60]	; (201074 <_port_irq_epilogue+0x44>)
  201038:	685b      	ldr	r3, [r3, #4]
  20103a:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
  20103e:	d102      	bne.n	201046 <_port_irq_epilogue+0x16>
  201040:	f383 8811 	msr	BASEPRI, r3
  201044:	4770      	bx	lr
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
  201046:	f3ef 8309 	mrs	r3, PSP
    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
  20104a:	f04f 7180 	mov.w	r1, #16777216	; 0x1000000
    ctxp--;
  20104e:	f1a3 0220 	sub.w	r2, r3, #32
    ctxp->xpsr = (regarm_t)0x01000000;
  201052:	f843 1c04 	str.w	r1, [r3, #-4]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
  201056:	f382 8809 	msr	PSP, r2
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.queue);
  20105a:	4a07      	ldr	r2, [pc, #28]	; (201078 <_port_irq_epilogue+0x48>)
  20105c:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->prio;
  20105e:	6992      	ldr	r2, [r2, #24]
    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
  201060:	6889      	ldr	r1, [r1, #8]
  201062:	6892      	ldr	r2, [r2, #8]
  201064:	4291      	cmp	r1, r2
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
  201066:	bf8c      	ite	hi
  201068:	4a04      	ldrhi	r2, [pc, #16]	; (20107c <_port_irq_epilogue+0x4c>)
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
  20106a:	4a05      	ldrls	r2, [pc, #20]	; (201080 <_port_irq_epilogue+0x50>)
  20106c:	f843 2c08 	str.w	r2, [r3, #-8]
  201070:	4770      	bx	lr
  201072:	bf00      	nop
  201074:	e000ed00 	.word	0xe000ed00
  201078:	200012a0 	.word	0x200012a0
  20107c:	00200301 	.word	0x00200301
  201080:	00200304 	.word	0x00200304
	...

00201090 <SVC_Handler>:
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
  201090:	f3ef 8309 	mrs	r3, PSP
  ctxp++;
  201094:	3320      	adds	r3, #32
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
  201096:	f383 8809 	msr	PSP, r3
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20109a:	2300      	movs	r3, #0
  20109c:	f383 8811 	msr	BASEPRI, r3
  2010a0:	4770      	bx	lr
  2010a2:	bf00      	nop
	...

002010b0 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
  2010b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
  2010b2:	6804      	ldr	r4, [r0, #0]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
  2010b4:	42a0      	cmp	r0, r4
  2010b6:	d022      	beq.n	2010fe <chEvtBroadcastFlagsI+0x4e>
  2010b8:	460d      	mov	r5, r1
  2010ba:	4607      	mov	r7, r0
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
      ((tp->state == CH_STATE_WTANDEVT) &&
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
    tp->u.rdymsg = MSG_OK;
  2010bc:	2600      	movs	r6, #0
  2010be:	e002      	b.n	2010c6 <chEvtBroadcastFlagsI+0x16>
    elp = elp->next;
  2010c0:	6824      	ldr	r4, [r4, #0]
  while (elp != (event_listener_t *)esp) {
  2010c2:	42a7      	cmp	r7, r4
  2010c4:	d01b      	beq.n	2010fe <chEvtBroadcastFlagsI+0x4e>
    elp->flags |= flags;
  2010c6:	68e3      	ldr	r3, [r4, #12]
  2010c8:	432b      	orrs	r3, r5
  2010ca:	60e3      	str	r3, [r4, #12]
    if ((flags == (eventflags_t)0) ||
  2010cc:	b115      	cbz	r5, 2010d4 <chEvtBroadcastFlagsI+0x24>
        ((elp->flags & elp->wflags) != (eventflags_t)0)) {
  2010ce:	6922      	ldr	r2, [r4, #16]
    if ((flags == (eventflags_t)0) ||
  2010d0:	4213      	tst	r3, r2
  2010d2:	d0f5      	beq.n	2010c0 <chEvtBroadcastFlagsI+0x10>
      chEvtSignalI(elp->listener, elp->events);
  2010d4:	6860      	ldr	r0, [r4, #4]
  tp->epending |= events;
  2010d6:	68a3      	ldr	r3, [r4, #8]
  2010d8:	6b41      	ldr	r1, [r0, #52]	; 0x34
  if (((tp->state == CH_STATE_WTOREVT) &&
  2010da:	f890 2020 	ldrb.w	r2, [r0, #32]
  tp->epending |= events;
  2010de:	430b      	orrs	r3, r1
  if (((tp->state == CH_STATE_WTOREVT) &&
  2010e0:	2a0a      	cmp	r2, #10
  tp->epending |= events;
  2010e2:	6343      	str	r3, [r0, #52]	; 0x34
  if (((tp->state == CH_STATE_WTOREVT) &&
  2010e4:	d00c      	beq.n	201100 <chEvtBroadcastFlagsI+0x50>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
  2010e6:	2a0b      	cmp	r2, #11
  2010e8:	d1ea      	bne.n	2010c0 <chEvtBroadcastFlagsI+0x10>
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
  2010ea:	6a42      	ldr	r2, [r0, #36]	; 0x24
      ((tp->state == CH_STATE_WTANDEVT) &&
  2010ec:	ea32 0303 	bics.w	r3, r2, r3
  2010f0:	d1e6      	bne.n	2010c0 <chEvtBroadcastFlagsI+0x10>
    tp->u.rdymsg = MSG_OK;
  2010f2:	6246      	str	r6, [r0, #36]	; 0x24
    (void) chSchReadyI(tp);
  2010f4:	f7ff f9bc 	bl	200470 <chSchReadyI>
    elp = elp->next;
  2010f8:	6824      	ldr	r4, [r4, #0]
  while (elp != (event_listener_t *)esp) {
  2010fa:	42a7      	cmp	r7, r4
  2010fc:	d1e3      	bne.n	2010c6 <chEvtBroadcastFlagsI+0x16>
  2010fe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
  201100:	6a42      	ldr	r2, [r0, #36]	; 0x24
  if (((tp->state == CH_STATE_WTOREVT) &&
  201102:	4213      	tst	r3, r2
  201104:	d0dc      	beq.n	2010c0 <chEvtBroadcastFlagsI+0x10>
    tp->u.rdymsg = MSG_OK;
  201106:	6246      	str	r6, [r0, #36]	; 0x24
    (void) chSchReadyI(tp);
  201108:	f7ff f9b2 	bl	200470 <chSchReadyI>
  20110c:	e7f4      	b.n	2010f8 <chEvtBroadcastFlagsI+0x48>
  20110e:	bf00      	nop

00201110 <sduDataReceived>:
  SerialUSBDriver *sdup = usbp->out_params[ep - 1U];
  201110:	310d      	adds	r1, #13
void sduDataReceived(USBDriver *usbp, usbep_t ep) {
  201112:	b538      	push	{r3, r4, r5, lr}
  SerialUSBDriver *sdup = usbp->out_params[ep - 1U];
  201114:	f850 4021 	ldr.w	r4, [r0, r1, lsl #2]
  if (sdup == NULL) {
  201118:	2c00      	cmp	r4, #0
  20111a:	d02f      	beq.n	20117c <sduDataReceived+0x6c>
  20111c:	2320      	movs	r3, #32
  20111e:	f383 8811 	msr	BASEPRI, r3
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
  201122:	2104      	movs	r1, #4
  ibqPostFullBufferI(&sdup->ibqueue,
  201124:	f104 050c 	add.w	r5, r4, #12
  201128:	1860      	adds	r0, r4, r1
  20112a:	f7ff ffc1 	bl	2010b0 <chEvtBroadcastFlagsI>
                     usbGetReceiveTransactionSizeX(sdup->config->usbp,
  20112e:	f8d4 148c 	ldr.w	r1, [r4, #1164]	; 0x48c
  *((size_t *)ibqp->bwrptr) = size;
  201132:	69e3      	ldr	r3, [r4, #28]
  201134:	7948      	ldrb	r0, [r1, #5]
  201136:	680a      	ldr	r2, [r1, #0]
  if (ibqp->bwrptr >= ibqp->btop) {
  201138:	6a61      	ldr	r1, [r4, #36]	; 0x24
  20113a:	eb02 0280 	add.w	r2, r2, r0, lsl #2
  20113e:	68d2      	ldr	r2, [r2, #12]
  ibqPostFullBufferI(&sdup->ibqueue,
  201140:	6992      	ldr	r2, [r2, #24]
  201142:	6852      	ldr	r2, [r2, #4]
  *((size_t *)ibqp->bwrptr) = size;
  201144:	601a      	str	r2, [r3, #0]
  ibqp->bwrptr += ibqp->bsize;
  201146:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  ibqp->bcounter++;
  201148:	69a2      	ldr	r2, [r4, #24]
  ibqp->bwrptr += ibqp->bsize;
  20114a:	4403      	add	r3, r0
  ibqp->bcounter++;
  20114c:	3201      	adds	r2, #1
  if (ibqp->bwrptr >= ibqp->btop) {
  20114e:	428b      	cmp	r3, r1
  ibqp->bwrptr += ibqp->bsize;
  201150:	61e3      	str	r3, [r4, #28]
  ibqp->bcounter++;
  201152:	61a2      	str	r2, [r4, #24]
  if (ibqp->bwrptr >= ibqp->btop) {
  201154:	d301      	bcc.n	20115a <sduDataReceived+0x4a>
    ibqp->bwrptr = ibqp->buffers;
  201156:	6b23      	ldr	r3, [r4, #48]	; 0x30
  201158:	61e3      	str	r3, [r4, #28]
  return (bool)(tqp->next != (const thread_t *)tqp);
  20115a:	68e3      	ldr	r3, [r4, #12]
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  if (queue_notempty(tqp)) {
  20115c:	429d      	cmp	r5, r3
  20115e:	d007      	beq.n	201170 <sduDataReceived+0x60>
  tqp->next             = tp->queue.next;
  201160:	681a      	ldr	r2, [r3, #0]

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
  201162:	2100      	movs	r1, #0
  (void) chSchReadyI(tp);
  201164:	4618      	mov	r0, r3
  201166:	60e2      	str	r2, [r4, #12]
  tqp->next->queue.prev = (thread_t *)tqp;
  201168:	6055      	str	r5, [r2, #4]
  tp->u.rdymsg = msg;
  20116a:	6259      	str	r1, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
  20116c:	f7ff f980 	bl	200470 <chSchReadyI>
  (void) sdu_start_receive(sdup);
  201170:	4620      	mov	r0, r4
  201172:	f7ff fee5 	bl	200f40 <sdu_start_receive.lto_priv.61>
  201176:	2300      	movs	r3, #0
  201178:	f383 8811 	msr	BASEPRI, r3
  20117c:	bd38      	pop	{r3, r4, r5, pc}
  20117e:	bf00      	nop

00201180 <sduDataTransmitted>:
  SerialUSBDriver *sdup = usbp->in_params[ep - 1U];
  201180:	eb00 0381 	add.w	r3, r0, r1, lsl #2
void sduDataTransmitted(USBDriver *usbp, usbep_t ep) {
  201184:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  SerialUSBDriver *sdup = usbp->in_params[ep - 1U];
  201188:	6a1c      	ldr	r4, [r3, #32]
void sduDataTransmitted(USBDriver *usbp, usbep_t ep) {
  20118a:	b082      	sub	sp, #8
  if (sdup == NULL) {
  20118c:	b1fc      	cbz	r4, 2011ce <sduDataTransmitted+0x4e>
  20118e:	460e      	mov	r6, r1
  201190:	4605      	mov	r5, r0
  201192:	2320      	movs	r3, #32
  201194:	f383 8811 	msr	BASEPRI, r3
  201198:	eb00 0881 	add.w	r8, r0, r1, lsl #2
  20119c:	1d20      	adds	r0, r4, #4
  20119e:	2108      	movs	r1, #8
  2011a0:	f7ff ff86 	bl	2010b0 <chEvtBroadcastFlagsI>
  if (usbp->epc[ep]->in_state->txsize > 0U) {
  2011a4:	f8d8 300c 	ldr.w	r3, [r8, #12]
  2011a8:	695b      	ldr	r3, [r3, #20]
  2011aa:	681b      	ldr	r3, [r3, #0]
  2011ac:	b993      	cbnz	r3, 2011d4 <sduDataTransmitted+0x54>
  2011ae:	f104 0744 	add.w	r7, r4, #68	; 0x44
  buf = obqGetFullBufferI(&sdup->obqueue, &n);
  2011b2:	4638      	mov	r0, r7
  2011b4:	a901      	add	r1, sp, #4
  2011b6:	f7ff ff03 	bl	200fc0 <obqGetFullBufferI>
  if (buf != NULL) {
  2011ba:	b350      	cbz	r0, 201212 <sduDataTransmitted+0x92>
    usbStartTransmitI(usbp, ep, buf, n);
  2011bc:	4602      	mov	r2, r0
  2011be:	4631      	mov	r1, r6
  2011c0:	4628      	mov	r0, r5
  2011c2:	9b01      	ldr	r3, [sp, #4]
  2011c4:	f7ff fea4 	bl	200f10 <usbStartTransmitI>
  2011c8:	2300      	movs	r3, #0
  2011ca:	f383 8811 	msr	BASEPRI, r3
}
  2011ce:	b002      	add	sp, #8
  2011d0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  obqp->brdptr += obqp->bsize;
  2011d4:	6da3      	ldr	r3, [r4, #88]	; 0x58
    obqReleaseEmptyBufferI(&sdup->obqueue);
  2011d6:	f104 0744 	add.w	r7, r4, #68	; 0x44
  2011da:	6e21      	ldr	r1, [r4, #96]	; 0x60
  obqp->bcounter++;
  2011dc:	6d22      	ldr	r2, [r4, #80]	; 0x50
  obqp->brdptr += obqp->bsize;
  2011de:	440b      	add	r3, r1
  if (obqp->brdptr >= obqp->btop) {
  2011e0:	6de1      	ldr	r1, [r4, #92]	; 0x5c
  obqp->bcounter++;
  2011e2:	3201      	adds	r2, #1
  if (obqp->brdptr >= obqp->btop) {
  2011e4:	428b      	cmp	r3, r1
  obqp->brdptr += obqp->bsize;
  2011e6:	65a3      	str	r3, [r4, #88]	; 0x58
  obqp->bcounter++;
  2011e8:	6522      	str	r2, [r4, #80]	; 0x50
  if (obqp->brdptr >= obqp->btop) {
  2011ea:	d301      	bcc.n	2011f0 <sduDataTransmitted+0x70>
    obqp->brdptr = obqp->buffers;
  2011ec:	6ea3      	ldr	r3, [r4, #104]	; 0x68
  2011ee:	65a3      	str	r3, [r4, #88]	; 0x58
  return (bool)(tqp->next != (const thread_t *)tqp);
  2011f0:	6c63      	ldr	r3, [r4, #68]	; 0x44
  2011f2:	429f      	cmp	r7, r3
  2011f4:	d0dd      	beq.n	2011b2 <sduDataTransmitted+0x32>
  tqp->next             = tp->queue.next;
  2011f6:	681a      	ldr	r2, [r3, #0]
  tp->u.rdymsg = msg;
  2011f8:	2100      	movs	r1, #0
  (void) chSchReadyI(tp);
  2011fa:	4618      	mov	r0, r3
  2011fc:	6462      	str	r2, [r4, #68]	; 0x44
  tqp->next->queue.prev = (thread_t *)tqp;
  2011fe:	6057      	str	r7, [r2, #4]
  tp->u.rdymsg = msg;
  201200:	6259      	str	r1, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
  201202:	f7ff f935 	bl	200470 <chSchReadyI>
  buf = obqGetFullBufferI(&sdup->obqueue, &n);
  201206:	4638      	mov	r0, r7
  201208:	a901      	add	r1, sp, #4
  20120a:	f7ff fed9 	bl	200fc0 <obqGetFullBufferI>
  if (buf != NULL) {
  20120e:	2800      	cmp	r0, #0
  201210:	d1d4      	bne.n	2011bc <sduDataTransmitted+0x3c>
  else if ((usbp->epc[ep]->in_state->txsize > 0U) &&
  201212:	f8d8 300c 	ldr.w	r3, [r8, #12]
  201216:	695a      	ldr	r2, [r3, #20]
  201218:	6812      	ldr	r2, [r2, #0]
  20121a:	2a00      	cmp	r2, #0
  20121c:	d0d4      	beq.n	2011c8 <sduDataTransmitted+0x48>
            ((size_t)usbp->epc[ep]->in_maxsize - 1U)) == 0U)) {
  20121e:	8a1b      	ldrh	r3, [r3, #16]
  201220:	3b01      	subs	r3, #1
  else if ((usbp->epc[ep]->in_state->txsize > 0U) &&
  201222:	4013      	ands	r3, r2
  201224:	d1d0      	bne.n	2011c8 <sduDataTransmitted+0x48>
    usbStartTransmitI(usbp, ep, usbp->setup, 0);
  201226:	4631      	mov	r1, r6
  201228:	f105 025c 	add.w	r2, r5, #92	; 0x5c
  20122c:	4628      	mov	r0, r5
  20122e:	f7ff fe6f 	bl	200f10 <usbStartTransmitI>
  201232:	e7c9      	b.n	2011c8 <sduDataTransmitted+0x48>
	...

00201240 <chTMStopMeasurementX>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
  201240:	4b0e      	ldr	r3, [pc, #56]	; (20127c <chTMStopMeasurementX+0x3c>)
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
  201242:	6882      	ldr	r2, [r0, #8]
  201244:	685b      	ldr	r3, [r3, #4]
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
  201246:	490e      	ldr	r1, [pc, #56]	; (201280 <chTMStopMeasurementX+0x40>)
  tmp->last = (now - tmp->last) - offset;
  201248:	1a9b      	subs	r3, r3, r2
  if (tmp->last > tmp->worst) {
  20124a:	6842      	ldr	r2, [r0, #4]
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
  20124c:	b430      	push	{r4, r5}
  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
  20124e:	6f4c      	ldr	r4, [r1, #116]	; 0x74
  tmp->n++;
  201250:	68c1      	ldr	r1, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
  201252:	1b1b      	subs	r3, r3, r4
  tmp->n++;
  201254:	3101      	adds	r1, #1
  tmp->last = (now - tmp->last) - offset;
  201256:	6083      	str	r3, [r0, #8]
  tmp->n++;
  201258:	60c1      	str	r1, [r0, #12]
  tmp->cumulative += (rttime_t)tmp->last;
  20125a:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
  20125e:	18e4      	adds	r4, r4, r3
  201260:	f145 0500 	adc.w	r5, r5, #0
  if (tmp->last > tmp->worst) {
  201264:	4293      	cmp	r3, r2
  if (tmp->last < tmp->best) {
  201266:	6802      	ldr	r2, [r0, #0]
    tmp->worst = tmp->last;
  201268:	bf88      	it	hi
  20126a:	6043      	strhi	r3, [r0, #4]
  if (tmp->last < tmp->best) {
  20126c:	4293      	cmp	r3, r2
  tmp->cumulative += (rttime_t)tmp->last;
  20126e:	e9c0 4504 	strd	r4, r5, [r0, #16]
    tmp->best = tmp->last;
  201272:	bf38      	it	cc
  201274:	6003      	strcc	r3, [r0, #0]
}
  201276:	bc30      	pop	{r4, r5}
  201278:	4770      	bx	lr
  20127a:	bf00      	nop
  20127c:	e0001000 	.word	0xe0001000
  201280:	200012a0 	.word	0x200012a0
	...

00201290 <chThdDequeueAllI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {
  201290:	b538      	push	{r3, r4, r5, lr}
  return (bool)(tqp->next != (const thread_t *)tqp);
  201292:	6803      	ldr	r3, [r0, #0]

  while (queue_notempty(tqp)) {
  201294:	4298      	cmp	r0, r3
  201296:	d00b      	beq.n	2012b0 <chThdDequeueAllI+0x20>
  201298:	4604      	mov	r4, r0
  20129a:	460d      	mov	r5, r1
  tqp->next             = tp->queue.next;
  20129c:	681a      	ldr	r2, [r3, #0]
  20129e:	4618      	mov	r0, r3
  2012a0:	6022      	str	r2, [r4, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
  2012a2:	6054      	str	r4, [r2, #4]
  tp->u.rdymsg = msg;
  2012a4:	625d      	str	r5, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
  2012a6:	f7ff f8e3 	bl	200470 <chSchReadyI>
  return (bool)(tqp->next != (const thread_t *)tqp);
  2012aa:	6823      	ldr	r3, [r4, #0]
  2012ac:	429c      	cmp	r4, r3
  2012ae:	d1f5      	bne.n	20129c <chThdDequeueAllI+0xc>
  2012b0:	bd38      	pop	{r3, r4, r5, pc}
  2012b2:	bf00      	nop
	...

002012c0 <chThdResumeI>:
  if (*trp != NULL) {
  2012c0:	6803      	ldr	r3, [r0, #0]
  2012c2:	b143      	cbz	r3, 2012d6 <chThdResumeI+0x16>
  2012c4:	4602      	mov	r2, r0
    (void) chSchReadyI(tp);
  2012c6:	4618      	mov	r0, r3
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
  2012c8:	b410      	push	{r4}
    *trp = NULL;
  2012ca:	2400      	movs	r4, #0
  2012cc:	6014      	str	r4, [r2, #0]
    tp->u.rdymsg = msg;
  2012ce:	6259      	str	r1, [r3, #36]	; 0x24
}
  2012d0:	bc10      	pop	{r4}
    (void) chSchReadyI(tp);
  2012d2:	f7ff b8cd 	b.w	200470 <chSchReadyI>
  2012d6:	4770      	bx	lr
	...

002012e0 <chThdSleep>:
void chThdSleep(sysinterval_t time) {
  2012e0:	b508      	push	{r3, lr}
  2012e2:	4601      	mov	r1, r0
  2012e4:	2320      	movs	r3, #32
  2012e6:	f383 8811 	msr	BASEPRI, r3
  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
  2012ea:	2008      	movs	r0, #8
  2012ec:	f7ff fb70 	bl	2009d0 <chSchGoSleepTimeoutS>
  2012f0:	2300      	movs	r3, #0
  2012f2:	f383 8811 	msr	BASEPRI, r3
  2012f6:	bd08      	pop	{r3, pc}
	...

00201300 <chThdExit>:
void chThdExit(msg_t msg) {
  201300:	b538      	push	{r3, r4, r5, lr}
  201302:	2220      	movs	r2, #32
  201304:	4603      	mov	r3, r0
  201306:	f382 8811 	msr	BASEPRI, r2
  thread_t *tp = currp;
  20130a:	4a10      	ldr	r2, [pc, #64]	; (20134c <chThdExit+0x4c>)
  20130c:	6994      	ldr	r4, [r2, #24]
  while (list_notempty(&tp->waiting)) {
  20130e:	f104 0528 	add.w	r5, r4, #40	; 0x28
  return (bool)(tlp->next != (thread_t *)tlp);
  201312:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  tp->u.exitcode = msg;
  201314:	6263      	str	r3, [r4, #36]	; 0x24
  while (list_notempty(&tp->waiting)) {
  201316:	4285      	cmp	r5, r0
  201318:	d006      	beq.n	201328 <chThdExit+0x28>
  tlp->next = tp->queue.next;
  20131a:	6803      	ldr	r3, [r0, #0]
  20131c:	62a3      	str	r3, [r4, #40]	; 0x28
    (void) chSchReadyI(list_remove(&tp->waiting));
  20131e:	f7ff f8a7 	bl	200470 <chSchReadyI>
  return (bool)(tlp->next != (thread_t *)tlp);
  201322:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  while (list_notempty(&tp->waiting)) {
  201324:	42a8      	cmp	r0, r5
  201326:	d1f8      	bne.n	20131a <chThdExit+0x1a>
  if ((tp->refs == (trefs_t)0) &&
  201328:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
  20132c:	b943      	cbnz	r3, 201340 <chThdExit+0x40>
  20132e:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
  201332:	079b      	lsls	r3, r3, #30
  201334:	d104      	bne.n	201340 <chThdExit+0x40>
    REG_REMOVE(tp);
  201336:	6922      	ldr	r2, [r4, #16]
  201338:	6963      	ldr	r3, [r4, #20]
  20133a:	611a      	str	r2, [r3, #16]
  20133c:	6922      	ldr	r2, [r4, #16]
  20133e:	6153      	str	r3, [r2, #20]
  chSchGoSleepS(CH_STATE_FINAL);
  201340:	200f      	movs	r0, #15
}
  201342:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chSchGoSleepS(CH_STATE_FINAL);
  201346:	f7ff bb2b 	b.w	2009a0 <chSchGoSleepS>
  20134a:	bf00      	nop
  20134c:	200012a0 	.word	0x200012a0

00201350 <chSchDoReschedule>:
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
  thread_t *otp = currp;
  201350:	4a0e      	ldr	r2, [pc, #56]	; (20138c <chSchDoReschedule+0x3c>)

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
  201352:	2101      	movs	r1, #1
  thread_t *tp = tqp->next;
  201354:	6810      	ldr	r0, [r2, #0]
void chSchDoReschedule(void) {
  201356:	b430      	push	{r4, r5}
  tqp->next             = tp->queue.next;
  201358:	6803      	ldr	r3, [r0, #0]
  tp->state = CH_STATE_READY;
  20135a:	2500      	movs	r5, #0
  thread_t *otp = currp;
  20135c:	6994      	ldr	r4, [r2, #24]
  20135e:	6013      	str	r3, [r2, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
  201360:	605a      	str	r2, [r3, #4]
  currp->state = CH_STATE_CURRENT;
  201362:	f880 1020 	strb.w	r1, [r0, #32]
  tp->state = CH_STATE_READY;
  201366:	f884 5020 	strb.w	r5, [r4, #32]

  /* Handling idle-leave hook.*/
  if (otp->prio == IDLEPRIO) {
  20136a:	68a1      	ldr	r1, [r4, #8]
  currp = queue_fifo_remove(&ch.rlist.queue);
  20136c:	6190      	str	r0, [r2, #24]
  20136e:	e000      	b.n	201372 <chSchDoReschedule+0x22>
  201370:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio > tp->prio);
  201372:	689a      	ldr	r2, [r3, #8]
  201374:	4291      	cmp	r1, r2
  201376:	d3fb      	bcc.n	201370 <chSchDoReschedule+0x20>
  tp->queue.prev             = cp->queue.prev;
  201378:	685a      	ldr	r2, [r3, #4]
     ahead of its peers.*/
  otp = chSchReadyAheadI(otp);
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
  20137a:	4621      	mov	r1, r4
  tp->queue.next             = cp;
  20137c:	6023      	str	r3, [r4, #0]
  tp->queue.prev             = cp->queue.prev;
  20137e:	6062      	str	r2, [r4, #4]
  tp->queue.prev->queue.next = tp;
  201380:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
  201382:	605c      	str	r4, [r3, #4]
}
  201384:	bc30      	pop	{r4, r5}
  chSysSwitch(currp, otp);
  201386:	f7fe bfab 	b.w	2002e0 <_port_switch>
  20138a:	bf00      	nop
  20138c:	200012a0 	.word	0x200012a0

00201390 <chSysPolledDelayX>:
  201390:	4a03      	ldr	r2, [pc, #12]	; (2013a0 <chSysPolledDelayX+0x10>)
  201392:	6851      	ldr	r1, [r2, #4]
  201394:	6853      	ldr	r3, [r2, #4]
 *
 * @xclass
 */
bool chSysIsCounterWithinX(rtcnt_t cnt, rtcnt_t start, rtcnt_t end) {

  return (bool)((cnt - start) < (end - start));
  201396:	1a5b      	subs	r3, r3, r1
 */
void chSysPolledDelayX(rtcnt_t cycles) {
  rtcnt_t start = chSysGetRealtimeCounterX();
  rtcnt_t end  = start + cycles;

  while (chSysIsCounterWithinX(chSysGetRealtimeCounterX(), start, end)) {
  201398:	4298      	cmp	r0, r3
  20139a:	d8fb      	bhi.n	201394 <chSysPolledDelayX+0x4>
  }
}
  20139c:	4770      	bx	lr
  20139e:	bf00      	nop
  2013a0:	e0001000 	.word	0xe0001000
	...

002013b0 <usbInitEndpointI>:
                      const USBEndpointConfig *epcp) {
  2013b0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  2013b4:	fa0f f881 	sxth.w	r8, r1
  if (epcp->in_state != NULL) {
  2013b8:	6953      	ldr	r3, [r2, #20]
                      const USBEndpointConfig *epcp) {
  2013ba:	460d      	mov	r5, r1
  2013bc:	eb00 0688 	add.w	r6, r0, r8, lsl #2
  usbp->epc[ep] = epcp;
  2013c0:	60f2      	str	r2, [r6, #12]
  if (epcp->in_state != NULL) {
  2013c2:	b123      	cbz	r3, 2013ce <usbInitEndpointI+0x1e>
    memset(epcp->in_state, 0, sizeof(USBInEndpointState));
  2013c4:	2100      	movs	r1, #0
  2013c6:	6019      	str	r1, [r3, #0]
  2013c8:	6059      	str	r1, [r3, #4]
  2013ca:	6099      	str	r1, [r3, #8]
  2013cc:	60d9      	str	r1, [r3, #12]
  if (epcp->out_state != NULL) {
  2013ce:	6993      	ldr	r3, [r2, #24]
  2013d0:	b123      	cbz	r3, 2013dc <usbInitEndpointI+0x2c>
    memset(epcp->out_state, 0, sizeof(USBOutEndpointState));
  2013d2:	2200      	movs	r2, #0
  2013d4:	601a      	str	r2, [r3, #0]
  2013d6:	605a      	str	r2, [r3, #4]
  2013d8:	609a      	str	r2, [r3, #8]
  2013da:	60da      	str	r2, [r3, #12]
  switch (usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) {
  2013dc:	68f3      	ldr	r3, [r6, #12]
  2013de:	681a      	ldr	r2, [r3, #0]
  2013e0:	f002 0203 	and.w	r2, r2, #3
  2013e4:	2a02      	cmp	r2, #2
  2013e6:	d05b      	beq.n	2014a0 <usbInitEndpointI+0xf0>
  2013e8:	2a03      	cmp	r2, #3
  2013ea:	d05b      	beq.n	2014a4 <usbInitEndpointI+0xf4>
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL;
  2013ec:	4f4a      	ldr	r7, [pc, #296]	; (201518 <usbInitEndpointI+0x168>)
  2013ee:	494b      	ldr	r1, [pc, #300]	; (20151c <usbInitEndpointI+0x16c>)
  2013f0:	2a01      	cmp	r2, #1
  2013f2:	bf18      	it	ne
  2013f4:	460f      	movne	r7, r1
  stm32_otg_t *otgp = usbp->otg;
  2013f6:	6ec4      	ldr	r4, [r0, #108]	; 0x6c
  otgp->oe[ep].DOEPTSIZ = 0;
  2013f8:	ea4f 1e45 	mov.w	lr, r5, lsl #5
  2013fc:	f04f 0c00 	mov.w	ip, #0
  if (usbp->epc[ep]->out_state != NULL) {
  201400:	699a      	ldr	r2, [r3, #24]
  otgp->oe[ep].DOEPTSIZ = 0;
  201402:	eb04 010e 	add.w	r1, r4, lr
  201406:	f8c1 cb10 	str.w	ip, [r1, #2832]	; 0xb10
  if (usbp->epc[ep]->out_state != NULL) {
  20140a:	2a00      	cmp	r2, #0
  20140c:	d06f      	beq.n	2014ee <usbInitEndpointI+0x13e>
    otgp->oe[ep].DOEPCTL = ctl | DOEPCTL_MPSIZ(usbp->epc[ep]->out_maxsize);
  20140e:	f8b3 c012 	ldrh.w	ip, [r3, #18]
  201412:	f105 0158 	add.w	r1, r5, #88	; 0x58
    otgp->DAINTMSK |= DAINTMSK_OEPM(ep);
  201416:	f105 0910 	add.w	r9, r5, #16
  20141a:	2201      	movs	r2, #1
    otgp->oe[ep].DOEPCTL = ctl | DOEPCTL_MPSIZ(usbp->epc[ep]->out_maxsize);
  20141c:	0149      	lsls	r1, r1, #5
  20141e:	ea4c 0c07 	orr.w	ip, ip, r7
    otgp->DAINTMSK |= DAINTMSK_OEPM(ep);
  201422:	fa02 f209 	lsl.w	r2, r2, r9
    otgp->oe[ep].DOEPCTL = ctl | DOEPCTL_MPSIZ(usbp->epc[ep]->out_maxsize);
  201426:	f844 c001 	str.w	ip, [r4, r1]
    otgp->DAINTMSK |= DAINTMSK_OEPM(ep);
  20142a:	f8d4 181c 	ldr.w	r1, [r4, #2076]	; 0x81c
  20142e:	430a      	orrs	r2, r1
  201430:	f8c4 281c 	str.w	r2, [r4, #2076]	; 0x81c
  otgp->ie[ep].DIEPTSIZ = 0;
  201434:	44a6      	add	lr, r4
  201436:	2100      	movs	r1, #0
  if (usbp->epc[ep]->in_state != NULL) {
  201438:	695a      	ldr	r2, [r3, #20]
  otgp->ie[ep].DIEPTSIZ = 0;
  20143a:	f8ce 1910 	str.w	r1, [lr, #2320]	; 0x910
  if (usbp->epc[ep]->in_state != NULL) {
  20143e:	b39a      	cbz	r2, 2014a8 <usbInitEndpointI+0xf8>
    if (usbp->epc[ep]->in_multiplier > 1)
  201440:	8b9a      	ldrh	r2, [r3, #28]
    fsize = usbp->epc[ep]->in_maxsize / 4;
  201442:	8a19      	ldrh	r1, [r3, #16]
    if (usbp->epc[ep]->in_multiplier > 1)
  201444:	2a01      	cmp	r2, #1
  next = usbp->pmnext;
  201446:	f8d0 e074 	ldr.w	lr, [r0, #116]	; 0x74
    fsize = usbp->epc[ep]->in_maxsize / 4;
  20144a:	ea4f 0391 	mov.w	r3, r1, lsr #2
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
  20144e:	f105 013f 	add.w	r1, r5, #63	; 0x3f
      fsize *= usbp->epc[ep]->in_multiplier;
  201452:	bf88      	it	hi
  201454:	4353      	mulhi	r3, r2
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
  201456:	01aa      	lsls	r2, r5, #6
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
  201458:	eb04 0181 	add.w	r1, r4, r1, lsl #2
  usbp->pmnext += size;
  20145c:	eb03 0c0e 	add.w	ip, r3, lr
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
  201460:	f042 0220 	orr.w	r2, r2, #32
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
  201464:	ea4e 4303 	orr.w	r3, lr, r3, lsl #16
  usbp->pmnext += size;
  201468:	f8c0 c074 	str.w	ip, [r0, #116]	; 0x74
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
  20146c:	604b      	str	r3, [r1, #4]
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
  20146e:	6122      	str	r2, [r4, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
  201470:	6923      	ldr	r3, [r4, #16]
  201472:	069a      	lsls	r2, r3, #26
  201474:	d4fc      	bmi.n	201470 <usbInitEndpointI+0xc0>
  chSysPolledDelayX(cycles);
  201476:	2012      	movs	r0, #18
  201478:	f7ff ff8a 	bl	201390 <chSysPolledDelayX>
                           DIEPCTL_MPSIZ(usbp->epc[ep]->in_maxsize);
  20147c:	68f2      	ldr	r2, [r6, #12]
    otgp->ie[ep].DIEPCTL = ctl |
  20147e:	f105 0148 	add.w	r1, r5, #72	; 0x48
    otgp->DAINTMSK |= DAINTMSK_IEPM(ep);
  201482:	2301      	movs	r3, #1
                           DIEPCTL_MPSIZ(usbp->epc[ep]->in_maxsize);
  201484:	8a12      	ldrh	r2, [r2, #16]
    otgp->ie[ep].DIEPCTL = ctl |
  201486:	0149      	lsls	r1, r1, #5
    otgp->DAINTMSK |= DAINTMSK_IEPM(ep);
  201488:	40ab      	lsls	r3, r5
                           DIEPCTL_TXFNUM(ep) |
  20148a:	ea42 5285 	orr.w	r2, r2, r5, lsl #22
  20148e:	433a      	orrs	r2, r7
    otgp->ie[ep].DIEPCTL = ctl |
  201490:	5062      	str	r2, [r4, r1]
    otgp->DAINTMSK |= DAINTMSK_IEPM(ep);
  201492:	f8d4 281c 	ldr.w	r2, [r4, #2076]	; 0x81c
  201496:	4313      	orrs	r3, r2
  201498:	f8c4 381c 	str.w	r3, [r4, #2076]	; 0x81c
  20149c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_BULK;
  2014a0:	4f1f      	ldr	r7, [pc, #124]	; (201520 <usbInitEndpointI+0x170>)
  2014a2:	e7a8      	b.n	2013f6 <usbInitEndpointI+0x46>
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_INTR;
  2014a4:	4f1f      	ldr	r7, [pc, #124]	; (201524 <usbInitEndpointI+0x174>)
  2014a6:	e7a6      	b.n	2013f6 <usbInitEndpointI+0x46>
    otgp->DIEPTXF[ep - 1] = 0x02000400; /* Reset value.*/
  2014a8:	f105 023f 	add.w	r2, r5, #63	; 0x3f
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
  2014ac:	01ab      	lsls	r3, r5, #6
    otgp->DIEPTXF[ep - 1] = 0x02000400; /* Reset value.*/
  2014ae:	491e      	ldr	r1, [pc, #120]	; (201528 <usbInitEndpointI+0x178>)
  2014b0:	eb04 0282 	add.w	r2, r4, r2, lsl #2
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
  2014b4:	f043 0320 	orr.w	r3, r3, #32
    otgp->DIEPTXF[ep - 1] = 0x02000400; /* Reset value.*/
  2014b8:	6051      	str	r1, [r2, #4]
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
  2014ba:	6123      	str	r3, [r4, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
  2014bc:	6923      	ldr	r3, [r4, #16]
  2014be:	069b      	lsls	r3, r3, #26
  2014c0:	d4fc      	bmi.n	2014bc <usbInitEndpointI+0x10c>
  2014c2:	2012      	movs	r0, #18
  2014c4:	eb04 1848 	add.w	r8, r4, r8, lsl #5
  2014c8:	f7ff ff62 	bl	201390 <chSysPolledDelayX>
    otgp->DAINTMSK &= ~DAINTMSK_IEPM(ep);
  2014cc:	2301      	movs	r3, #1
  2014ce:	fa03 f505 	lsl.w	r5, r3, r5
    otgp->ie[ep].DIEPCTL &= ~DIEPCTL_USBAEP;
  2014d2:	f8d8 3900 	ldr.w	r3, [r8, #2304]	; 0x900
  2014d6:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
  2014da:	f8c8 3900 	str.w	r3, [r8, #2304]	; 0x900
    otgp->DAINTMSK &= ~DAINTMSK_IEPM(ep);
  2014de:	f8d4 381c 	ldr.w	r3, [r4, #2076]	; 0x81c
  2014e2:	ea23 0305 	bic.w	r3, r3, r5
  2014e6:	f8c4 381c 	str.w	r3, [r4, #2076]	; 0x81c
  2014ea:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  2014ee:	eb04 1248 	add.w	r2, r4, r8, lsl #5
    otgp->DAINTMSK &= ~DAINTMSK_OEPM(ep);
  2014f2:	f105 0910 	add.w	r9, r5, #16
  2014f6:	2101      	movs	r1, #1
    otgp->oe[ep].DOEPCTL &= ~DOEPCTL_USBAEP;
  2014f8:	f8d2 cb00 	ldr.w	ip, [r2, #2816]	; 0xb00
    otgp->DAINTMSK &= ~DAINTMSK_OEPM(ep);
  2014fc:	fa01 f109 	lsl.w	r1, r1, r9
    otgp->oe[ep].DOEPCTL &= ~DOEPCTL_USBAEP;
  201500:	f42c 4c00 	bic.w	ip, ip, #32768	; 0x8000
  201504:	f8c2 cb00 	str.w	ip, [r2, #2816]	; 0xb00
    otgp->DAINTMSK &= ~DAINTMSK_OEPM(ep);
  201508:	f8d4 281c 	ldr.w	r2, [r4, #2076]	; 0x81c
  20150c:	ea22 0201 	bic.w	r2, r2, r1
  201510:	f8c4 281c 	str.w	r2, [r4, #2076]	; 0x81c
  201514:	e78e      	b.n	201434 <usbInitEndpointI+0x84>
  201516:	bf00      	nop
  201518:	10048000 	.word	0x10048000
  20151c:	10008000 	.word	0x10008000
  201520:	10088000 	.word	0x10088000
  201524:	100c8000 	.word	0x100c8000
  201528:	02000400 	.word	0x02000400
  20152c:	00000000 	.word	0x00000000

00201530 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
  201530:	b5f0      	push	{r4, r5, r6, r7, lr}
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
  201532:	4f12      	ldr	r7, [pc, #72]	; (20157c <__init_ram_areas+0x4c>)
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
  201534:	2600      	movs	r6, #0
void __init_ram_areas(void) {
  201536:	4d12      	ldr	r5, [pc, #72]	; (201580 <__init_ram_areas+0x50>)
  201538:	f107 0e80 	add.w	lr, r7, #128	; 0x80
  20153c:	4c11      	ldr	r4, [pc, #68]	; (201584 <__init_ram_areas+0x54>)
  20153e:	4b12      	ldr	r3, [pc, #72]	; (201588 <__init_ram_areas+0x58>)
  201540:	4912      	ldr	r1, [pc, #72]	; (20158c <__init_ram_areas+0x5c>)
    while (p < rap->clear_area) {
  201542:	429c      	cmp	r4, r3
  201544:	d911      	bls.n	20156a <__init_ram_areas+0x3a>
  201546:	3904      	subs	r1, #4
  201548:	461a      	mov	r2, r3
      *p = *tp;
  20154a:	f851 0f04 	ldr.w	r0, [r1, #4]!
  20154e:	f842 0b04 	str.w	r0, [r2], #4
    while (p < rap->clear_area) {
  201552:	4294      	cmp	r4, r2
  201554:	d8f9      	bhi.n	20154a <__init_ram_areas+0x1a>
  201556:	43da      	mvns	r2, r3
  201558:	4414      	add	r4, r2
  20155a:	f024 0403 	bic.w	r4, r4, #3
  20155e:	3404      	adds	r4, #4
  201560:	4423      	add	r3, r4
    while (p < rap->no_init_area) {
  201562:	429d      	cmp	r5, r3
  201564:	d903      	bls.n	20156e <__init_ram_areas+0x3e>
      *p = 0;
  201566:	f843 6b04 	str.w	r6, [r3], #4
    while (p < rap->no_init_area) {
  20156a:	429d      	cmp	r5, r3
  20156c:	d8fb      	bhi.n	201566 <__init_ram_areas+0x36>
      p++;
    }
    rap++;
  20156e:	3710      	adds	r7, #16
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
  201570:	4577      	cmp	r7, lr
  201572:	d202      	bcs.n	20157a <__init_ram_areas+0x4a>
  201574:	e897 003a 	ldmia.w	r7, {r1, r3, r4, r5}
  201578:	e7e3      	b.n	201542 <__init_ram_areas+0x12>
  20157a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  20157c:	08003bb8 	.word	0x08003bb8
  201580:	20020008 	.word	0x20020008
  201584:	20020008 	.word	0x20020008
  201588:	20020008 	.word	0x20020008
  20158c:	08003f74 	.word	0x08003f74

00201590 <__default_exit>:
void __default_exit(void) {
  201590:	e7fe      	b.n	201590 <__default_exit>
  201592:	bf00      	nop
	...

002015a0 <__late_init>:
void __late_init(void) {}
  2015a0:	4770      	bx	lr
  2015a2:	bf00      	nop
	...

002015b0 <__core_init>:
void __core_init(void) {
  2015b0:	b5f0      	push	{r4, r5, r6, r7, lr}
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
  2015b2:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  2015b6:	f3bf 8f6f 	isb	sy
__STATIC_INLINE void SCB_EnableICache (void)
{
  #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)
    __DSB();
    __ISB();
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
  2015ba:	4c1d      	ldr	r4, [pc, #116]	; (201630 <__core_init+0x80>)
  2015bc:	2200      	movs	r2, #0
  2015be:	f8c4 2250 	str.w	r2, [r4, #592]	; 0x250
  __ASM volatile ("dsb 0xF":::"memory");
  2015c2:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  2015c6:	f3bf 8f6f 	isb	sy
    __DSB();
    __ISB();
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
  2015ca:	6963      	ldr	r3, [r4, #20]
  2015cc:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  2015d0:	6163      	str	r3, [r4, #20]
  __ASM volatile ("dsb 0xF":::"memory");
  2015d2:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  2015d6:	f3bf 8f6f 	isb	sy
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    uint32_t ccsidr;
    uint32_t sets;
    uint32_t ways;

    SCB->CSSELR = 0U; /*(0U << 1U) | 0U;*/  /* Level 1 data cache */
  2015da:	f8c4 2084 	str.w	r2, [r4, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
  2015de:	f3bf 8f4f 	dsb	sy
    __DSB();

    ccsidr = SCB->CCSIDR;
  2015e2:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
  2015e6:	f643 7ee0 	movw	lr, #16352	; 0x3fe0
  2015ea:	f3c3 06c9 	ubfx	r6, r3, #3, #10

                                            /* invalidate D-Cache */
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
  2015ee:	f3c3 334e 	ubfx	r3, r3, #13, #15
  2015f2:	07b7      	lsls	r7, r6, #30
  2015f4:	015d      	lsls	r5, r3, #5
  2015f6:	ea05 000e 	and.w	r0, r5, lr
  2015fa:	4639      	mov	r1, r7
    do {
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
  2015fc:	4632      	mov	r2, r6
      do {
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
  2015fe:	ea41 0300 	orr.w	r3, r1, r0
                      ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );
        #if defined ( __CC_ARM )
          __schedule_barrier();
        #endif
      } while (ways-- != 0U);
  201602:	3a01      	subs	r2, #1
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
  201604:	f101 4140 	add.w	r1, r1, #3221225472	; 0xc0000000
  201608:	f8c4 3260 	str.w	r3, [r4, #608]	; 0x260
      } while (ways-- != 0U);
  20160c:	1c53      	adds	r3, r2, #1
  20160e:	d1f6      	bne.n	2015fe <__core_init+0x4e>
  201610:	3d20      	subs	r5, #32
    } while(sets-- != 0U);
  201612:	f115 0f20 	cmn.w	r5, #32
  201616:	d1ee      	bne.n	2015f6 <__core_init+0x46>
  201618:	f3bf 8f4f 	dsb	sy
    __DSB();

    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
  20161c:	6963      	ldr	r3, [r4, #20]
  20161e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
  201622:	6163      	str	r3, [r4, #20]
  201624:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  201628:	f3bf 8f6f 	isb	sy
  20162c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  20162e:	bf00      	nop
  201630:	e000ed00 	.word	0xe000ed00
	...

00201640 <_usb_ep0out>:
 * @notapi
 */
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {

  (void)ep;
  switch (usbp->ep0state) {
  201640:	f890 204c 	ldrb.w	r2, [r0, #76]	; 0x4c
  201644:	2a15      	cmp	r2, #21
  201646:	d80d      	bhi.n	201664 <_usb_ep0out+0x24>
  201648:	f640 6141 	movw	r1, #3649	; 0xe41
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
  20164c:	b538      	push	{r3, r4, r5, lr}
  20164e:	2301      	movs	r3, #1
  201650:	4604      	mov	r4, r0
  201652:	4093      	lsls	r3, r2
  201654:	420b      	tst	r3, r1
  201656:	d112      	bne.n	20167e <_usb_ep0out+0x3e>
  201658:	f413 1580 	ands.w	r5, r3, #1048576	; 0x100000
  20165c:	d103      	bne.n	201666 <_usb_ep0out+0x26>
  20165e:	029b      	lsls	r3, r3, #10
  201660:	d423      	bmi.n	2016aa <_usb_ep0out+0x6a>
  201662:	bd38      	pop	{r3, r4, r5, pc}
  201664:	4770      	bx	lr
    return;
  case USB_EP0_OUT_WAITING_STS:
    /* Status packet received, it must be zero sized, invoking the callback
       if defined.*/
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    if (usbGetReceiveTransactionSizeX(usbp, 0) != 0U) {
  201666:	68c3      	ldr	r3, [r0, #12]
  201668:	699b      	ldr	r3, [r3, #24]
  20166a:	685b      	ldr	r3, [r3, #4]
  20166c:	2b00      	cmp	r3, #0
  20166e:	d1f8      	bne.n	201662 <_usb_ep0out+0x22>
      break;
    }
#endif
    if (usbp->ep0endcb != NULL) {
  201670:	6d83      	ldr	r3, [r0, #88]	; 0x58
  201672:	b103      	cbz	r3, 201676 <_usb_ep0out+0x36>
      usbp->ep0endcb(usbp);
  201674:	4798      	blx	r3
    }
    usbp->ep0state = USB_EP0_STP_WAITING;
  201676:	2300      	movs	r3, #0
  201678:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
  20167c:	bd38      	pop	{r3, r4, r5, pc}
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
  20167e:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
    /* Error response, the state machine goes into an error state, the low
       level layer will have to reset it to USB_EP0_WAITING_SETUP after
       receiving a SETUP packet.*/
    usb_lld_stall_in(usbp, 0);
    usb_lld_stall_out(usbp, 0);
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
  201680:	6841      	ldr	r1, [r0, #4]
  201682:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
  201686:	680d      	ldr	r5, [r1, #0]
  201688:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
  20168c:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
  201690:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	; 0xb00
  201694:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
  201698:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
  20169c:	b10d      	cbz	r5, 2016a2 <_usb_ep0out+0x62>
  20169e:	2106      	movs	r1, #6
  2016a0:	47a8      	blx	r5
    usbp->ep0state = USB_EP0_ERROR;
  2016a2:	2306      	movs	r3, #6
  2016a4:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
  2016a8:	bd38      	pop	{r3, r4, r5, pc}
    usbp->ep0state = USB_EP0_IN_SENDING_STS;
  2016aa:	220b      	movs	r2, #11
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2016ac:	2320      	movs	r3, #32
  2016ae:	f880 204c 	strb.w	r2, [r0, #76]	; 0x4c
  2016b2:	f383 8811 	msr	BASEPRI, r3
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
  2016b6:	8902      	ldrh	r2, [r0, #8]
  usb_lld_start_in(usbp, ep);
  2016b8:	4629      	mov	r1, r5
  isp = usbp->epc[ep]->in_state;
  2016ba:	68c3      	ldr	r3, [r0, #12]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
  2016bc:	f042 0201 	orr.w	r2, r2, #1
  isp = usbp->epc[ep]->in_state;
  2016c0:	695b      	ldr	r3, [r3, #20]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
  2016c2:	8102      	strh	r2, [r0, #8]
  isp->txbuf  = buf;
  2016c4:	609d      	str	r5, [r3, #8]
  isp->txsize = n;
  2016c6:	601d      	str	r5, [r3, #0]
  isp->txcnt  = 0;
  2016c8:	605d      	str	r5, [r3, #4]
  usb_lld_start_in(usbp, ep);
  2016ca:	f002 f851 	bl	203770 <usb_lld_start_in>
  2016ce:	f385 8811 	msr	BASEPRI, r5
  2016d2:	bd38      	pop	{r3, r4, r5, pc}
	...

002016e0 <Vector14C>:
OSAL_IRQ_HANDLER(STM32_OTG1_HANDLER) {
  2016e0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  stm32_otg_t *otgp = usbp->otg;
  2016e4:	4e93      	ldr	r6, [pc, #588]	; (201934 <Vector14C+0x254>)
  2016e6:	6ef5      	ldr	r5, [r6, #108]	; 0x6c
  sts  = otgp->GINTSTS;
  2016e8:	696f      	ldr	r7, [r5, #20]
  sts &= otgp->GINTMSK;
  2016ea:	69ab      	ldr	r3, [r5, #24]
  2016ec:	401f      	ands	r7, r3
  if (sts & GINTSTS_USBRST) {
  2016ee:	f417 5a80 	ands.w	sl, r7, #4096	; 0x1000
  otgp->GINTSTS = sts;
  2016f2:	616f      	str	r7, [r5, #20]
  if (sts & GINTSTS_USBRST) {
  2016f4:	f040 8120 	bne.w	201938 <Vector14C+0x258>
  if (sts & GINTSTS_WKUPINT) {
  2016f8:	2f00      	cmp	r7, #0
  2016fa:	f2c0 80fe 	blt.w	2018fa <Vector14C+0x21a>
  if (sts & GINTSTS_USBSUSP) {
  2016fe:	0539      	lsls	r1, r7, #20
  201700:	f100 80ed 	bmi.w	2018de <Vector14C+0x1fe>
  if (sts & GINTSTS_ENUMDNE) {
  201704:	04ba      	lsls	r2, r7, #18
  201706:	d50c      	bpl.n	201722 <Vector14C+0x42>
    if ((otgp->DSTS & DSTS_ENUMSPD_MASK) == DSTS_ENUMSPD_HS_480) {
  201708:	f8d5 3808 	ldr.w	r3, [r5, #2056]	; 0x808
  20170c:	f013 0f06 	tst.w	r3, #6
      otgp->GUSBCFG = (otgp->GUSBCFG & ~(GUSBCFG_TRDT_MASK)) |
  201710:	68eb      	ldr	r3, [r5, #12]
  201712:	f423 5370 	bic.w	r3, r3, #15360	; 0x3c00
  201716:	bf0c      	ite	eq
  201718:	f443 5310 	orreq.w	r3, r3, #9216	; 0x2400
      otgp->GUSBCFG = (otgp->GUSBCFG & ~(GUSBCFG_TRDT_MASK)) |
  20171c:	f443 53a0 	orrne.w	r3, r3, #5120	; 0x1400
  201720:	60eb      	str	r3, [r5, #12]
  if (sts & GINTSTS_SOF) {
  201722:	073b      	lsls	r3, r7, #28
  201724:	d434      	bmi.n	201790 <Vector14C+0xb0>
  if (sts & GINTSTS_IISOIXFR) {
  201726:	02fc      	lsls	r4, r7, #11
  201728:	d43a      	bmi.n	2017a0 <Vector14C+0xc0>
  if (sts & GINTSTS_IISOOXFR) {
  20172a:	02b8      	lsls	r0, r7, #10
  20172c:	f100 80a9 	bmi.w	201882 <Vector14C+0x1a2>
  if ((sts & GINTSTS_RXFLVL) != 0U) {
  201730:	06fb      	lsls	r3, r7, #27
  201732:	d479      	bmi.n	201828 <Vector14C+0x148>
  if (sts & GINTSTS_OEPINT) {
  201734:	033b      	lsls	r3, r7, #12
  src = otgp->DAINT;
  201736:	f8d5 4818 	ldr.w	r4, [r5, #2072]	; 0x818
  if (sts & GINTSTS_OEPINT) {
  20173a:	d511      	bpl.n	201760 <Vector14C+0x80>
    if (src & (1 << 16))
  20173c:	03e6      	lsls	r6, r4, #15
  20173e:	f100 81ca 	bmi.w	201ad6 <Vector14C+0x3f6>
    if (src & (1 << 17))
  201742:	03a5      	lsls	r5, r4, #14
  201744:	f100 81c3 	bmi.w	201ace <Vector14C+0x3ee>
    if (src & (1 << 18))
  201748:	0360      	lsls	r0, r4, #13
  20174a:	f100 81bc 	bmi.w	201ac6 <Vector14C+0x3e6>
    if (src & (1 << 19))
  20174e:	0321      	lsls	r1, r4, #12
  201750:	f100 81b5 	bmi.w	201abe <Vector14C+0x3de>
    if (src & (1 << 20))
  201754:	02e2      	lsls	r2, r4, #11
  201756:	f100 81ae 	bmi.w	201ab6 <Vector14C+0x3d6>
    if (src & (1 << 21))
  20175a:	02a3      	lsls	r3, r4, #10
  20175c:	f100 8166 	bmi.w	201a2c <Vector14C+0x34c>
  if (sts & GINTSTS_IEPINT) {
  201760:	037f      	lsls	r7, r7, #13
  201762:	d511      	bpl.n	201788 <Vector14C+0xa8>
    if (src & (1 << 0))
  201764:	07e6      	lsls	r6, r4, #31
  201766:	f100 81a2 	bmi.w	201aae <Vector14C+0x3ce>
    if (src & (1 << 1))
  20176a:	07a5      	lsls	r5, r4, #30
  20176c:	f100 819b 	bmi.w	201aa6 <Vector14C+0x3c6>
    if (src & (1 << 2))
  201770:	0760      	lsls	r0, r4, #29
  201772:	f100 8194 	bmi.w	201a9e <Vector14C+0x3be>
    if (src & (1 << 3))
  201776:	0721      	lsls	r1, r4, #28
  201778:	f100 8187 	bmi.w	201a8a <Vector14C+0x3aa>
    if (src & (1 << 4))
  20177c:	06e2      	lsls	r2, r4, #27
  20177e:	f100 818a 	bmi.w	201a96 <Vector14C+0x3b6>
    if (src & (1 << 5))
  201782:	06a3      	lsls	r3, r4, #26
  201784:	f100 814b 	bmi.w	201a1e <Vector14C+0x33e>
}
  201788:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  OSAL_IRQ_EPILOGUE();
  20178c:	f7ff bc50 	b.w	201030 <_port_irq_epilogue>
    _usb_isr_invoke_sof_cb(usbp);
  201790:	6873      	ldr	r3, [r6, #4]
  201792:	68db      	ldr	r3, [r3, #12]
  201794:	2b00      	cmp	r3, #0
  201796:	d0c6      	beq.n	201726 <Vector14C+0x46>
  201798:	4866      	ldr	r0, [pc, #408]	; (201934 <Vector14C+0x254>)
  20179a:	4798      	blx	r3
  if (sts & GINTSTS_IISOIXFR) {
  20179c:	02fc      	lsls	r4, r7, #11
  20179e:	d5c4      	bpl.n	20172a <Vector14C+0x4a>
  stm32_otg_t *otgp = usbp->otg;
  2017a0:	f8d6 b06c 	ldr.w	fp, [r6, #108]	; 0x6c
  2017a4:	2400      	movs	r4, #0
      _usb_isr_invoke_in_cb(usbp, ep);
  2017a6:	f04f 0801 	mov.w	r8, #1
  2017aa:	f8df 9188 	ldr.w	r9, [pc, #392]	; 201934 <Vector14C+0x254>
  2017ae:	e006      	b.n	2017be <Vector14C+0xde>
  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
  2017b0:	3401      	adds	r4, #1
  2017b2:	6f33      	ldr	r3, [r6, #112]	; 0x70
  2017b4:	b2e4      	uxtb	r4, r4
  2017b6:	689b      	ldr	r3, [r3, #8]
  2017b8:	429c      	cmp	r4, r3
  2017ba:	46a2      	mov	sl, r4
  2017bc:	d8b5      	bhi.n	20172a <Vector14C+0x4a>
  2017be:	eb0b 1244 	add.w	r2, fp, r4, lsl #5
    if (((otgp->ie[ep].DIEPCTL & DIEPCTL_EPTYP_MASK) == DIEPCTL_EPTYP_ISO) &&
  2017c2:	f8d2 3900 	ldr.w	r3, [r2, #2304]	; 0x900
  2017c6:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
  2017ca:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
  2017ce:	d1ef      	bne.n	2017b0 <Vector14C+0xd0>
        ((otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA) != 0)) {
  2017d0:	f8d2 3900 	ldr.w	r3, [r2, #2304]	; 0x900
    if (((otgp->ie[ep].DIEPCTL & DIEPCTL_EPTYP_MASK) == DIEPCTL_EPTYP_ISO) &&
  2017d4:	2b00      	cmp	r3, #0
  2017d6:	daeb      	bge.n	2017b0 <Vector14C+0xd0>
      otgp->ie[ep].DIEPCTL |= (DIEPCTL_EPDIS | DIEPCTL_SNAK);
  2017d8:	f8d2 3900 	ldr.w	r3, [r2, #2304]	; 0x900
  2017dc:	f043 4390 	orr.w	r3, r3, #1207959552	; 0x48000000
  2017e0:	f8c2 3900 	str.w	r3, [r2, #2304]	; 0x900
      while (otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA)
  2017e4:	f8d2 3900 	ldr.w	r3, [r2, #2304]	; 0x900
  2017e8:	2b00      	cmp	r3, #0
  2017ea:	dbfb      	blt.n	2017e4 <Vector14C+0x104>
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
  2017ec:	ea4f 1a8a 	mov.w	sl, sl, lsl #6
  2017f0:	6ef2      	ldr	r2, [r6, #108]	; 0x6c
  2017f2:	f04a 0320 	orr.w	r3, sl, #32
  2017f6:	6113      	str	r3, [r2, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
  2017f8:	6913      	ldr	r3, [r2, #16]
  2017fa:	0699      	lsls	r1, r3, #26
  2017fc:	d4fc      	bmi.n	2017f8 <Vector14C+0x118>
  2017fe:	2012      	movs	r0, #18
  201800:	f7ff fdc6 	bl	201390 <chSysPolledDelayX>
      _usb_isr_invoke_in_cb(usbp, ep);
  201804:	8932      	ldrh	r2, [r6, #8]
  201806:	eb06 0184 	add.w	r1, r6, r4, lsl #2
  20180a:	fa08 f304 	lsl.w	r3, r8, r4
  20180e:	68c9      	ldr	r1, [r1, #12]
  201810:	ea22 0303 	bic.w	r3, r2, r3
  201814:	688a      	ldr	r2, [r1, #8]
  201816:	8133      	strh	r3, [r6, #8]
  201818:	b112      	cbz	r2, 201820 <Vector14C+0x140>
  20181a:	4621      	mov	r1, r4
  20181c:	4648      	mov	r0, r9
  20181e:	4790      	blx	r2
    otg_txfifo_handler(usbp, ep);
  201820:	4620      	mov	r0, r4
  201822:	f002 f8cd 	bl	2039c0 <otg_txfifo_handler.constprop.7>
  201826:	e7c3      	b.n	2017b0 <Vector14C+0xd0>
  sts = usbp->otg->GRXSTSP;
  201828:	f8d6 e06c 	ldr.w	lr, [r6, #108]	; 0x6c
  20182c:	f8de 3020 	ldr.w	r3, [lr, #32]
  switch (sts & GRXSTSP_PKTSTS_MASK) {
  201830:	f403 11f0 	and.w	r1, r3, #1966080	; 0x1e0000
  cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
  201834:	f3c3 120a 	ubfx	r2, r3, #4, #11
  ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
  201838:	f003 030f 	and.w	r3, r3, #15
  switch (sts & GRXSTSP_PKTSTS_MASK) {
  20183c:	f5b1 2f80 	cmp.w	r1, #262144	; 0x40000
  201840:	f000 80fb 	beq.w	201a3a <Vector14C+0x35a>
  201844:	f5b1 2f40 	cmp.w	r1, #786432	; 0xc0000
  201848:	f47f af74 	bne.w	201734 <Vector14C+0x54>
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0], usbp->epc[ep]->setup_buf,
  20184c:	eb06 0383 	add.w	r3, r6, r3, lsl #2
  201850:	68db      	ldr	r3, [r3, #12]
  201852:	6a18      	ldr	r0, [r3, #32]
  while (i < n) {
  201854:	2a00      	cmp	r2, #0
  201856:	f43f af6d 	beq.w	201734 <Vector14C+0x54>
  20185a:	2100      	movs	r1, #0
      w = *fifop;
  20185c:	f50e 5e80 	add.w	lr, lr, #4096	; 0x1000
  while (i < n) {
  201860:	460b      	mov	r3, r1
  201862:	e002      	b.n	20186a <Vector14C+0x18a>
  201864:	429a      	cmp	r2, r3
  201866:	f43f af65 	beq.w	201734 <Vector14C+0x54>
    if ((i & 3) == 0){
  20186a:	079e      	lsls	r6, r3, #30
  20186c:	d101      	bne.n	201872 <Vector14C+0x192>
      w = *fifop;
  20186e:	f8de 1000 	ldr.w	r1, [lr]
    if (i < max) {
  201872:	2b07      	cmp	r3, #7
    i++;
  201874:	f103 0301 	add.w	r3, r3, #1
    if (i < max) {
  201878:	d8f4      	bhi.n	201864 <Vector14C+0x184>
      *buf++ = (uint8_t)w;
  20187a:	7001      	strb	r1, [r0, #0]
      w >>= 8;
  20187c:	0a09      	lsrs	r1, r1, #8
      *buf++ = (uint8_t)w;
  20187e:	3001      	adds	r0, #1
  201880:	e7f0      	b.n	201864 <Vector14C+0x184>
  stm32_otg_t *otgp = usbp->otg;
  201882:	f8d6 806c 	ldr.w	r8, [r6, #108]	; 0x6c
  201886:	2400      	movs	r4, #0
      _usb_isr_invoke_out_cb(usbp, ep);
  201888:	f04f 0a01 	mov.w	sl, #1
  20188c:	f8df 90a4 	ldr.w	r9, [pc, #164]	; 201934 <Vector14C+0x254>
  201890:	e006      	b.n	2018a0 <Vector14C+0x1c0>
  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
  201892:	3401      	adds	r4, #1
  201894:	6f33      	ldr	r3, [r6, #112]	; 0x70
  201896:	b2e4      	uxtb	r4, r4
  201898:	689b      	ldr	r3, [r3, #8]
  20189a:	429c      	cmp	r4, r3
  20189c:	f63f af48 	bhi.w	201730 <Vector14C+0x50>
  2018a0:	eb08 1244 	add.w	r2, r8, r4, lsl #5
    if (((otgp->oe[ep].DOEPCTL & DOEPCTL_EPTYP_MASK) == DOEPCTL_EPTYP_ISO) &&
  2018a4:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	; 0xb00
  2018a8:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
  2018ac:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
  2018b0:	d1ef      	bne.n	201892 <Vector14C+0x1b2>
        ((otgp->oe[ep].DOEPCTL & DOEPCTL_EPENA) != 0)) {
  2018b2:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	; 0xb00
    if (((otgp->oe[ep].DOEPCTL & DOEPCTL_EPTYP_MASK) == DOEPCTL_EPTYP_ISO) &&
  2018b6:	2b00      	cmp	r3, #0
  2018b8:	daeb      	bge.n	201892 <Vector14C+0x1b2>
      _usb_isr_invoke_out_cb(usbp, ep);
  2018ba:	eb06 0084 	add.w	r0, r6, r4, lsl #2
  2018be:	8972      	ldrh	r2, [r6, #10]
  2018c0:	fa0a f304 	lsl.w	r3, sl, r4
  2018c4:	4621      	mov	r1, r4
  2018c6:	f8d0 e00c 	ldr.w	lr, [r0, #12]
  2018ca:	4648      	mov	r0, r9
  2018cc:	ea22 0303 	bic.w	r3, r2, r3
  2018d0:	f8de 200c 	ldr.w	r2, [lr, #12]
  2018d4:	8173      	strh	r3, [r6, #10]
  2018d6:	2a00      	cmp	r2, #0
  2018d8:	d0db      	beq.n	201892 <Vector14C+0x1b2>
  2018da:	4790      	blx	r2
  2018dc:	e7d9      	b.n	201892 <Vector14C+0x1b2>
  usbp->saved_state = usbp->state;
  2018de:	7831      	ldrb	r1, [r6, #0]
  usbp->state       = USB_SUSPENDED;
  2018e0:	2205      	movs	r2, #5
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
  2018e2:	6873      	ldr	r3, [r6, #4]
  usbp->saved_state = usbp->state;
  2018e4:	f886 1068 	strb.w	r1, [r6, #104]	; 0x68
  usbp->state       = USB_SUSPENDED;
  2018e8:	7032      	strb	r2, [r6, #0]
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
  2018ea:	681b      	ldr	r3, [r3, #0]
  2018ec:	2b00      	cmp	r3, #0
  2018ee:	f43f af09 	beq.w	201704 <Vector14C+0x24>
  2018f2:	2104      	movs	r1, #4
  2018f4:	480f      	ldr	r0, [pc, #60]	; (201934 <Vector14C+0x254>)
  2018f6:	4798      	blx	r3
  2018f8:	e704      	b.n	201704 <Vector14C+0x24>
    if (otgp->PCGCCTL & (PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK)) {
  2018fa:	f8d5 3e00 	ldr.w	r3, [r5, #3584]	; 0xe00
  2018fe:	0798      	lsls	r0, r3, #30
  201900:	d005      	beq.n	20190e <Vector14C+0x22e>
      otgp->PCGCCTL &= ~(PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK);
  201902:	f8d5 3e00 	ldr.w	r3, [r5, #3584]	; 0xe00
  201906:	f023 0303 	bic.w	r3, r3, #3
  20190a:	f8c5 3e00 	str.w	r3, [r5, #3584]	; 0xe00
    otgp->DCTL &= ~DCTL_RWUSIG;
  20190e:	f8d5 3804 	ldr.w	r3, [r5, #2052]	; 0x804
  usbp->state = usbp->saved_state;
  201912:	f896 1068 	ldrb.w	r1, [r6, #104]	; 0x68
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
  201916:	6872      	ldr	r2, [r6, #4]
  201918:	f023 0301 	bic.w	r3, r3, #1
  usbp->state = usbp->saved_state;
  20191c:	7031      	strb	r1, [r6, #0]
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
  20191e:	6812      	ldr	r2, [r2, #0]
  201920:	f8c5 3804 	str.w	r3, [r5, #2052]	; 0x804
  201924:	2a00      	cmp	r2, #0
  201926:	f43f aeea 	beq.w	2016fe <Vector14C+0x1e>
  20192a:	2105      	movs	r1, #5
  20192c:	4801      	ldr	r0, [pc, #4]	; (201934 <Vector14C+0x254>)
  20192e:	4790      	blx	r2
  201930:	e6e5      	b.n	2016fe <Vector14C+0x1e>
  201932:	bf00      	nop
  201934:	20001228 	.word	0x20001228
  usbp->status        = 0;
  201938:	2300      	movs	r3, #0
  usbp->state         = USB_READY;
  20193a:	2102      	movs	r1, #2
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
  20193c:	2220      	movs	r2, #32
  usbp->status        = 0;
  20193e:	f8a6 3064 	strh.w	r3, [r6, #100]	; 0x64
  usbp->address       = 0;
  201942:	f886 3066 	strb.w	r3, [r6, #102]	; 0x66
  usbp->configuration = 0;
  201946:	f886 3067 	strb.w	r3, [r6, #103]	; 0x67
    usbp->epc[i] = NULL;
  20194a:	60f3      	str	r3, [r6, #12]
  20194c:	6133      	str	r3, [r6, #16]
  20194e:	6173      	str	r3, [r6, #20]
  201950:	61b3      	str	r3, [r6, #24]
  201952:	61f3      	str	r3, [r6, #28]
  201954:	6233      	str	r3, [r6, #32]
  usbp->ep0state = USB_EP0_STP_WAITING;
  201956:	f886 304c 	strb.w	r3, [r6, #76]	; 0x4c
  usbp->transmitting  = 0;
  20195a:	8133      	strh	r3, [r6, #8]
  usbp->receiving     = 0;
  20195c:	8173      	strh	r3, [r6, #10]
  usbp->state         = USB_READY;
  20195e:	7031      	strb	r1, [r6, #0]
  201960:	612a      	str	r2, [r5, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
  201962:	692c      	ldr	r4, [r5, #16]
  201964:	f014 0420 	ands.w	r4, r4, #32
  201968:	d1fb      	bne.n	201962 <Vector14C+0x282>
  20196a:	2012      	movs	r0, #18
  20196c:	f7ff fd10 	bl	201390 <chSysPolledDelayX>
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
  201970:	6f37      	ldr	r7, [r6, #112]	; 0x70
  otgp->DAINTMSK   = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
  201972:	f04f 1301 	mov.w	r3, #65537	; 0x10001
    otgp->ie[i].DIEPCTL = DIEPCTL_SNAK;
  201976:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
  20197a:	f04f 32ff 	mov.w	r2, #4294967295
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
  20197e:	68b8      	ldr	r0, [r7, #8]
  otgp->DIEPEMPMSK = 0;
  201980:	f8c5 4834 	str.w	r4, [r5, #2100]	; 0x834
  otgp->DAINTMSK   = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
  201984:	f8c5 381c 	str.w	r3, [r5, #2076]	; 0x81c
  201988:	eb05 1344 	add.w	r3, r5, r4, lsl #5
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
  20198c:	3401      	adds	r4, #1
  20198e:	4284      	cmp	r4, r0
    otgp->ie[i].DIEPCTL = DIEPCTL_SNAK;
  201990:	f8c3 1900 	str.w	r1, [r3, #2304]	; 0x900
    otgp->oe[i].DOEPCTL = DOEPCTL_SNAK;
  201994:	f8c3 1b00 	str.w	r1, [r3, #2816]	; 0xb00
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
  201998:	f8c3 2908 	str.w	r2, [r3, #2312]	; 0x908
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
  20199c:	f8c3 2b08 	str.w	r2, [r3, #2824]	; 0xb08
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
  2019a0:	d9f2      	bls.n	201988 <Vector14C+0x2a8>
  usbp->pmnext = usbp->otgparams->rx_fifo_size;
  2019a2:	6839      	ldr	r1, [r7, #0]
  otgp->GRSTCTL = GRSTCTL_RXFFLSH;
  2019a4:	2210      	movs	r2, #16
  2019a6:	6ef3      	ldr	r3, [r6, #108]	; 0x6c
  usbp->pmnext = usbp->otgparams->rx_fifo_size;
  2019a8:	6771      	str	r1, [r6, #116]	; 0x74
  otgp->GRXFSIZ = usbp->otgparams->rx_fifo_size;
  2019aa:	6839      	ldr	r1, [r7, #0]
  2019ac:	6269      	str	r1, [r5, #36]	; 0x24
  otgp->GRSTCTL = GRSTCTL_RXFFLSH;
  2019ae:	611a      	str	r2, [r3, #16]
  while ((otgp->GRSTCTL & GRSTCTL_RXFFLSH) != 0)
  2019b0:	691c      	ldr	r4, [r3, #16]
  2019b2:	f014 0410 	ands.w	r4, r4, #16
  2019b6:	d1fb      	bne.n	2019b0 <Vector14C+0x2d0>
  2019b8:	2012      	movs	r0, #18
  2019ba:	f7ff fce9 	bl	201390 <chSysPolledDelayX>
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);
  2019be:	f8d5 1800 	ldr.w	r1, [r5, #2048]	; 0x800
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
  2019c2:	4a47      	ldr	r2, [pc, #284]	; (201ae0 <Vector14C+0x400>)
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
  2019c4:	2009      	movs	r0, #9
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);
  2019c6:	f421 61fe 	bic.w	r1, r1, #2032	; 0x7f0
  next = usbp->pmnext;
  2019ca:	6f73      	ldr	r3, [r6, #116]	; 0x74
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
  2019cc:	6877      	ldr	r7, [r6, #4]
  otgp->oe[0].DOEPTSIZ = DOEPTSIZ_STUPCNT(3);
  2019ce:	f04f 4ec0 	mov.w	lr, #1610612736	; 0x60000000
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);
  2019d2:	f8c5 1800 	str.w	r1, [r5, #2048]	; 0x800
  usbp->pmnext += size;
  2019d6:	f103 0c10 	add.w	ip, r3, #16
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
  2019da:	69a9      	ldr	r1, [r5, #24]
  otgp->DIEPTXF0 = DIEPTXF_INEPTXFD(ep0config.in_maxsize / 4) |
  2019dc:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
  2019e0:	683f      	ldr	r7, [r7, #0]
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
  2019e2:	430a      	orrs	r2, r1
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
  2019e4:	493f      	ldr	r1, [pc, #252]	; (201ae4 <Vector14C+0x404>)
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
  2019e6:	61aa      	str	r2, [r5, #24]
  usbp->epc[0] = &ep0config;
  2019e8:	4a3f      	ldr	r2, [pc, #252]	; (201ae8 <Vector14C+0x408>)
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
  2019ea:	f8c5 0810 	str.w	r0, [r5, #2064]	; 0x810
  usbp->pmnext += size;
  2019ee:	f8c6 c074 	str.w	ip, [r6, #116]	; 0x74
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;
  2019f2:	f8c5 0814 	str.w	r0, [r5, #2068]	; 0x814
  usbp->epc[0] = &ep0config;
  2019f6:	60f2      	str	r2, [r6, #12]
  otgp->oe[0].DOEPTSIZ = DOEPTSIZ_STUPCNT(3);
  2019f8:	f8c5 eb10 	str.w	lr, [r5, #2832]	; 0xb10
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
  2019fc:	f8c5 1b00 	str.w	r1, [r5, #2816]	; 0xb00
  otgp->ie[0].DIEPTSIZ = 0;
  201a00:	f8c5 4910 	str.w	r4, [r5, #2320]	; 0x910
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
  201a04:	f8c5 1900 	str.w	r1, [r5, #2304]	; 0x900
  otgp->DIEPTXF0 = DIEPTXF_INEPTXFD(ep0config.in_maxsize / 4) |
  201a08:	62ab      	str	r3, [r5, #40]	; 0x28
  201a0a:	2f00      	cmp	r7, #0
  201a0c:	f43f aebc 	beq.w	201788 <Vector14C+0xa8>
  201a10:	4621      	mov	r1, r4
  201a12:	4836      	ldr	r0, [pc, #216]	; (201aec <Vector14C+0x40c>)
  201a14:	47b8      	blx	r7
}
  201a16:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  OSAL_IRQ_EPILOGUE();
  201a1a:	f7ff bb09 	b.w	201030 <_port_irq_epilogue>
      otg_epin_handler(usbp, 5);
  201a1e:	2005      	movs	r0, #5
  201a20:	f002 f876 	bl	203b10 <otg_epin_handler.constprop.3>
}
  201a24:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  OSAL_IRQ_EPILOGUE();
  201a28:	f7ff bb02 	b.w	201030 <_port_irq_epilogue>
      otg_epout_handler(usbp, 5);
  201a2c:	2005      	movs	r0, #5
  201a2e:	f002 f81f 	bl	203a70 <otg_epout_handler.constprop.4>
  if (sts & GINTSTS_IEPINT) {
  201a32:	037f      	lsls	r7, r7, #13
  201a34:	f57f aea8 	bpl.w	201788 <Vector14C+0xa8>
  201a38:	e694      	b.n	201764 <Vector14C+0x84>
                            usbp->epc[ep]->out_state->rxbuf,
  201a3a:	f103 0802 	add.w	r8, r3, #2
  201a3e:	eb06 0388 	add.w	r3, r6, r8, lsl #2
  201a42:	685b      	ldr	r3, [r3, #4]
  201a44:	6999      	ldr	r1, [r3, #24]
                            usbp->epc[ep]->out_state->rxcnt);
  201a46:	684b      	ldr	r3, [r1, #4]
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
  201a48:	680c      	ldr	r4, [r1, #0]
  201a4a:	6888      	ldr	r0, [r1, #8]
  201a4c:	eba4 0c03 	sub.w	ip, r4, r3
  while (i < n) {
  201a50:	b1b2      	cbz	r2, 201a80 <Vector14C+0x3a0>
  201a52:	2100      	movs	r1, #0
      w = *fifop;
  201a54:	f50e 5e80 	add.w	lr, lr, #4096	; 0x1000
  while (i < n) {
  201a58:	460b      	mov	r3, r1
    if ((i & 3) == 0){
  201a5a:	079c      	lsls	r4, r3, #30
  201a5c:	d101      	bne.n	201a62 <Vector14C+0x382>
      w = *fifop;
  201a5e:	f8de 1000 	ldr.w	r1, [lr]
    if (i < max) {
  201a62:	459c      	cmp	ip, r3
    i++;
  201a64:	f103 0301 	add.w	r3, r3, #1
    if (i < max) {
  201a68:	d902      	bls.n	201a70 <Vector14C+0x390>
      *buf++ = (uint8_t)w;
  201a6a:	7001      	strb	r1, [r0, #0]
      w >>= 8;
  201a6c:	0a09      	lsrs	r1, r1, #8
      *buf++ = (uint8_t)w;
  201a6e:	3001      	adds	r0, #1
  while (i < n) {
  201a70:	429a      	cmp	r2, r3
  201a72:	d1f2      	bne.n	201a5a <Vector14C+0x37a>
  201a74:	eb06 0688 	add.w	r6, r6, r8, lsl #2
  201a78:	6873      	ldr	r3, [r6, #4]
  201a7a:	6999      	ldr	r1, [r3, #24]
  201a7c:	6888      	ldr	r0, [r1, #8]
  201a7e:	684b      	ldr	r3, [r1, #4]
    usbp->epc[ep]->out_state->rxbuf += cnt;
  201a80:	4410      	add	r0, r2
    usbp->epc[ep]->out_state->rxcnt += cnt;
  201a82:	441a      	add	r2, r3
    usbp->epc[ep]->out_state->rxbuf += cnt;
  201a84:	6088      	str	r0, [r1, #8]
    usbp->epc[ep]->out_state->rxcnt += cnt;
  201a86:	604a      	str	r2, [r1, #4]
  201a88:	e654      	b.n	201734 <Vector14C+0x54>
      otg_epin_handler(usbp, 3);
  201a8a:	2003      	movs	r0, #3
  201a8c:	f002 f840 	bl	203b10 <otg_epin_handler.constprop.3>
    if (src & (1 << 4))
  201a90:	06e2      	lsls	r2, r4, #27
  201a92:	f57f ae76 	bpl.w	201782 <Vector14C+0xa2>
      otg_epin_handler(usbp, 4);
  201a96:	2004      	movs	r0, #4
  201a98:	f002 f83a 	bl	203b10 <otg_epin_handler.constprop.3>
  201a9c:	e671      	b.n	201782 <Vector14C+0xa2>
      otg_epin_handler(usbp, 2);
  201a9e:	2002      	movs	r0, #2
  201aa0:	f002 f836 	bl	203b10 <otg_epin_handler.constprop.3>
  201aa4:	e667      	b.n	201776 <Vector14C+0x96>
      otg_epin_handler(usbp, 1);
  201aa6:	2001      	movs	r0, #1
  201aa8:	f002 f832 	bl	203b10 <otg_epin_handler.constprop.3>
  201aac:	e660      	b.n	201770 <Vector14C+0x90>
      otg_epin_handler(usbp, 0);
  201aae:	2000      	movs	r0, #0
  201ab0:	f002 f82e 	bl	203b10 <otg_epin_handler.constprop.3>
  201ab4:	e659      	b.n	20176a <Vector14C+0x8a>
      otg_epout_handler(usbp, 4);
  201ab6:	2004      	movs	r0, #4
  201ab8:	f001 ffda 	bl	203a70 <otg_epout_handler.constprop.4>
  201abc:	e64d      	b.n	20175a <Vector14C+0x7a>
      otg_epout_handler(usbp, 3);
  201abe:	2003      	movs	r0, #3
  201ac0:	f001 ffd6 	bl	203a70 <otg_epout_handler.constprop.4>
  201ac4:	e646      	b.n	201754 <Vector14C+0x74>
      otg_epout_handler(usbp, 2);
  201ac6:	2002      	movs	r0, #2
  201ac8:	f001 ffd2 	bl	203a70 <otg_epout_handler.constprop.4>
  201acc:	e63f      	b.n	20174e <Vector14C+0x6e>
      otg_epout_handler(usbp, 1);
  201ace:	2001      	movs	r0, #1
  201ad0:	f001 ffce 	bl	203a70 <otg_epout_handler.constprop.4>
  201ad4:	e638      	b.n	201748 <Vector14C+0x68>
      otg_epout_handler(usbp, 0);
  201ad6:	2000      	movs	r0, #0
  201ad8:	f001 ffca 	bl	203a70 <otg_epout_handler.constprop.4>
  201adc:	e631      	b.n	201742 <Vector14C+0x62>
  201ade:	bf00      	nop
  201ae0:	000c0010 	.word	0x000c0010
  201ae4:	10008040 	.word	0x10008040
  201ae8:	08003c3c 	.word	0x08003c3c
  201aec:	20001228 	.word	0x20001228

00201af0 <Vector158>:
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
  201af0:	4b08      	ldr	r3, [pc, #32]	; (201b14 <Vector158+0x24>)
  DMA2->HIFCR = flags << 22U;
  if (dma_isr_redir[15].dma_func)
  201af2:	4809      	ldr	r0, [pc, #36]	; (201b18 <Vector158+0x28>)
  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
  201af4:	6859      	ldr	r1, [r3, #4]
  if (dma_isr_redir[15].dma_func)
  201af6:	6f82      	ldr	r2, [r0, #120]	; 0x78
  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
  201af8:	0d89      	lsrs	r1, r1, #22
  201afa:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
  201afe:	b510      	push	{r4, lr}
  DMA2->HIFCR = flags << 22U;
  201b00:	058c      	lsls	r4, r1, #22
  201b02:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[15].dma_func)
  201b04:	b10a      	cbz	r2, 201b0a <Vector158+0x1a>
    dma_isr_redir[15].dma_func(dma_isr_redir[15].dma_param, flags);
  201b06:	6fc0      	ldr	r0, [r0, #124]	; 0x7c
  201b08:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
  201b0a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
  201b0e:	f7ff ba8f 	b.w	201030 <_port_irq_epilogue>
  201b12:	bf00      	nop
  201b14:	40026400 	.word	0x40026400
  201b18:	20000f8c 	.word	0x20000f8c
  201b1c:	00000000 	.word	0x00000000

00201b20 <Vector154>:
  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
  201b20:	4b08      	ldr	r3, [pc, #32]	; (201b44 <Vector154+0x24>)
  if (dma_isr_redir[14].dma_func)
  201b22:	4809      	ldr	r0, [pc, #36]	; (201b48 <Vector154+0x28>)
  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
  201b24:	6859      	ldr	r1, [r3, #4]
  if (dma_isr_redir[14].dma_func)
  201b26:	6f02      	ldr	r2, [r0, #112]	; 0x70
  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
  201b28:	0c09      	lsrs	r1, r1, #16
  201b2a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
  201b2e:	b510      	push	{r4, lr}
  DMA2->HIFCR = flags << 16U;
  201b30:	040c      	lsls	r4, r1, #16
  201b32:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[14].dma_func)
  201b34:	b10a      	cbz	r2, 201b3a <Vector154+0x1a>
    dma_isr_redir[14].dma_func(dma_isr_redir[14].dma_param, flags);
  201b36:	6f40      	ldr	r0, [r0, #116]	; 0x74
  201b38:	4790      	blx	r2
}
  201b3a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
  201b3e:	f7ff ba77 	b.w	201030 <_port_irq_epilogue>
  201b42:	bf00      	nop
  201b44:	40026400 	.word	0x40026400
  201b48:	20000f8c 	.word	0x20000f8c
  201b4c:	00000000 	.word	0x00000000

00201b50 <Vector150>:
  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
  201b50:	4b08      	ldr	r3, [pc, #32]	; (201b74 <Vector150+0x24>)
  if (dma_isr_redir[13].dma_func)
  201b52:	4809      	ldr	r0, [pc, #36]	; (201b78 <Vector150+0x28>)
  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
  201b54:	6859      	ldr	r1, [r3, #4]
  if (dma_isr_redir[13].dma_func)
  201b56:	6e82      	ldr	r2, [r0, #104]	; 0x68
  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
  201b58:	0989      	lsrs	r1, r1, #6
  201b5a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
  201b5e:	b510      	push	{r4, lr}
  DMA2->HIFCR = flags << 6U;
  201b60:	018c      	lsls	r4, r1, #6
  201b62:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[13].dma_func)
  201b64:	b10a      	cbz	r2, 201b6a <Vector150+0x1a>
    dma_isr_redir[13].dma_func(dma_isr_redir[13].dma_param, flags);
  201b66:	6ec0      	ldr	r0, [r0, #108]	; 0x6c
  201b68:	4790      	blx	r2
}
  201b6a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
  201b6e:	f7ff ba5f 	b.w	201030 <_port_irq_epilogue>
  201b72:	bf00      	nop
  201b74:	40026400 	.word	0x40026400
  201b78:	20000f8c 	.word	0x20000f8c
  201b7c:	00000000 	.word	0x00000000

00201b80 <Vector130>:
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
  201b80:	b508      	push	{r3, lr}
  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
  201b82:	4b07      	ldr	r3, [pc, #28]	; (201ba0 <Vector130+0x20>)
  if (dma_isr_redir[12].dma_func)
  201b84:	4807      	ldr	r0, [pc, #28]	; (201ba4 <Vector130+0x24>)
  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
  201b86:	6859      	ldr	r1, [r3, #4]
  if (dma_isr_redir[12].dma_func)
  201b88:	6e02      	ldr	r2, [r0, #96]	; 0x60
  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
  201b8a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 0U;
  201b8e:	60d9      	str	r1, [r3, #12]
  if (dma_isr_redir[12].dma_func)
  201b90:	b10a      	cbz	r2, 201b96 <Vector130+0x16>
    dma_isr_redir[12].dma_func(dma_isr_redir[12].dma_param, flags);
  201b92:	6e40      	ldr	r0, [r0, #100]	; 0x64
  201b94:	4790      	blx	r2
}
  201b96:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
  201b9a:	f7ff ba49 	b.w	201030 <_port_irq_epilogue>
  201b9e:	bf00      	nop
  201ba0:	40026400 	.word	0x40026400
  201ba4:	20000f8c 	.word	0x20000f8c
	...

00201bb0 <Vector12C>:
  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
  201bb0:	4b08      	ldr	r3, [pc, #32]	; (201bd4 <Vector12C+0x24>)
  if (dma_isr_redir[11].dma_func)
  201bb2:	4809      	ldr	r0, [pc, #36]	; (201bd8 <Vector12C+0x28>)
  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
  201bb4:	6819      	ldr	r1, [r3, #0]
  if (dma_isr_redir[11].dma_func)
  201bb6:	6d82      	ldr	r2, [r0, #88]	; 0x58
  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
  201bb8:	0d89      	lsrs	r1, r1, #22
  201bba:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
  201bbe:	b510      	push	{r4, lr}
  DMA2->LIFCR = flags << 22U;
  201bc0:	058c      	lsls	r4, r1, #22
  201bc2:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[11].dma_func)
  201bc4:	b10a      	cbz	r2, 201bca <Vector12C+0x1a>
    dma_isr_redir[11].dma_func(dma_isr_redir[11].dma_param, flags);
  201bc6:	6dc0      	ldr	r0, [r0, #92]	; 0x5c
  201bc8:	4790      	blx	r2
}
  201bca:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
  201bce:	f7ff ba2f 	b.w	201030 <_port_irq_epilogue>
  201bd2:	bf00      	nop
  201bd4:	40026400 	.word	0x40026400
  201bd8:	20000f8c 	.word	0x20000f8c
  201bdc:	00000000 	.word	0x00000000

00201be0 <Vector128>:
  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
  201be0:	4b08      	ldr	r3, [pc, #32]	; (201c04 <Vector128+0x24>)
  if (dma_isr_redir[10].dma_func)
  201be2:	4809      	ldr	r0, [pc, #36]	; (201c08 <Vector128+0x28>)
  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
  201be4:	6819      	ldr	r1, [r3, #0]
  if (dma_isr_redir[10].dma_func)
  201be6:	6d02      	ldr	r2, [r0, #80]	; 0x50
  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
  201be8:	0c09      	lsrs	r1, r1, #16
  201bea:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
  201bee:	b510      	push	{r4, lr}
  DMA2->LIFCR = flags << 16U;
  201bf0:	040c      	lsls	r4, r1, #16
  201bf2:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[10].dma_func)
  201bf4:	b10a      	cbz	r2, 201bfa <Vector128+0x1a>
    dma_isr_redir[10].dma_func(dma_isr_redir[10].dma_param, flags);
  201bf6:	6d40      	ldr	r0, [r0, #84]	; 0x54
  201bf8:	4790      	blx	r2
}
  201bfa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
  201bfe:	f7ff ba17 	b.w	201030 <_port_irq_epilogue>
  201c02:	bf00      	nop
  201c04:	40026400 	.word	0x40026400
  201c08:	20000f8c 	.word	0x20000f8c
  201c0c:	00000000 	.word	0x00000000

00201c10 <Vector124>:
  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
  201c10:	4b08      	ldr	r3, [pc, #32]	; (201c34 <Vector124+0x24>)
  if (dma_isr_redir[9].dma_func)
  201c12:	4809      	ldr	r0, [pc, #36]	; (201c38 <Vector124+0x28>)
  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
  201c14:	6819      	ldr	r1, [r3, #0]
  if (dma_isr_redir[9].dma_func)
  201c16:	6c82      	ldr	r2, [r0, #72]	; 0x48
  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
  201c18:	0989      	lsrs	r1, r1, #6
  201c1a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
  201c1e:	b510      	push	{r4, lr}
  DMA2->LIFCR = flags << 6U;
  201c20:	018c      	lsls	r4, r1, #6
  201c22:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[9].dma_func)
  201c24:	b10a      	cbz	r2, 201c2a <Vector124+0x1a>
    dma_isr_redir[9].dma_func(dma_isr_redir[9].dma_param, flags);
  201c26:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
  201c28:	4790      	blx	r2
}
  201c2a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
  201c2e:	f7ff b9ff 	b.w	201030 <_port_irq_epilogue>
  201c32:	bf00      	nop
  201c34:	40026400 	.word	0x40026400
  201c38:	20000f8c 	.word	0x20000f8c
  201c3c:	00000000 	.word	0x00000000

00201c40 <Vector120>:
OSAL_IRQ_HANDLER(STM32_DMA2_CH0_HANDLER) {
  201c40:	b508      	push	{r3, lr}
  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
  201c42:	4b07      	ldr	r3, [pc, #28]	; (201c60 <Vector120+0x20>)
  if (dma_isr_redir[8].dma_func)
  201c44:	4807      	ldr	r0, [pc, #28]	; (201c64 <Vector120+0x24>)
  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
  201c46:	6819      	ldr	r1, [r3, #0]
  if (dma_isr_redir[8].dma_func)
  201c48:	6c02      	ldr	r2, [r0, #64]	; 0x40
  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
  201c4a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 0U;
  201c4e:	6099      	str	r1, [r3, #8]
  if (dma_isr_redir[8].dma_func)
  201c50:	b10a      	cbz	r2, 201c56 <Vector120+0x16>
    dma_isr_redir[8].dma_func(dma_isr_redir[8].dma_param, flags);
  201c52:	6c40      	ldr	r0, [r0, #68]	; 0x44
  201c54:	4790      	blx	r2
}
  201c56:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
  201c5a:	f7ff b9e9 	b.w	201030 <_port_irq_epilogue>
  201c5e:	bf00      	nop
  201c60:	40026400 	.word	0x40026400
  201c64:	20000f8c 	.word	0x20000f8c
	...

00201c70 <VectorFC>:
  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
  201c70:	4b08      	ldr	r3, [pc, #32]	; (201c94 <VectorFC+0x24>)
  if (dma_isr_redir[7].dma_func)
  201c72:	4809      	ldr	r0, [pc, #36]	; (201c98 <VectorFC+0x28>)
  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
  201c74:	6859      	ldr	r1, [r3, #4]
  if (dma_isr_redir[7].dma_func)
  201c76:	6b82      	ldr	r2, [r0, #56]	; 0x38
  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
  201c78:	0d89      	lsrs	r1, r1, #22
  201c7a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
  201c7e:	b510      	push	{r4, lr}
  DMA1->HIFCR = flags << 22U;
  201c80:	058c      	lsls	r4, r1, #22
  201c82:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[7].dma_func)
  201c84:	b10a      	cbz	r2, 201c8a <VectorFC+0x1a>
    dma_isr_redir[7].dma_func(dma_isr_redir[7].dma_param, flags);
  201c86:	6bc0      	ldr	r0, [r0, #60]	; 0x3c
  201c88:	4790      	blx	r2
}
  201c8a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
  201c8e:	f7ff b9cf 	b.w	201030 <_port_irq_epilogue>
  201c92:	bf00      	nop
  201c94:	40026000 	.word	0x40026000
  201c98:	20000f8c 	.word	0x20000f8c
  201c9c:	00000000 	.word	0x00000000

00201ca0 <Vector84>:
  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
  201ca0:	4b08      	ldr	r3, [pc, #32]	; (201cc4 <Vector84+0x24>)
  if (dma_isr_redir[6].dma_func)
  201ca2:	4809      	ldr	r0, [pc, #36]	; (201cc8 <Vector84+0x28>)
  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
  201ca4:	6859      	ldr	r1, [r3, #4]
  if (dma_isr_redir[6].dma_func)
  201ca6:	6b02      	ldr	r2, [r0, #48]	; 0x30
  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
  201ca8:	0c09      	lsrs	r1, r1, #16
  201caa:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
  201cae:	b510      	push	{r4, lr}
  DMA1->HIFCR = flags << 16U;
  201cb0:	040c      	lsls	r4, r1, #16
  201cb2:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[6].dma_func)
  201cb4:	b10a      	cbz	r2, 201cba <Vector84+0x1a>
    dma_isr_redir[6].dma_func(dma_isr_redir[6].dma_param, flags);
  201cb6:	6b40      	ldr	r0, [r0, #52]	; 0x34
  201cb8:	4790      	blx	r2
}
  201cba:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
  201cbe:	f7ff b9b7 	b.w	201030 <_port_irq_epilogue>
  201cc2:	bf00      	nop
  201cc4:	40026000 	.word	0x40026000
  201cc8:	20000f8c 	.word	0x20000f8c
  201ccc:	00000000 	.word	0x00000000

00201cd0 <Vector80>:
  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
  201cd0:	4b08      	ldr	r3, [pc, #32]	; (201cf4 <Vector80+0x24>)
  if (dma_isr_redir[5].dma_func)
  201cd2:	4809      	ldr	r0, [pc, #36]	; (201cf8 <Vector80+0x28>)
  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
  201cd4:	6859      	ldr	r1, [r3, #4]
  if (dma_isr_redir[5].dma_func)
  201cd6:	6a82      	ldr	r2, [r0, #40]	; 0x28
  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
  201cd8:	0989      	lsrs	r1, r1, #6
  201cda:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
  201cde:	b510      	push	{r4, lr}
  DMA1->HIFCR = flags << 6U;
  201ce0:	018c      	lsls	r4, r1, #6
  201ce2:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[5].dma_func)
  201ce4:	b10a      	cbz	r2, 201cea <Vector80+0x1a>
    dma_isr_redir[5].dma_func(dma_isr_redir[5].dma_param, flags);
  201ce6:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
  201ce8:	4790      	blx	r2
}
  201cea:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
  201cee:	f7ff b99f 	b.w	201030 <_port_irq_epilogue>
  201cf2:	bf00      	nop
  201cf4:	40026000 	.word	0x40026000
  201cf8:	20000f8c 	.word	0x20000f8c
  201cfc:	00000000 	.word	0x00000000

00201d00 <Vector7C>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
  201d00:	b508      	push	{r3, lr}
  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
  201d02:	4b07      	ldr	r3, [pc, #28]	; (201d20 <Vector7C+0x20>)
  if (dma_isr_redir[4].dma_func)
  201d04:	4807      	ldr	r0, [pc, #28]	; (201d24 <Vector7C+0x24>)
  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
  201d06:	6859      	ldr	r1, [r3, #4]
  if (dma_isr_redir[4].dma_func)
  201d08:	6a02      	ldr	r2, [r0, #32]
  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
  201d0a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 0U;
  201d0e:	60d9      	str	r1, [r3, #12]
  if (dma_isr_redir[4].dma_func)
  201d10:	b10a      	cbz	r2, 201d16 <Vector7C+0x16>
    dma_isr_redir[4].dma_func(dma_isr_redir[4].dma_param, flags);
  201d12:	6a40      	ldr	r0, [r0, #36]	; 0x24
  201d14:	4790      	blx	r2
}
  201d16:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
  201d1a:	f7ff b989 	b.w	201030 <_port_irq_epilogue>
  201d1e:	bf00      	nop
  201d20:	40026000 	.word	0x40026000
  201d24:	20000f8c 	.word	0x20000f8c
	...

00201d30 <Vector78>:
  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
  201d30:	4b08      	ldr	r3, [pc, #32]	; (201d54 <Vector78+0x24>)
  if (dma_isr_redir[3].dma_func)
  201d32:	4809      	ldr	r0, [pc, #36]	; (201d58 <Vector78+0x28>)
  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
  201d34:	6819      	ldr	r1, [r3, #0]
  if (dma_isr_redir[3].dma_func)
  201d36:	6982      	ldr	r2, [r0, #24]
  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
  201d38:	0d89      	lsrs	r1, r1, #22
  201d3a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
  201d3e:	b510      	push	{r4, lr}
  DMA1->LIFCR = flags << 22U;
  201d40:	058c      	lsls	r4, r1, #22
  201d42:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[3].dma_func)
  201d44:	b10a      	cbz	r2, 201d4a <Vector78+0x1a>
    dma_isr_redir[3].dma_func(dma_isr_redir[3].dma_param, flags);
  201d46:	69c0      	ldr	r0, [r0, #28]
  201d48:	4790      	blx	r2
}
  201d4a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
  201d4e:	f7ff b96f 	b.w	201030 <_port_irq_epilogue>
  201d52:	bf00      	nop
  201d54:	40026000 	.word	0x40026000
  201d58:	20000f8c 	.word	0x20000f8c
  201d5c:	00000000 	.word	0x00000000

00201d60 <Vector74>:
  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
  201d60:	4b08      	ldr	r3, [pc, #32]	; (201d84 <Vector74+0x24>)
  if (dma_isr_redir[2].dma_func)
  201d62:	4809      	ldr	r0, [pc, #36]	; (201d88 <Vector74+0x28>)
  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
  201d64:	6819      	ldr	r1, [r3, #0]
  if (dma_isr_redir[2].dma_func)
  201d66:	6902      	ldr	r2, [r0, #16]
  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
  201d68:	0c09      	lsrs	r1, r1, #16
  201d6a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
  201d6e:	b510      	push	{r4, lr}
  DMA1->LIFCR = flags << 16U;
  201d70:	040c      	lsls	r4, r1, #16
  201d72:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[2].dma_func)
  201d74:	b10a      	cbz	r2, 201d7a <Vector74+0x1a>
    dma_isr_redir[2].dma_func(dma_isr_redir[2].dma_param, flags);
  201d76:	6940      	ldr	r0, [r0, #20]
  201d78:	4790      	blx	r2
}
  201d7a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
  201d7e:	f7ff b957 	b.w	201030 <_port_irq_epilogue>
  201d82:	bf00      	nop
  201d84:	40026000 	.word	0x40026000
  201d88:	20000f8c 	.word	0x20000f8c
  201d8c:	00000000 	.word	0x00000000

00201d90 <Vector70>:
  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
  201d90:	4b08      	ldr	r3, [pc, #32]	; (201db4 <Vector70+0x24>)
  if (dma_isr_redir[1].dma_func)
  201d92:	4809      	ldr	r0, [pc, #36]	; (201db8 <Vector70+0x28>)
  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
  201d94:	6819      	ldr	r1, [r3, #0]
  if (dma_isr_redir[1].dma_func)
  201d96:	6882      	ldr	r2, [r0, #8]
  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
  201d98:	0989      	lsrs	r1, r1, #6
  201d9a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
  201d9e:	b510      	push	{r4, lr}
  DMA1->LIFCR = flags << 6U;
  201da0:	018c      	lsls	r4, r1, #6
  201da2:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[1].dma_func)
  201da4:	b10a      	cbz	r2, 201daa <Vector70+0x1a>
    dma_isr_redir[1].dma_func(dma_isr_redir[1].dma_param, flags);
  201da6:	68c0      	ldr	r0, [r0, #12]
  201da8:	4790      	blx	r2
}
  201daa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
  201dae:	f7ff b93f 	b.w	201030 <_port_irq_epilogue>
  201db2:	bf00      	nop
  201db4:	40026000 	.word	0x40026000
  201db8:	20000f8c 	.word	0x20000f8c
  201dbc:	00000000 	.word	0x00000000

00201dc0 <Vector6C>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH0_HANDLER) {
  201dc0:	b508      	push	{r3, lr}
  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
  201dc2:	4b07      	ldr	r3, [pc, #28]	; (201de0 <Vector6C+0x20>)
  if (dma_isr_redir[0].dma_func)
  201dc4:	4a07      	ldr	r2, [pc, #28]	; (201de4 <Vector6C+0x24>)
  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
  201dc6:	6819      	ldr	r1, [r3, #0]
  201dc8:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 0U;
  201dcc:	6099      	str	r1, [r3, #8]
  if (dma_isr_redir[0].dma_func)
  201dce:	6813      	ldr	r3, [r2, #0]
  201dd0:	b10b      	cbz	r3, 201dd6 <Vector6C+0x16>
    dma_isr_redir[0].dma_func(dma_isr_redir[0].dma_param, flags);
  201dd2:	6850      	ldr	r0, [r2, #4]
  201dd4:	4798      	blx	r3
}
  201dd6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
  201dda:	f7ff b929 	b.w	201030 <_port_irq_epilogue>
  201dde:	bf00      	nop
  201de0:	40026000 	.word	0x40026000
  201de4:	20000f8c 	.word	0x20000f8c
	...

00201df0 <adc_lld_stop_conversion>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {
  201df0:	b430      	push	{r4, r5}

  dmaStreamDisable(adcp->dmastp);
  201df2:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
  201df4:	6822      	ldr	r2, [r4, #0]
  201df6:	6813      	ldr	r3, [r2, #0]
  201df8:	f023 031f 	bic.w	r3, r3, #31
  201dfc:	6013      	str	r3, [r2, #0]
  201dfe:	6813      	ldr	r3, [r2, #0]
  201e00:	f013 0301 	ands.w	r3, r3, #1
  201e04:	d1fb      	bne.n	201dfe <adc_lld_stop_conversion+0xe>
  201e06:	7a25      	ldrb	r5, [r4, #8]
  201e08:	213d      	movs	r1, #61	; 0x3d
  adcp->adc->CR1 = 0;
  201e0a:	6a82      	ldr	r2, [r0, #40]	; 0x28
  /* Because ticket #822, preserving injected conversions.*/
  adcp->adc->CR2 &= ~(ADC_CR2_SWSTART);
  adcp->adc->CR2 = ADC_CR2_ADON;
  201e0c:	2001      	movs	r0, #1
  dmaStreamDisable(adcp->dmastp);
  201e0e:	6864      	ldr	r4, [r4, #4]
  201e10:	40a9      	lsls	r1, r5
  201e12:	6021      	str	r1, [r4, #0]
  adcp->adc->CR1 = 0;
  201e14:	6053      	str	r3, [r2, #4]
  adcp->adc->CR2 &= ~(ADC_CR2_SWSTART);
  201e16:	6893      	ldr	r3, [r2, #8]
  201e18:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
}
  201e1c:	bc30      	pop	{r4, r5}
  adcp->adc->CR2 &= ~(ADC_CR2_SWSTART);
  201e1e:	6093      	str	r3, [r2, #8]
  adcp->adc->CR2 = ADC_CR2_ADON;
  201e20:	6090      	str	r0, [r2, #8]
}
  201e22:	4770      	bx	lr
	...

00201e30 <Vector88>:
  sr = ADC1->SR;
  201e30:	4b4c      	ldr	r3, [pc, #304]	; (201f64 <Vector88+0x134>)
  ADC1->SR = 0;
  201e32:	2100      	movs	r1, #0
  sr = ADC1->SR;
  201e34:	681a      	ldr	r2, [r3, #0]
OSAL_IRQ_HANDLER(STM32_ADC_HANDLER) {
  201e36:	b510      	push	{r4, lr}
  ADC1->SR = 0;
  201e38:	6019      	str	r1, [r3, #0]
  if ((sr & ADC_SR_OVR) && (dmaStreamGetTransactionSize(ADCD1.dmastp) > 0)) {
  201e3a:	0691      	lsls	r1, r2, #26
  201e3c:	d505      	bpl.n	201e4a <Vector88+0x1a>
  201e3e:	4c4a      	ldr	r4, [pc, #296]	; (201f68 <Vector88+0x138>)
  201e40:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  201e42:	681b      	ldr	r3, [r3, #0]
  201e44:	685b      	ldr	r3, [r3, #4]
  201e46:	2b00      	cmp	r3, #0
  201e48:	d157      	bne.n	201efa <Vector88+0xca>
  sr = ADC2->SR;
  201e4a:	4b48      	ldr	r3, [pc, #288]	; (201f6c <Vector88+0x13c>)
  ADC2->SR = 0;
  201e4c:	2100      	movs	r1, #0
  sr = ADC2->SR;
  201e4e:	681a      	ldr	r2, [r3, #0]
  ADC2->SR = 0;
  201e50:	6019      	str	r1, [r3, #0]
  if ((sr & ADC_SR_OVR) && (dmaStreamGetTransactionSize(ADCD2.dmastp) > 0)) {
  201e52:	0692      	lsls	r2, r2, #26
  201e54:	d504      	bpl.n	201e60 <Vector88+0x30>
  201e56:	4c46      	ldr	r4, [pc, #280]	; (201f70 <Vector88+0x140>)
  201e58:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  201e5a:	681b      	ldr	r3, [r3, #0]
  201e5c:	685b      	ldr	r3, [r3, #4]
  201e5e:	bb63      	cbnz	r3, 201eba <Vector88+0x8a>
  sr = ADC3->SR;
  201e60:	4b44      	ldr	r3, [pc, #272]	; (201f74 <Vector88+0x144>)
  ADC3->SR = 0;
  201e62:	2100      	movs	r1, #0
  sr = ADC3->SR;
  201e64:	681a      	ldr	r2, [r3, #0]
  ADC3->SR = 0;
  201e66:	6019      	str	r1, [r3, #0]
  if ((sr & ADC_SR_OVR) && (dmaStreamGetTransactionSize(ADCD3.dmastp) > 0)) {
  201e68:	0693      	lsls	r3, r2, #26
  201e6a:	d522      	bpl.n	201eb2 <Vector88+0x82>
  201e6c:	4c42      	ldr	r4, [pc, #264]	; (201f78 <Vector88+0x148>)
  201e6e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  201e70:	681b      	ldr	r3, [r3, #0]
  201e72:	685b      	ldr	r3, [r3, #4]
  201e74:	b1eb      	cbz	r3, 201eb2 <Vector88+0x82>
    if (ADCD3.grpp != NULL)
  201e76:	6923      	ldr	r3, [r4, #16]
  201e78:	b1db      	cbz	r3, 201eb2 <Vector88+0x82>
      _adc_isr_error_code(&ADCD3, ADC_ERR_OVERFLOW);
  201e7a:	4620      	mov	r0, r4
  201e7c:	f7ff ffb8 	bl	201df0 <adc_lld_stop_conversion>
  201e80:	6923      	ldr	r3, [r4, #16]
  201e82:	689b      	ldr	r3, [r3, #8]
  201e84:	2b00      	cmp	r3, #0
  201e86:	d05a      	beq.n	201f3e <Vector88+0x10e>
  201e88:	2205      	movs	r2, #5
  201e8a:	2101      	movs	r1, #1
  201e8c:	4620      	mov	r0, r4
  201e8e:	7022      	strb	r2, [r4, #0]
  201e90:	4798      	blx	r3
  201e92:	7823      	ldrb	r3, [r4, #0]
  201e94:	2b05      	cmp	r3, #5
  201e96:	d04f      	beq.n	201f38 <Vector88+0x108>
  201e98:	2300      	movs	r3, #0
  201e9a:	6123      	str	r3, [r4, #16]
  201e9c:	2320      	movs	r3, #32
  201e9e:	f383 8811 	msr	BASEPRI, r3
  chThdResumeI(trp, msg);
  201ea2:	f04f 31ff 	mov.w	r1, #4294967295
  201ea6:	4835      	ldr	r0, [pc, #212]	; (201f7c <Vector88+0x14c>)
  201ea8:	f7ff fa0a 	bl	2012c0 <chThdResumeI>
  201eac:	2300      	movs	r3, #0
  201eae:	f383 8811 	msr	BASEPRI, r3
}
  201eb2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
  201eb6:	f7ff b8bb 	b.w	201030 <_port_irq_epilogue>
    if (ADCD2.grpp != NULL)
  201eba:	6923      	ldr	r3, [r4, #16]
  201ebc:	2b00      	cmp	r3, #0
  201ebe:	d0cf      	beq.n	201e60 <Vector88+0x30>
      _adc_isr_error_code(&ADCD2, ADC_ERR_OVERFLOW);
  201ec0:	4620      	mov	r0, r4
  201ec2:	f7ff ff95 	bl	201df0 <adc_lld_stop_conversion>
  201ec6:	6923      	ldr	r3, [r4, #16]
  201ec8:	689b      	ldr	r3, [r3, #8]
  201eca:	2b00      	cmp	r3, #0
  201ecc:	d03f      	beq.n	201f4e <Vector88+0x11e>
  201ece:	2205      	movs	r2, #5
  201ed0:	2101      	movs	r1, #1
  201ed2:	4620      	mov	r0, r4
  201ed4:	7022      	strb	r2, [r4, #0]
  201ed6:	4798      	blx	r3
  201ed8:	7823      	ldrb	r3, [r4, #0]
  201eda:	2b05      	cmp	r3, #5
  201edc:	d03e      	beq.n	201f5c <Vector88+0x12c>
  201ede:	2300      	movs	r3, #0
  201ee0:	6123      	str	r3, [r4, #16]
  201ee2:	2320      	movs	r3, #32
  201ee4:	f383 8811 	msr	BASEPRI, r3
  201ee8:	f04f 31ff 	mov.w	r1, #4294967295
  201eec:	4824      	ldr	r0, [pc, #144]	; (201f80 <Vector88+0x150>)
  201eee:	f7ff f9e7 	bl	2012c0 <chThdResumeI>
  201ef2:	2300      	movs	r3, #0
  201ef4:	f383 8811 	msr	BASEPRI, r3
  201ef8:	e7b2      	b.n	201e60 <Vector88+0x30>
    if (ADCD1.grpp != NULL)
  201efa:	6923      	ldr	r3, [r4, #16]
  201efc:	2b00      	cmp	r3, #0
  201efe:	d0a4      	beq.n	201e4a <Vector88+0x1a>
      _adc_isr_error_code(&ADCD1, ADC_ERR_OVERFLOW);
  201f00:	4620      	mov	r0, r4
  201f02:	f7ff ff75 	bl	201df0 <adc_lld_stop_conversion>
  201f06:	6923      	ldr	r3, [r4, #16]
  201f08:	689b      	ldr	r3, [r3, #8]
  201f0a:	b1e3      	cbz	r3, 201f46 <Vector88+0x116>
  201f0c:	2205      	movs	r2, #5
  201f0e:	2101      	movs	r1, #1
  201f10:	4620      	mov	r0, r4
  201f12:	7022      	strb	r2, [r4, #0]
  201f14:	4798      	blx	r3
  201f16:	7823      	ldrb	r3, [r4, #0]
  201f18:	2b05      	cmp	r3, #5
  201f1a:	d01c      	beq.n	201f56 <Vector88+0x126>
  201f1c:	2300      	movs	r3, #0
  201f1e:	6123      	str	r3, [r4, #16]
  201f20:	2320      	movs	r3, #32
  201f22:	f383 8811 	msr	BASEPRI, r3
  201f26:	f04f 31ff 	mov.w	r1, #4294967295
  201f2a:	4816      	ldr	r0, [pc, #88]	; (201f84 <Vector88+0x154>)
  201f2c:	f7ff f9c8 	bl	2012c0 <chThdResumeI>
  201f30:	2300      	movs	r3, #0
  201f32:	f383 8811 	msr	BASEPRI, r3
  201f36:	e788      	b.n	201e4a <Vector88+0x1a>
      _adc_isr_error_code(&ADCD3, ADC_ERR_OVERFLOW);
  201f38:	2302      	movs	r3, #2
  201f3a:	7023      	strb	r3, [r4, #0]
  201f3c:	e7ac      	b.n	201e98 <Vector88+0x68>
  201f3e:	2202      	movs	r2, #2
  201f40:	6123      	str	r3, [r4, #16]
  201f42:	7022      	strb	r2, [r4, #0]
  201f44:	e7aa      	b.n	201e9c <Vector88+0x6c>
      _adc_isr_error_code(&ADCD1, ADC_ERR_OVERFLOW);
  201f46:	2202      	movs	r2, #2
  201f48:	6123      	str	r3, [r4, #16]
  201f4a:	7022      	strb	r2, [r4, #0]
  201f4c:	e7e8      	b.n	201f20 <Vector88+0xf0>
      _adc_isr_error_code(&ADCD2, ADC_ERR_OVERFLOW);
  201f4e:	2202      	movs	r2, #2
  201f50:	6123      	str	r3, [r4, #16]
  201f52:	7022      	strb	r2, [r4, #0]
  201f54:	e7c5      	b.n	201ee2 <Vector88+0xb2>
      _adc_isr_error_code(&ADCD1, ADC_ERR_OVERFLOW);
  201f56:	2302      	movs	r3, #2
  201f58:	7023      	strb	r3, [r4, #0]
  201f5a:	e7df      	b.n	201f1c <Vector88+0xec>
      _adc_isr_error_code(&ADCD2, ADC_ERR_OVERFLOW);
  201f5c:	2302      	movs	r3, #2
  201f5e:	7023      	strb	r3, [r4, #0]
  201f60:	e7bd      	b.n	201ede <Vector88+0xae>
  201f62:	bf00      	nop
  201f64:	40012000 	.word	0x40012000
  201f68:	20000818 	.word	0x20000818
  201f6c:	40012100 	.word	0x40012100
  201f70:	2000084c 	.word	0x2000084c
  201f74:	40012200 	.word	0x40012200
  201f78:	20000880 	.word	0x20000880
  201f7c:	20000894 	.word	0x20000894
  201f80:	20000860 	.word	0x20000860
  201f84:	2000082c 	.word	0x2000082c
	...

00201f90 <VectorE0>:
OSAL_IRQ_HANDLER(VectorE0) {
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR;
  201f90:	4b3e      	ldr	r3, [pc, #248]	; (20208c <VectorE0+0xfc>)
OSAL_IRQ_HANDLER(VectorE0) {
  201f92:	b510      	push	{r4, lr}
  pr = EXTI->PR;
  201f94:	695c      	ldr	r4, [r3, #20]
  pr &= EXTI->IMR & ((1U << 10) | (1U << 11) | (1U << 12) | (1U << 13) |
  201f96:	681a      	ldr	r2, [r3, #0]
  201f98:	4014      	ands	r4, r2
  201f9a:	f404 427c 	and.w	r2, r4, #64512	; 0xfc00
                     (1U << 14) | (1U << 15));
  EXTI->PR = pr;
  201f9e:	615a      	str	r2, [r3, #20]

  exti_serve_irq(pr, 10);
  201fa0:	0562      	lsls	r2, r4, #21
  201fa2:	d510      	bpl.n	201fc6 <VectorE0+0x36>
  201fa4:	4a3a      	ldr	r2, [pc, #232]	; (202090 <VectorE0+0x100>)
  201fa6:	f8d2 30a8 	ldr.w	r3, [r2, #168]	; 0xa8
  201faa:	b113      	cbz	r3, 201fb2 <VectorE0+0x22>
  201fac:	f8d2 00ac 	ldr.w	r0, [r2, #172]	; 0xac
  201fb0:	4798      	blx	r3
  201fb2:	2320      	movs	r3, #32
  201fb4:	f383 8811 	msr	BASEPRI, r3
  chThdDequeueAllI(tqp, msg);
  201fb8:	2100      	movs	r1, #0
  201fba:	4836      	ldr	r0, [pc, #216]	; (202094 <VectorE0+0x104>)
  201fbc:	f7ff f968 	bl	201290 <chThdDequeueAllI>
  201fc0:	2300      	movs	r3, #0
  201fc2:	f383 8811 	msr	BASEPRI, r3
  exti_serve_irq(pr, 11);
  201fc6:	0523      	lsls	r3, r4, #20
  201fc8:	d510      	bpl.n	201fec <VectorE0+0x5c>
  201fca:	4a31      	ldr	r2, [pc, #196]	; (202090 <VectorE0+0x100>)
  201fcc:	f8d2 30b8 	ldr.w	r3, [r2, #184]	; 0xb8
  201fd0:	b113      	cbz	r3, 201fd8 <VectorE0+0x48>
  201fd2:	f8d2 00bc 	ldr.w	r0, [r2, #188]	; 0xbc
  201fd6:	4798      	blx	r3
  201fd8:	2320      	movs	r3, #32
  201fda:	f383 8811 	msr	BASEPRI, r3
  201fde:	2100      	movs	r1, #0
  201fe0:	482d      	ldr	r0, [pc, #180]	; (202098 <VectorE0+0x108>)
  201fe2:	f7ff f955 	bl	201290 <chThdDequeueAllI>
  201fe6:	2300      	movs	r3, #0
  201fe8:	f383 8811 	msr	BASEPRI, r3
  exti_serve_irq(pr, 12);
  201fec:	04e0      	lsls	r0, r4, #19
  201fee:	d510      	bpl.n	202012 <VectorE0+0x82>
  201ff0:	4a27      	ldr	r2, [pc, #156]	; (202090 <VectorE0+0x100>)
  201ff2:	f8d2 30c8 	ldr.w	r3, [r2, #200]	; 0xc8
  201ff6:	b113      	cbz	r3, 201ffe <VectorE0+0x6e>
  201ff8:	f8d2 00cc 	ldr.w	r0, [r2, #204]	; 0xcc
  201ffc:	4798      	blx	r3
  201ffe:	2320      	movs	r3, #32
  202000:	f383 8811 	msr	BASEPRI, r3
  202004:	2100      	movs	r1, #0
  202006:	4825      	ldr	r0, [pc, #148]	; (20209c <VectorE0+0x10c>)
  202008:	f7ff f942 	bl	201290 <chThdDequeueAllI>
  20200c:	2300      	movs	r3, #0
  20200e:	f383 8811 	msr	BASEPRI, r3
  exti_serve_irq(pr, 13);
  202012:	04a1      	lsls	r1, r4, #18
  202014:	d510      	bpl.n	202038 <VectorE0+0xa8>
  202016:	4a1e      	ldr	r2, [pc, #120]	; (202090 <VectorE0+0x100>)
  202018:	f8d2 30d8 	ldr.w	r3, [r2, #216]	; 0xd8
  20201c:	b113      	cbz	r3, 202024 <VectorE0+0x94>
  20201e:	f8d2 00dc 	ldr.w	r0, [r2, #220]	; 0xdc
  202022:	4798      	blx	r3
  202024:	2320      	movs	r3, #32
  202026:	f383 8811 	msr	BASEPRI, r3
  20202a:	2100      	movs	r1, #0
  20202c:	481c      	ldr	r0, [pc, #112]	; (2020a0 <VectorE0+0x110>)
  20202e:	f7ff f92f 	bl	201290 <chThdDequeueAllI>
  202032:	2300      	movs	r3, #0
  202034:	f383 8811 	msr	BASEPRI, r3
  exti_serve_irq(pr, 14);
  202038:	0462      	lsls	r2, r4, #17
  20203a:	d510      	bpl.n	20205e <VectorE0+0xce>
  20203c:	4a14      	ldr	r2, [pc, #80]	; (202090 <VectorE0+0x100>)
  20203e:	f8d2 30e8 	ldr.w	r3, [r2, #232]	; 0xe8
  202042:	b113      	cbz	r3, 20204a <VectorE0+0xba>
  202044:	f8d2 00ec 	ldr.w	r0, [r2, #236]	; 0xec
  202048:	4798      	blx	r3
  20204a:	2320      	movs	r3, #32
  20204c:	f383 8811 	msr	BASEPRI, r3
  202050:	2100      	movs	r1, #0
  202052:	4814      	ldr	r0, [pc, #80]	; (2020a4 <VectorE0+0x114>)
  202054:	f7ff f91c 	bl	201290 <chThdDequeueAllI>
  202058:	2300      	movs	r3, #0
  20205a:	f383 8811 	msr	BASEPRI, r3
  exti_serve_irq(pr, 15);
  20205e:	0423      	lsls	r3, r4, #16
  202060:	d510      	bpl.n	202084 <VectorE0+0xf4>
  202062:	4a0b      	ldr	r2, [pc, #44]	; (202090 <VectorE0+0x100>)
  202064:	f8d2 30f8 	ldr.w	r3, [r2, #248]	; 0xf8
  202068:	b113      	cbz	r3, 202070 <VectorE0+0xe0>
  20206a:	f8d2 00fc 	ldr.w	r0, [r2, #252]	; 0xfc
  20206e:	4798      	blx	r3
  202070:	2320      	movs	r3, #32
  202072:	f383 8811 	msr	BASEPRI, r3
  202076:	2100      	movs	r1, #0
  202078:	480b      	ldr	r0, [pc, #44]	; (2020a8 <VectorE0+0x118>)
  20207a:	f7ff f909 	bl	201290 <chThdDequeueAllI>
  20207e:	2300      	movs	r3, #0
  202080:	f383 8811 	msr	BASEPRI, r3

  OSAL_IRQ_EPILOGUE();
}
  202084:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
  202088:	f7fe bfd2 	b.w	201030 <_port_irq_epilogue>
  20208c:	40013c00 	.word	0x40013c00
  202090:	20000d44 	.word	0x20000d44
  202094:	20000de4 	.word	0x20000de4
  202098:	20000df4 	.word	0x20000df4
  20209c:	20000e04 	.word	0x20000e04
  2020a0:	20000e14 	.word	0x20000e14
  2020a4:	20000e24 	.word	0x20000e24
  2020a8:	20000e34 	.word	0x20000e34
  2020ac:	00000000 	.word	0x00000000

002020b0 <Vector9C>:
  pr = EXTI->PR;
  2020b0:	4b32      	ldr	r3, [pc, #200]	; (20217c <Vector9C+0xcc>)
OSAL_IRQ_HANDLER(Vector9C) {
  2020b2:	b510      	push	{r4, lr}
  pr = EXTI->PR;
  2020b4:	695c      	ldr	r4, [r3, #20]
  pr &= EXTI->IMR & ((1U << 5) | (1U << 6) | (1U << 7) | (1U << 8) |
  2020b6:	681a      	ldr	r2, [r3, #0]
  2020b8:	4014      	ands	r4, r2
  2020ba:	f404 7278 	and.w	r2, r4, #992	; 0x3e0
  EXTI->PR = pr;
  2020be:	615a      	str	r2, [r3, #20]
  exti_serve_irq(pr, 5);
  2020c0:	06a3      	lsls	r3, r4, #26
  2020c2:	d50e      	bpl.n	2020e2 <Vector9C+0x32>
  2020c4:	4a2e      	ldr	r2, [pc, #184]	; (202180 <Vector9C+0xd0>)
  2020c6:	6d93      	ldr	r3, [r2, #88]	; 0x58
  2020c8:	b10b      	cbz	r3, 2020ce <Vector9C+0x1e>
  2020ca:	6dd0      	ldr	r0, [r2, #92]	; 0x5c
  2020cc:	4798      	blx	r3
  2020ce:	2320      	movs	r3, #32
  2020d0:	f383 8811 	msr	BASEPRI, r3
  2020d4:	2100      	movs	r1, #0
  2020d6:	482b      	ldr	r0, [pc, #172]	; (202184 <Vector9C+0xd4>)
  2020d8:	f7ff f8da 	bl	201290 <chThdDequeueAllI>
  2020dc:	2300      	movs	r3, #0
  2020de:	f383 8811 	msr	BASEPRI, r3
  exti_serve_irq(pr, 6);
  2020e2:	0660      	lsls	r0, r4, #25
  2020e4:	d50e      	bpl.n	202104 <Vector9C+0x54>
  2020e6:	4a26      	ldr	r2, [pc, #152]	; (202180 <Vector9C+0xd0>)
  2020e8:	6e93      	ldr	r3, [r2, #104]	; 0x68
  2020ea:	b10b      	cbz	r3, 2020f0 <Vector9C+0x40>
  2020ec:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
  2020ee:	4798      	blx	r3
  2020f0:	2320      	movs	r3, #32
  2020f2:	f383 8811 	msr	BASEPRI, r3
  2020f6:	2100      	movs	r1, #0
  2020f8:	4823      	ldr	r0, [pc, #140]	; (202188 <Vector9C+0xd8>)
  2020fa:	f7ff f8c9 	bl	201290 <chThdDequeueAllI>
  2020fe:	2300      	movs	r3, #0
  202100:	f383 8811 	msr	BASEPRI, r3
  exti_serve_irq(pr, 7);
  202104:	0621      	lsls	r1, r4, #24
  202106:	d50e      	bpl.n	202126 <Vector9C+0x76>
  202108:	4a1d      	ldr	r2, [pc, #116]	; (202180 <Vector9C+0xd0>)
  20210a:	6f93      	ldr	r3, [r2, #120]	; 0x78
  20210c:	b10b      	cbz	r3, 202112 <Vector9C+0x62>
  20210e:	6fd0      	ldr	r0, [r2, #124]	; 0x7c
  202110:	4798      	blx	r3
  202112:	2320      	movs	r3, #32
  202114:	f383 8811 	msr	BASEPRI, r3
  202118:	2100      	movs	r1, #0
  20211a:	481c      	ldr	r0, [pc, #112]	; (20218c <Vector9C+0xdc>)
  20211c:	f7ff f8b8 	bl	201290 <chThdDequeueAllI>
  202120:	2300      	movs	r3, #0
  202122:	f383 8811 	msr	BASEPRI, r3
  exti_serve_irq(pr, 8);
  202126:	05e2      	lsls	r2, r4, #23
  202128:	d510      	bpl.n	20214c <Vector9C+0x9c>
  20212a:	4a15      	ldr	r2, [pc, #84]	; (202180 <Vector9C+0xd0>)
  20212c:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
  202130:	b113      	cbz	r3, 202138 <Vector9C+0x88>
  202132:	f8d2 008c 	ldr.w	r0, [r2, #140]	; 0x8c
  202136:	4798      	blx	r3
  202138:	2320      	movs	r3, #32
  20213a:	f383 8811 	msr	BASEPRI, r3
  20213e:	2100      	movs	r1, #0
  202140:	4813      	ldr	r0, [pc, #76]	; (202190 <Vector9C+0xe0>)
  202142:	f7ff f8a5 	bl	201290 <chThdDequeueAllI>
  202146:	2300      	movs	r3, #0
  202148:	f383 8811 	msr	BASEPRI, r3
  exti_serve_irq(pr, 9);
  20214c:	05a3      	lsls	r3, r4, #22
  20214e:	d510      	bpl.n	202172 <Vector9C+0xc2>
  202150:	4a0b      	ldr	r2, [pc, #44]	; (202180 <Vector9C+0xd0>)
  202152:	f8d2 3098 	ldr.w	r3, [r2, #152]	; 0x98
  202156:	b113      	cbz	r3, 20215e <Vector9C+0xae>
  202158:	f8d2 009c 	ldr.w	r0, [r2, #156]	; 0x9c
  20215c:	4798      	blx	r3
  20215e:	2320      	movs	r3, #32
  202160:	f383 8811 	msr	BASEPRI, r3
  202164:	2100      	movs	r1, #0
  202166:	480b      	ldr	r0, [pc, #44]	; (202194 <Vector9C+0xe4>)
  202168:	f7ff f892 	bl	201290 <chThdDequeueAllI>
  20216c:	2300      	movs	r3, #0
  20216e:	f383 8811 	msr	BASEPRI, r3
}
  202172:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
  202176:	f7fe bf5b 	b.w	201030 <_port_irq_epilogue>
  20217a:	bf00      	nop
  20217c:	40013c00 	.word	0x40013c00
  202180:	20000d44 	.word	0x20000d44
  202184:	20000d94 	.word	0x20000d94
  202188:	20000da4 	.word	0x20000da4
  20218c:	20000db4 	.word	0x20000db4
  202190:	20000dc4 	.word	0x20000dc4
  202194:	20000dd4 	.word	0x20000dd4
	...

002021a0 <Vector68>:
  pr = EXTI->PR;
  2021a0:	4a0d      	ldr	r2, [pc, #52]	; (2021d8 <Vector68+0x38>)
OSAL_IRQ_HANDLER(Vector68) {
  2021a2:	b508      	push	{r3, lr}
  pr = EXTI->PR;
  2021a4:	6953      	ldr	r3, [r2, #20]
  pr &= EXTI->IMR & (1U << 4);
  2021a6:	6811      	ldr	r1, [r2, #0]
  2021a8:	400b      	ands	r3, r1
  2021aa:	f003 0310 	and.w	r3, r3, #16
  EXTI->PR = pr;
  2021ae:	6153      	str	r3, [r2, #20]
  exti_serve_irq(pr, 4);
  2021b0:	b173      	cbz	r3, 2021d0 <Vector68+0x30>
  2021b2:	4a0a      	ldr	r2, [pc, #40]	; (2021dc <Vector68+0x3c>)
  2021b4:	6c93      	ldr	r3, [r2, #72]	; 0x48
  2021b6:	b10b      	cbz	r3, 2021bc <Vector68+0x1c>
  2021b8:	6cd0      	ldr	r0, [r2, #76]	; 0x4c
  2021ba:	4798      	blx	r3
  2021bc:	2320      	movs	r3, #32
  2021be:	f383 8811 	msr	BASEPRI, r3
  2021c2:	2100      	movs	r1, #0
  2021c4:	4806      	ldr	r0, [pc, #24]	; (2021e0 <Vector68+0x40>)
  2021c6:	f7ff f863 	bl	201290 <chThdDequeueAllI>
  2021ca:	2300      	movs	r3, #0
  2021cc:	f383 8811 	msr	BASEPRI, r3
}
  2021d0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
  2021d4:	f7fe bf2c 	b.w	201030 <_port_irq_epilogue>
  2021d8:	40013c00 	.word	0x40013c00
  2021dc:	20000d44 	.word	0x20000d44
  2021e0:	20000d84 	.word	0x20000d84
	...

002021f0 <Vector64>:
  pr = EXTI->PR;
  2021f0:	4a0d      	ldr	r2, [pc, #52]	; (202228 <Vector64+0x38>)
OSAL_IRQ_HANDLER(Vector64) {
  2021f2:	b508      	push	{r3, lr}
  pr = EXTI->PR;
  2021f4:	6953      	ldr	r3, [r2, #20]
  pr &= EXTI->IMR & (1U << 3);
  2021f6:	6811      	ldr	r1, [r2, #0]
  2021f8:	400b      	ands	r3, r1
  2021fa:	f003 0308 	and.w	r3, r3, #8
  EXTI->PR = pr;
  2021fe:	6153      	str	r3, [r2, #20]
  exti_serve_irq(pr, 3);
  202200:	b173      	cbz	r3, 202220 <Vector64+0x30>
  202202:	4a0a      	ldr	r2, [pc, #40]	; (20222c <Vector64+0x3c>)
  202204:	6b93      	ldr	r3, [r2, #56]	; 0x38
  202206:	b10b      	cbz	r3, 20220c <Vector64+0x1c>
  202208:	6bd0      	ldr	r0, [r2, #60]	; 0x3c
  20220a:	4798      	blx	r3
  20220c:	2320      	movs	r3, #32
  20220e:	f383 8811 	msr	BASEPRI, r3
  202212:	2100      	movs	r1, #0
  202214:	4806      	ldr	r0, [pc, #24]	; (202230 <Vector64+0x40>)
  202216:	f7ff f83b 	bl	201290 <chThdDequeueAllI>
  20221a:	2300      	movs	r3, #0
  20221c:	f383 8811 	msr	BASEPRI, r3
}
  202220:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
  202224:	f7fe bf04 	b.w	201030 <_port_irq_epilogue>
  202228:	40013c00 	.word	0x40013c00
  20222c:	20000d44 	.word	0x20000d44
  202230:	20000d74 	.word	0x20000d74
	...

00202240 <Vector60>:
  pr = EXTI->PR;
  202240:	4a0d      	ldr	r2, [pc, #52]	; (202278 <Vector60+0x38>)
OSAL_IRQ_HANDLER(Vector60) {
  202242:	b508      	push	{r3, lr}
  pr = EXTI->PR;
  202244:	6953      	ldr	r3, [r2, #20]
  pr &= EXTI->IMR & (1U << 2);
  202246:	6811      	ldr	r1, [r2, #0]
  202248:	400b      	ands	r3, r1
  20224a:	f003 0304 	and.w	r3, r3, #4
  EXTI->PR = pr;
  20224e:	6153      	str	r3, [r2, #20]
  exti_serve_irq(pr, 2);
  202250:	b173      	cbz	r3, 202270 <Vector60+0x30>
  202252:	4a0a      	ldr	r2, [pc, #40]	; (20227c <Vector60+0x3c>)
  202254:	6a93      	ldr	r3, [r2, #40]	; 0x28
  202256:	b10b      	cbz	r3, 20225c <Vector60+0x1c>
  202258:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
  20225a:	4798      	blx	r3
  20225c:	2320      	movs	r3, #32
  20225e:	f383 8811 	msr	BASEPRI, r3
  202262:	2100      	movs	r1, #0
  202264:	4806      	ldr	r0, [pc, #24]	; (202280 <Vector60+0x40>)
  202266:	f7ff f813 	bl	201290 <chThdDequeueAllI>
  20226a:	2300      	movs	r3, #0
  20226c:	f383 8811 	msr	BASEPRI, r3
}
  202270:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
  202274:	f7fe bedc 	b.w	201030 <_port_irq_epilogue>
  202278:	40013c00 	.word	0x40013c00
  20227c:	20000d44 	.word	0x20000d44
  202280:	20000d64 	.word	0x20000d64
	...

00202290 <Vector5C>:
  pr = EXTI->PR;
  202290:	4a0d      	ldr	r2, [pc, #52]	; (2022c8 <Vector5C+0x38>)
OSAL_IRQ_HANDLER(Vector5C) {
  202292:	b508      	push	{r3, lr}
  pr = EXTI->PR;
  202294:	6953      	ldr	r3, [r2, #20]
  pr &= EXTI->IMR & (1U << 1);
  202296:	6811      	ldr	r1, [r2, #0]
  202298:	400b      	ands	r3, r1
  20229a:	f003 0302 	and.w	r3, r3, #2
  EXTI->PR = pr;
  20229e:	6153      	str	r3, [r2, #20]
  exti_serve_irq(pr, 1);
  2022a0:	b173      	cbz	r3, 2022c0 <Vector5C+0x30>
  2022a2:	4a0a      	ldr	r2, [pc, #40]	; (2022cc <Vector5C+0x3c>)
  2022a4:	6993      	ldr	r3, [r2, #24]
  2022a6:	b10b      	cbz	r3, 2022ac <Vector5C+0x1c>
  2022a8:	69d0      	ldr	r0, [r2, #28]
  2022aa:	4798      	blx	r3
  2022ac:	2320      	movs	r3, #32
  2022ae:	f383 8811 	msr	BASEPRI, r3
  2022b2:	2100      	movs	r1, #0
  2022b4:	4806      	ldr	r0, [pc, #24]	; (2022d0 <Vector5C+0x40>)
  2022b6:	f7fe ffeb 	bl	201290 <chThdDequeueAllI>
  2022ba:	2300      	movs	r3, #0
  2022bc:	f383 8811 	msr	BASEPRI, r3
}
  2022c0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
  2022c4:	f7fe beb4 	b.w	201030 <_port_irq_epilogue>
  2022c8:	40013c00 	.word	0x40013c00
  2022cc:	20000d44 	.word	0x20000d44
  2022d0:	20000d54 	.word	0x20000d54
	...

002022e0 <Vector58>:
  pr = EXTI->PR;
  2022e0:	4a0d      	ldr	r2, [pc, #52]	; (202318 <Vector58+0x38>)
OSAL_IRQ_HANDLER(Vector58) {
  2022e2:	b508      	push	{r3, lr}
  pr = EXTI->PR;
  2022e4:	6953      	ldr	r3, [r2, #20]
  pr &= EXTI->IMR & (1U << 0);
  2022e6:	6811      	ldr	r1, [r2, #0]
  2022e8:	400b      	ands	r3, r1
  2022ea:	f003 0301 	and.w	r3, r3, #1
  EXTI->PR = pr;
  2022ee:	6153      	str	r3, [r2, #20]
  exti_serve_irq(pr, 0);
  2022f0:	b173      	cbz	r3, 202310 <Vector58+0x30>
  2022f2:	4a0a      	ldr	r2, [pc, #40]	; (20231c <Vector58+0x3c>)
  2022f4:	6893      	ldr	r3, [r2, #8]
  2022f6:	b10b      	cbz	r3, 2022fc <Vector58+0x1c>
  2022f8:	68d0      	ldr	r0, [r2, #12]
  2022fa:	4798      	blx	r3
  2022fc:	2320      	movs	r3, #32
  2022fe:	f383 8811 	msr	BASEPRI, r3
  202302:	2100      	movs	r1, #0
  202304:	4805      	ldr	r0, [pc, #20]	; (20231c <Vector58+0x3c>)
  202306:	f7fe ffc3 	bl	201290 <chThdDequeueAllI>
  20230a:	2300      	movs	r3, #0
  20230c:	f383 8811 	msr	BASEPRI, r3
}
  202310:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
  202314:	f7fe be8c 	b.w	201030 <_port_irq_epilogue>
  202318:	40013c00 	.word	0x40013c00
  20231c:	20000d44 	.word	0x20000d44

00202320 <Thread1>:
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.current->name = name;
  202320:	4b14      	ldr	r3, [pc, #80]	; (202374 <Thread1+0x54>)
static THD_FUNCTION(Thread1, arg) {

  (void)arg;
  chRegSetThreadName("blinker");
  while (true) {
	    palSetLine(LINE_LED1);
  202322:	2601      	movs	r6, #1
  202324:	4a14      	ldr	r2, [pc, #80]	; (202378 <Thread1+0x58>)
	    chThdSleepMilliseconds(50);
	    palSetLine(LINE_LED2);
  202326:	2580      	movs	r5, #128	; 0x80
  202328:	699b      	ldr	r3, [r3, #24]
	    palSetLine(LINE_LED1);
  20232a:	4c14      	ldr	r4, [pc, #80]	; (20237c <Thread1+0x5c>)
static THD_FUNCTION(Thread1, arg) {
  20232c:	b580      	push	{r7, lr}
	    palSetLine(LINE_LED1);
  20232e:	4637      	mov	r7, r6
  202330:	619a      	str	r2, [r3, #24]
  202332:	8327      	strh	r7, [r4, #24]
	    chThdSleepMilliseconds(50);
  202334:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
  202338:	f7fe ffd2 	bl	2012e0 <chThdSleep>
	    palSetLine(LINE_LED2);
  20233c:	8325      	strh	r5, [r4, #24]
	    chThdSleepMilliseconds(50);
  20233e:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
  202342:	f7fe ffcd 	bl	2012e0 <chThdSleep>
	    palSetLine(LINE_LED3);
  202346:	f44f 4380 	mov.w	r3, #16384	; 0x4000
	    chThdSleepMilliseconds(200);
  20234a:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
	    palSetLine(LINE_LED3);
  20234e:	8323      	strh	r3, [r4, #24]
	    chThdSleepMilliseconds(200);
  202350:	f7fe ffc6 	bl	2012e0 <chThdSleep>
	    palClearLine(LINE_LED1);
  202354:	8366      	strh	r6, [r4, #26]
	    chThdSleepMilliseconds(50);
  202356:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
  20235a:	f7fe ffc1 	bl	2012e0 <chThdSleep>
	    palClearLine(LINE_LED2);
  20235e:	8365      	strh	r5, [r4, #26]
	    chThdSleepMilliseconds(50);
  202360:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
  202364:	f7fe ffbc 	bl	2012e0 <chThdSleep>
	    //palClearLine(LINE_LED3);
	    chThdSleepMilliseconds(200);
  202368:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
  20236c:	f7fe ffb8 	bl	2012e0 <chThdSleep>
  202370:	e7df      	b.n	202332 <Thread1+0x12>
  202372:	bf00      	nop
  202374:	200012a0 	.word	0x200012a0
  202378:	08003c60 	.word	0x08003c60
  20237c:	40020400 	.word	0x40020400

00202380 <main>:

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).
     Note, GPIOs are not reset because initialized before this point in
     board files.*/
  rccResetAHB1(~STM32_GPIO_EN_MASK);
  202380:	4b22      	ldr	r3, [pc, #136]	; (20240c <main+0x8c>)
  202382:	2200      	movs	r2, #0
  202384:	4922      	ldr	r1, [pc, #136]	; (202410 <main+0x90>)
  rccResetAHB2(~0);
  202386:	f04f 34ff 	mov.w	r4, #4294967295
  rccResetAHB1(~STM32_GPIO_EN_MASK);
  20238a:	691d      	ldr	r5, [r3, #16]
  PWR->CR1 |= PWR_CR1_DBP;
  20238c:	4821      	ldr	r0, [pc, #132]	; (202414 <main+0x94>)
  rccResetAHB1(~STM32_GPIO_EN_MASK);
  20238e:	4329      	orrs	r1, r5
}

/*
 * Application entry point.
 */
int main(void) {
  202390:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
  202394:	6119      	str	r1, [r3, #16]
  202396:	b089      	sub	sp, #36	; 0x24
  202398:	611a      	str	r2, [r3, #16]
  rccResetAHB2(~0);
  20239a:	6959      	ldr	r1, [r3, #20]
  20239c:	615c      	str	r4, [r3, #20]
  20239e:	615a      	str	r2, [r3, #20]
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
  2023a0:	6a19      	ldr	r1, [r3, #32]
  2023a2:	f061 5180 	orn	r1, r1, #268435456	; 0x10000000
  2023a6:	6219      	str	r1, [r3, #32]
  2023a8:	621a      	str	r2, [r3, #32]
  rccResetAPB2(~0);
  2023aa:	6a59      	ldr	r1, [r3, #36]	; 0x24
  2023ac:	625c      	str	r4, [r3, #36]	; 0x24
  2023ae:	625a      	str	r2, [r3, #36]	; 0x24
  PWR->CR1 |= PWR_CR1_DBP;
  2023b0:	6801      	ldr	r1, [r0, #0]
  2023b2:	f441 7180 	orr.w	r1, r1, #256	; 0x100
  2023b6:	6001      	str	r1, [r0, #0]
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
  2023b8:	6f19      	ldr	r1, [r3, #112]	; 0x70
  2023ba:	f401 7140 	and.w	r1, r1, #768	; 0x300
  2023be:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
  2023c2:	d003      	beq.n	2023cc <main+0x4c>
    RCC->BDCR = RCC_BDCR_BDRST;
  2023c4:	f44f 3180 	mov.w	r1, #65536	; 0x10000
  2023c8:	6719      	str	r1, [r3, #112]	; 0x70
    RCC->BDCR = 0;
  2023ca:	671a      	str	r2, [r3, #112]	; 0x70
  RCC->BDCR |= STM32_LSEDRV | RCC_BDCR_LSEON;
  2023cc:	4b0f      	ldr	r3, [pc, #60]	; (20240c <main+0x8c>)
  2023ce:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  while ((RCC->BDCR & RCC_BDCR_LSERDY) == 0)
  2023d0:	4619      	mov	r1, r3
  RCC->BDCR |= STM32_LSEDRV | RCC_BDCR_LSEON;
  2023d2:	f042 0219 	orr.w	r2, r2, #25
  2023d6:	671a      	str	r2, [r3, #112]	; 0x70
  while ((RCC->BDCR & RCC_BDCR_LSERDY) == 0)
  2023d8:	6f0b      	ldr	r3, [r1, #112]	; 0x70
  2023da:	079b      	lsls	r3, r3, #30
  2023dc:	d5fc      	bpl.n	2023d8 <main+0x58>
  PWR->CSR1 &= ~PWR_CSR1_BRE;
  2023de:	4c0d      	ldr	r4, [pc, #52]	; (202414 <main+0x94>)
 * @init
 */
void dmaInit(void) {
  unsigned i;

  dma_streams_mask = 0U;
  2023e0:	2000      	movs	r0, #0
  2023e2:	490d      	ldr	r1, [pc, #52]	; (202418 <main+0x98>)
  2023e4:	6862      	ldr	r2, [r4, #4]
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
  2023e6:	4603      	mov	r3, r0
    _stm32_dma_streams[i].stream->CR = 0U;
  2023e8:	4606      	mov	r6, r0
  dma_streams_mask = 0U;
  2023ea:	4d0c      	ldr	r5, [pc, #48]	; (20241c <main+0x9c>)
  2023ec:	f422 7200 	bic.w	r2, r2, #512	; 0x200
  2023f0:	6062      	str	r2, [r4, #4]
  2023f2:	4a0b      	ldr	r2, [pc, #44]	; (202420 <main+0xa0>)
  2023f4:	6010      	str	r0, [r2, #0]
    dma_isr_redir[i].dma_func = NULL;
  2023f6:	4a0b      	ldr	r2, [pc, #44]	; (202424 <main+0xa4>)
  2023f8:	310c      	adds	r1, #12
    _stm32_dma_streams[i].stream->CR = 0U;
  2023fa:	602e      	str	r6, [r5, #0]
    dma_isr_redir[i].dma_func = NULL;
  2023fc:	f842 6033 	str.w	r6, [r2, r3, lsl #3]
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
  202400:	3301      	adds	r3, #1
  202402:	2b10      	cmp	r3, #16
  202404:	d010      	beq.n	202428 <main+0xa8>
  202406:	f851 5c0c 	ldr.w	r5, [r1, #-12]
  20240a:	e7f4      	b.n	2023f6 <main+0x76>
  20240c:	40023800 	.word	0x40023800
  202410:	fffff800 	.word	0xfffff800
  202414:	40007000 	.word	0x40007000
  202418:	08003c74 	.word	0x08003c74
  20241c:	40026010 	.word	0x40026010
  202420:	2000100c 	.word	0x2000100c
  202424:	20000f8c 	.word	0x20000f8c
  }
  DMA1->LIFCR = 0xFFFFFFFFU;
  202428:	f04f 33ff 	mov.w	r3, #4294967295
  20242c:	4cc4      	ldr	r4, [pc, #784]	; (202740 <main+0x3c0>)
  DMA1->HIFCR = 0xFFFFFFFFU;
  DMA2->LIFCR = 0xFFFFFFFFU;
  20242e:	4ec5      	ldr	r6, [pc, #788]	; (202744 <main+0x3c4>)

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  202430:	2060      	movs	r0, #96	; 0x60
  DMA1->LIFCR = 0xFFFFFFFFU;
  202432:	60a3      	str	r3, [r4, #8]
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  202434:	2540      	movs	r5, #64	; 0x40
  DMA1->HIFCR = 0xFFFFFFFFU;
  202436:	60e3      	str	r3, [r4, #12]
  202438:	2780      	movs	r7, #128	; 0x80
  DMA2->LIFCR = 0xFFFFFFFFU;
  20243a:	60b3      	str	r3, [r6, #8]
  20243c:	f44f 7480 	mov.w	r4, #256	; 0x100
  DMA2->HIFCR = 0xFFFFFFFFU;
  202440:	60f3      	str	r3, [r6, #12]
  202442:	f44f 7300 	mov.w	r3, #512	; 0x200
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  202446:	4ac0      	ldr	r2, [pc, #768]	; (202748 <main+0x3c8>)
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  202448:	f44f 6680 	mov.w	r6, #1024	; 0x400
  20244c:	49bf      	ldr	r1, [pc, #764]	; (20274c <main+0x3cc>)
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  20244e:	f882 0306 	strb.w	r0, [r2, #774]	; 0x306
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  202452:	f8c2 5180 	str.w	r5, [r2, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  202456:	6015      	str	r5, [r2, #0]
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  202458:	f44f 0500 	mov.w	r5, #8388608	; 0x800000
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  20245c:	f882 0307 	strb.w	r0, [r2, #775]	; 0x307
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  202460:	f8c2 7180 	str.w	r7, [r2, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  202464:	6017      	str	r7, [r2, #0]
  202466:	190f      	adds	r7, r1, r4
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  202468:	f882 0308 	strb.w	r0, [r2, #776]	; 0x308
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  20246c:	f8c2 4180 	str.w	r4, [r2, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  202470:	6014      	str	r4, [r2, #0]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  202472:	f882 0309 	strb.w	r0, [r2, #777]	; 0x309
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  202476:	f8c2 3180 	str.w	r3, [r2, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  20247a:	6013      	str	r3, [r2, #0]

#if PAL_USE_CALLBACKS || PAL_USE_WAIT || defined(__DOXYGEN__)
  unsigned i;

  for (i = 0; i < 16; i++) {
    _pal_init_event(i);
  20247c:	2300      	movs	r3, #0
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  20247e:	f882 030a 	strb.w	r0, [r2, #778]	; 0x30a
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  202482:	f8c2 6180 	str.w	r6, [r2, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  202486:	6016      	str	r6, [r2, #0]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  202488:	f882 0317 	strb.w	r0, [r2, #791]	; 0x317
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  20248c:	f8c2 5180 	str.w	r5, [r2, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  202490:	6015      	str	r5, [r2, #0]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  202492:	f882 0328 	strb.w	r0, [r2, #808]	; 0x328
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  202496:	f8c2 4184 	str.w	r4, [r2, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  20249a:	6054      	str	r4, [r2, #4]
  20249c:	608b      	str	r3, [r1, #8]
  20249e:	60cb      	str	r3, [r1, #12]
  tqp->next = (thread_t *)tqp;
  2024a0:	6009      	str	r1, [r1, #0]
  tqp->prev = (thread_t *)tqp;
  2024a2:	6049      	str	r1, [r1, #4]
  2024a4:	3110      	adds	r1, #16
  for (i = 0; i < 16; i++) {
  2024a6:	42b9      	cmp	r1, r7
  2024a8:	d1f8      	bne.n	20249c <main+0x11c>
 *
 * @init
 */
void adcObjectInit(ADCDriver *adcp) {

  adcp->state    = ADC_STOP;
  2024aa:	4fa9      	ldr	r7, [pc, #676]	; (202750 <main+0x3d0>)
  2024ac:	2201      	movs	r2, #1
  ADCD1.adc = ADC1;
  2024ae:	4ca9      	ldr	r4, [pc, #676]	; (202754 <main+0x3d4>)
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  2024b0:	2560      	movs	r5, #96	; 0x60
  ADCD1.dmastp  = STM32_DMA_STREAM(STM32_ADC_ADC1_DMA_STREAM);
  2024b2:	49a9      	ldr	r1, [pc, #676]	; (202758 <main+0x3d8>)
  tqp->next = (thread_t *)tqp;
  2024b4:	f107 0018 	add.w	r0, r7, #24
  ADCD1.adc = ADC1;
  2024b8:	62bc      	str	r4, [r7, #40]	; 0x28
  ADCD1.dmamode = STM32_DMA_CR_CHSEL(ADC1_DMA_CHANNEL) |
  2024ba:	4ca8      	ldr	r4, [pc, #672]	; (20275c <main+0x3dc>)
  ADCD2.dmastp  = STM32_DMA_STREAM(STM32_ADC_ADC2_DMA_STREAM);
  2024bc:	f1a1 0e18 	sub.w	lr, r1, #24
  2024c0:	f8df 92d8 	ldr.w	r9, [pc, #728]	; 20279c <main+0x41c>
  ADCD1.dmamode = STM32_DMA_CR_CHSEL(ADC1_DMA_CHANNEL) |
  2024c4:	633c      	str	r4, [r7, #48]	; 0x30
  ADCD3.dmastp  = STM32_DMA_STREAM(STM32_ADC_ADC3_DMA_STREAM);
  2024c6:	f1a1 0424 	sub.w	r4, r1, #36	; 0x24
  ADCD1.dmastp  = STM32_DMA_STREAM(STM32_ADC_ADC1_DMA_STREAM);
  2024ca:	62f9      	str	r1, [r7, #44]	; 0x2c
  ADCD2.adc = ADC2;
  2024cc:	49a4      	ldr	r1, [pc, #656]	; (202760 <main+0x3e0>)
  2024ce:	f8df 82d0 	ldr.w	r8, [pc, #720]	; 2027a0 <main+0x420>
  2024d2:	f8c9 1028 	str.w	r1, [r9, #40]	; 0x28
  ADCD2.dmamode = STM32_DMA_CR_CHSEL(ADC2_DMA_CHANNEL) |
  2024d6:	49a3      	ldr	r1, [pc, #652]	; (202764 <main+0x3e4>)
  usbp->state        = USB_STOP;
  2024d8:	4ea3      	ldr	r6, [pc, #652]	; (202768 <main+0x3e8>)
  2024da:	61b8      	str	r0, [r7, #24]
  tqp->prev = (thread_t *)tqp;
  2024dc:	61f8      	str	r0, [r7, #28]
  tqp->next = (thread_t *)tqp;
  2024de:	f108 0018 	add.w	r0, r8, #24
  2024e2:	f8c9 1030 	str.w	r1, [r9, #48]	; 0x30
  2024e6:	f109 0118 	add.w	r1, r9, #24
  adcp->config   = NULL;
  2024ea:	607b      	str	r3, [r7, #4]
  adcp->samples  = NULL;
  2024ec:	60bb      	str	r3, [r7, #8]
  adcp->depth    = 0;
  2024ee:	60fb      	str	r3, [r7, #12]
  adcp->grpp     = NULL;
  2024f0:	613b      	str	r3, [r7, #16]
#if ADC_USE_WAIT == TRUE
  adcp->thread   = NULL;
  2024f2:	617b      	str	r3, [r7, #20]
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->queue);
  mp->owner = NULL;
  2024f4:	623b      	str	r3, [r7, #32]
  ADCD2.dmastp  = STM32_DMA_STREAM(STM32_ADC_ADC2_DMA_STREAM);
  2024f6:	f8c9 e02c 	str.w	lr, [r9, #44]	; 0x2c
  2024fa:	f106 0e38 	add.w	lr, r6, #56	; 0x38
  adcp->config   = NULL;
  2024fe:	f8c9 3004 	str.w	r3, [r9, #4]
  adcp->samples  = NULL;
  202502:	f8c9 3008 	str.w	r3, [r9, #8]
  adcp->depth    = 0;
  202506:	f8c9 300c 	str.w	r3, [r9, #12]
  adcp->grpp     = NULL;
  20250a:	f8c9 3010 	str.w	r3, [r9, #16]
  adcp->thread   = NULL;
  20250e:	f8c9 3014 	str.w	r3, [r9, #20]
  202512:	f8c9 3020 	str.w	r3, [r9, #32]
  adcp->config   = NULL;
  202516:	f8c8 3004 	str.w	r3, [r8, #4]
  adcp->samples  = NULL;
  20251a:	f8c8 3008 	str.w	r3, [r8, #8]
  adcp->depth    = 0;
  20251e:	f8c8 300c 	str.w	r3, [r8, #12]
  adcp->grpp     = NULL;
  202522:	f8c8 3010 	str.w	r3, [r8, #16]
  adcp->thread   = NULL;
  202526:	f8c8 3014 	str.w	r3, [r8, #20]
  20252a:	f8c8 0018 	str.w	r0, [r8, #24]
  tqp->prev = (thread_t *)tqp;
  20252e:	f8c8 001c 	str.w	r0, [r8, #28]
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  202532:	f44f 2080 	mov.w	r0, #262144	; 0x40000
  tqp->next = (thread_t *)tqp;
  202536:	f8c9 1018 	str.w	r1, [r9, #24]
  tqp->prev = (thread_t *)tqp;
  20253a:	f8c9 101c 	str.w	r1, [r9, #28]
  20253e:	f106 0124 	add.w	r1, r6, #36	; 0x24
  adcp->state    = ADC_STOP;
  202542:	703a      	strb	r2, [r7, #0]
  202544:	f889 2000 	strb.w	r2, [r9]
  202548:	f888 2000 	strb.w	r2, [r8]
  20254c:	f8c8 3020 	str.w	r3, [r8, #32]
  ADCD3.dmastp  = STM32_DMA_STREAM(STM32_ADC_ADC3_DMA_STREAM);
  202550:	f8c8 402c 	str.w	r4, [r8, #44]	; 0x2c
  usbp->config       = NULL;
  202554:	6073      	str	r3, [r6, #4]
  ADCD3.adc = ADC3;
  202556:	4c85      	ldr	r4, [pc, #532]	; (20276c <main+0x3ec>)
  ADCD3.dmamode = STM32_DMA_CR_CHSEL(ADC3_DMA_CHANNEL) |
  202558:	4b85      	ldr	r3, [pc, #532]	; (202770 <main+0x3f0>)
  ADCD3.adc = ADC3;
  20255a:	f8c8 4028 	str.w	r4, [r8, #40]	; 0x28
    usbp->in_params[i]  = NULL;
  20255e:	2400      	movs	r4, #0
  ADCD3.dmamode = STM32_DMA_CR_CHSEL(ADC3_DMA_CHANNEL) |
  202560:	f8c8 3030 	str.w	r3, [r8, #48]	; 0x30
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  202564:	4b78      	ldr	r3, [pc, #480]	; (202748 <main+0x3c8>)
  202566:	f883 5312 	strb.w	r5, [r3, #786]	; 0x312
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  20256a:	f8c3 0180 	str.w	r0, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  20256e:	6018      	str	r0, [r3, #0]
  usbp->state        = USB_STOP;
  202570:	7032      	strb	r2, [r6, #0]
    usbp->in_params[i]  = NULL;
  202572:	f841 4b04 	str.w	r4, [r1], #4
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
  202576:	4571      	cmp	r1, lr
    usbp->out_params[i] = NULL;
  202578:	610c      	str	r4, [r1, #16]
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
  20257a:	d1fa      	bne.n	202572 <main+0x1f2>

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
  20257c:	f8df a224 	ldr.w	sl, [pc, #548]	; 2027a4 <main+0x424>
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
  STM32_ST_TIM->CCMR1  = 0;
  STM32_ST_TIM->CCR[0] = 0;
  STM32_ST_TIM->DIER   = 0;
  STM32_ST_TIM->CR2    = 0;
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
  202580:	f04f 0b01 	mov.w	fp, #1
  tqp->next = (thread_t *)tqp;
  202584:	4d7b      	ldr	r5, [pc, #492]	; (202774 <main+0x3f4>)
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
  202586:	f04f 3eff 	mov.w	lr, #4294967295
  ST_ENABLE_CLOCK();
  20258a:	f8da 0040 	ldr.w	r0, [sl, #64]	; 0x40
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
  20258e:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
  ST_ENABLE_STOP();
  202592:	f8df c214 	ldr.w	ip, [pc, #532]	; 2027a8 <main+0x428>
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
  202596:	f642 232f 	movw	r3, #10799	; 0x2a2f
  ST_ENABLE_CLOCK();
  20259a:	f040 0001 	orr.w	r0, r0, #1
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  20259e:	4a6a      	ldr	r2, [pc, #424]	; (202748 <main+0x3c8>)
  2025a0:	f8ca 0040 	str.w	r0, [sl, #64]	; 0x40
  2025a4:	f8da 0060 	ldr.w	r0, [sl, #96]	; 0x60
  ch.vtlist.delta = (sysinterval_t)-1;
  2025a8:	f8c5 e024 	str.w	lr, [r5, #36]	; 0x24
  2025ac:	ea40 000b 	orr.w	r0, r0, fp
  usbp->transmitting = 0;
  2025b0:	8134      	strh	r4, [r6, #8]
  usbp->receiving    = 0;
  2025b2:	8174      	strh	r4, [r6, #10]
  2025b4:	f8ca 0060 	str.w	r0, [sl, #96]	; 0x60
  ST_ENABLE_STOP();
  2025b8:	f8dc 0008 	ldr.w	r0, [ip, #8]
  tqp->prev = (thread_t *)tqp;
  2025bc:	606d      	str	r5, [r5, #4]
  2025be:	ea40 000b 	orr.w	r0, r0, fp
  ch.rlist.prio = NOPRIO;
  2025c2:	60ac      	str	r4, [r5, #8]
  ch.rlist.newer = (thread_t *)&ch.rlist;
  2025c4:	612d      	str	r5, [r5, #16]
  2025c6:	f8cc 0008 	str.w	r0, [ip, #8]
  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
  2025ca:	f105 001c 	add.w	r0, r5, #28
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
  2025ce:	628b      	str	r3, [r1, #40]	; 0x28
  USBD1.otg       = OTG_FS;
  2025d0:	f04f 4ca0 	mov.w	ip, #1342177280	; 0x50000000
  2025d4:	f06f 037f 	mvn.w	r3, #127	; 0x7f
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
  2025d8:	f8c1 e02c 	str.w	lr, [r1, #44]	; 0x2c
  ch.rlist.older = (thread_t *)&ch.rlist;
  2025dc:	616d      	str	r5, [r5, #20]
  STM32_ST_TIM->CCMR1  = 0;
  2025de:	618c      	str	r4, [r1, #24]
  ch.vtlist.lasttime = (systime_t)0;
  2025e0:	62ac      	str	r4, [r5, #40]	; 0x28
  STM32_ST_TIM->CCR[0] = 0;
  2025e2:	634c      	str	r4, [r1, #52]	; 0x34
  ch.tm.offset = (rtcnt_t)0;
  2025e4:	676c      	str	r4, [r5, #116]	; 0x74
  STM32_ST_TIM->DIER   = 0;
  2025e6:	60cc      	str	r4, [r1, #12]
  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
  2025e8:	61e8      	str	r0, [r5, #28]
  STM32_ST_TIM->CR2    = 0;
  2025ea:	604c      	str	r4, [r1, #4]
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
  2025ec:	6228      	str	r0, [r5, #32]
  chTMStartMeasurementX(&tm);
  2025ee:	a802      	add	r0, sp, #8
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
  2025f0:	f8c1 b014 	str.w	fp, [r1, #20]
  2025f4:	f8c6 c06c 	str.w	ip, [r6, #108]	; 0x6c
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
  2025f8:	f8c1 b000 	str.w	fp, [r1]
  2025fc:	f882 331c 	strb.w	r3, [r2, #796]	; 0x31c
  USBD1.otgparams = &fsparams;
  202600:	4b5d      	ldr	r3, [pc, #372]	; (202778 <main+0x3f8>)
  202602:	6733      	str	r3, [r6, #112]	; 0x70
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  202604:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
  202608:	f8c2 3180 	str.w	r3, [r2, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  20260c:	6013      	str	r3, [r2, #0]
  tmp->cumulative = (rttime_t)0;
  20260e:	2300      	movs	r3, #0
  202610:	9201      	str	r2, [sp, #4]
  202612:	2200      	movs	r2, #0
  tmp->best       = (rtcnt_t)-1;
  202614:	f8cd e008 	str.w	lr, [sp, #8]
  tqp->next = (thread_t *)tqp;
  202618:	602d      	str	r5, [r5, #0]
  tmp->worst      = (rtcnt_t)0;
  20261a:	9403      	str	r4, [sp, #12]
  tmp->last       = (rtcnt_t)0;
  20261c:	9404      	str	r4, [sp, #16]
  tmp->n          = (ucnt_t)0;
  20261e:	9405      	str	r4, [sp, #20]
  tmp->cumulative = (rttime_t)0;
  202620:	e9cd 2306 	strd	r2, r3, [sp, #24]
  chTMStartMeasurementX(&tm);
  202624:	f001 f974 	bl	203910 <chTMStartMeasurementX.constprop.35>
  chTMStopMeasurementX(&tm);
  202628:	a802      	add	r0, sp, #8
  20262a:	f7fe fe09 	bl	201240 <chTMStopMeasurementX>
  tp->prio      = prio;
  20262e:	2380      	movs	r3, #128	; 0x80
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.provider = chCoreAllocAlignedWithOffset;
  202630:	f8df e178 	ldr.w	lr, [pc, #376]	; 2027ac <main+0x42c>
                             unsigned align, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->next = NULL;
  mp->object_size = size;
  202634:	2214      	movs	r2, #20
  202636:	63ab      	str	r3, [r5, #56]	; 0x38
  202638:	211c      	movs	r1, #28
  tp->realprio  = prio;
  20263a:	66eb      	str	r3, [r5, #108]	; 0x6c
  20263c:	f10e 0c0c 	add.w	ip, lr, #12
  ch.tm.offset = tm.last;
  202640:	9b04      	ldr	r3, [sp, #16]
  202642:	484e      	ldr	r0, [pc, #312]	; (20277c <main+0x3fc>)
  202644:	676b      	str	r3, [r5, #116]	; 0x74
  202646:	4b4e      	ldr	r3, [pc, #312]	; (202780 <main+0x400>)
  H_NEXT(&default_heap.header) = NULL;
  202648:	f8ce 4004 	str.w	r4, [lr, #4]
  H_PAGES(&default_heap.header) = 0;
  20264c:	f8ce 4008 	str.w	r4, [lr, #8]
  202650:	f8ce 4014 	str.w	r4, [lr, #20]
  default_heap.provider = chCoreAllocAlignedWithOffset;
  202654:	f8ce 3000 	str.w	r3, [lr]
/* Module local functions.                                                   */
/*===========================================================================*/

static inline void dyn_list_init(dyn_list_t *dlp) {

  dlp->next = (dyn_element_t *)dlp;
  202658:	f100 0310 	add.w	r3, r0, #16
  20265c:	f8ce c00c 	str.w	ip, [lr, #12]
  tqp->prev = (thread_t *)tqp;
  202660:	f8ce c010 	str.w	ip, [lr, #16]
  202664:	f100 0e3c 	add.w	lr, r0, #60	; 0x3c
  202668:	6182      	str	r2, [r0, #24]
  20266a:	f100 0224 	add.w	r2, r0, #36	; 0x24
  20266e:	f100 0c40 	add.w	ip, r0, #64	; 0x40
  202672:	6103      	str	r3, [r0, #16]
  202674:	6242      	str	r2, [r0, #36]	; 0x24
  mp->align = align;
  202676:	2304      	movs	r3, #4
  202678:	f100 0228 	add.w	r2, r0, #40	; 0x28
  20267c:	f8c0 e03c 	str.w	lr, [r0, #60]	; 0x3c
  mp->provider = provider;
  202680:	f8df e12c 	ldr.w	lr, [pc, #300]	; 2027b0 <main+0x430>
  202684:	6084      	str	r4, [r0, #8]
  mp->next = NULL;
  202686:	6144      	str	r4, [r0, #20]
  202688:	62c4      	str	r4, [r0, #44]	; 0x2c
  20268a:	6282      	str	r2, [r0, #40]	; 0x28
  tlp->next = (thread_t *)tlp;
  20268c:	f105 0258 	add.w	r2, r5, #88	; 0x58
  mp->object_size = size;
  202690:	6301      	str	r1, [r0, #48]	; 0x30
  REG_INSERT(tp);
  202692:	f105 0130 	add.w	r1, r5, #48	; 0x30
  202696:	f8c0 c040 	str.w	ip, [r0, #64]	; 0x40
  mp->align = align;
  20269a:	61c3      	str	r3, [r0, #28]
  20269c:	6343      	str	r3, [r0, #52]	; 0x34
  mp->provider = provider;
  20269e:	f8c0 e020 	str.w	lr, [r0, #32]
  ch_memcore.nextmem = __heap_base__;
  2026a2:	4b38      	ldr	r3, [pc, #224]	; (202784 <main+0x404>)
  2026a4:	f8c0 e038 	str.w	lr, [r0, #56]	; 0x38
  tqp->next = (thread_t *)tqp;
  2026a8:	6000      	str	r0, [r0, #0]
  tqp->prev = (thread_t *)tqp;
  2026aa:	6040      	str	r0, [r0, #4]
  2026ac:	f8df e104 	ldr.w	lr, [pc, #260]	; 2027b4 <main+0x434>
  ch_memcore.endmem  = __heap_end__;
  2026b0:	4835      	ldr	r0, [pc, #212]	; (202788 <main+0x408>)
  ch_memcore.nextmem = __heap_base__;
  2026b2:	f8c3 e000 	str.w	lr, [r3]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  2026b6:	f64f 0eff 	movw	lr, #63743	; 0xf8ff
  ch_memcore.endmem  = __heap_end__;
  2026ba:	6058      	str	r0, [r3, #4]
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  2026bc:	4b33      	ldr	r3, [pc, #204]	; (20278c <main+0x40c>)
  tp->name      = name;
  2026be:	4834      	ldr	r0, [pc, #208]	; (202790 <main+0x410>)
  tp->flags     = CH_FLAG_MODE_STATIC;
  2026c0:	f885 4051 	strb.w	r4, [r5, #81]	; 0x51
  tp->mtxlist   = NULL;
  2026c4:	66ac      	str	r4, [r5, #104]	; 0x68
  tp->epending  = (eventmask_t)0;
  2026c6:	666c      	str	r4, [r5, #100]	; 0x64
  tp->refs      = (trefs_t)1;
  2026c8:	f885 b052 	strb.w	fp, [r5, #82]	; 0x52
  tp->name      = name;
  2026cc:	64a8      	str	r0, [r5, #72]	; 0x48
  2026ce:	68d8      	ldr	r0, [r3, #12]
  REG_INSERT(tp);
  2026d0:	f8d5 c014 	ldr.w	ip, [r5, #20]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  2026d4:	ea00 0e0e 	and.w	lr, r0, lr
  reg_value  =  (reg_value                                   |
  2026d8:	482e      	ldr	r0, [pc, #184]	; (202794 <main+0x414>)
  2026da:	f8c5 c044 	str.w	ip, [r5, #68]	; 0x44
  2026de:	642d      	str	r5, [r5, #64]	; 0x40
  2026e0:	ea4e 0000 	orr.w	r0, lr, r0
  2026e4:	f8cc 1010 	str.w	r1, [ip, #16]
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
  2026e8:	f8df c0cc 	ldr.w	ip, [pc, #204]	; 2027b8 <main+0x438>
  SCB->AIRCR =  reg_value;
  2026ec:	60d8      	str	r0, [r3, #12]
  2026ee:	f8dc e00c 	ldr.w	lr, [ip, #12]
  DWT->LAR = 0xC5ACCE55U;
  2026f2:	4829      	ldr	r0, [pc, #164]	; (202798 <main+0x418>)
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
  2026f4:	f04e 7e80 	orr.w	lr, lr, #16777216	; 0x1000000
  2026f8:	6169      	str	r1, [r5, #20]
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
  2026fa:	61a9      	str	r1, [r5, #24]
  currp->wabase = NULL;
  2026fc:	64ec      	str	r4, [r5, #76]	; 0x4c
  2026fe:	f8cc e00c 	str.w	lr, [ip, #12]
  DWT->LAR = 0xC5ACCE55U;
  202702:	f8df e0b8 	ldr.w	lr, [pc, #184]	; 2027bc <main+0x43c>
  currp->state = CH_STATE_CURRENT;
  202706:	f885 b050 	strb.w	fp, [r5, #80]	; 0x50
  20270a:	f8c0 efb0 	str.w	lr, [r0, #4016]	; 0xfb0
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
  20270e:	f8d0 e000 	ldr.w	lr, [r0]
  tlp->next = (thread_t *)tlp;
  202712:	65aa      	str	r2, [r5, #88]	; 0x58
  tqp->next = (thread_t *)tqp;
  202714:	f105 025c 	add.w	r2, r5, #92	; 0x5c
  202718:	ea4e 0e0b 	orr.w	lr, lr, fp
  20271c:	65ea      	str	r2, [r5, #92]	; 0x5c
  tqp->prev = (thread_t *)tqp;
  20271e:	662a      	str	r2, [r5, #96]	; 0x60
    SCB->SHPR[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  202720:	f04f 0210 	mov.w	r2, #16
  202724:	f8c0 e000 	str.w	lr, [r0]
  202728:	77da      	strb	r2, [r3, #31]
  20272a:	f04f 0220 	mov.w	r2, #32
  20272e:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
  202732:	f384 8811 	msr	BASEPRI, r4
  __ASM volatile ("cpsie i" : : : "memory");
  202736:	b662      	cpsie	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  202738:	2320      	movs	r3, #32
  20273a:	f383 8811 	msr	BASEPRI, r3
  20273e:	e03f      	b.n	2027c0 <main+0x440>
  202740:	40026000 	.word	0x40026000
  202744:	40026400 	.word	0x40026400
  202748:	e000e100 	.word	0xe000e100
  20274c:	20000d44 	.word	0x20000d44
  202750:	20000818 	.word	0x20000818
  202754:	40012000 	.word	0x40012000
  202758:	08003cf8 	.word	0x08003cf8
  20275c:	00022c16 	.word	0x00022c16
  202760:	40012100 	.word	0x40012100
  202764:	02022c16 	.word	0x02022c16
  202768:	20001228 	.word	0x20001228
  20276c:	40012200 	.word	0x40012200
  202770:	04022c16 	.word	0x04022c16
  202774:	200012a0 	.word	0x200012a0
  202778:	08003db8 	.word	0x08003db8
  20277c:	20000e48 	.word	0x20000e48
  202780:	002003b1 	.word	0x002003b1
  202784:	20000f68 	.word	0x20000f68
  202788:	20080000 	.word	0x20080000
  20278c:	e000ed00 	.word	0xe000ed00
  202790:	08003da0 	.word	0x08003da0
  202794:	05fa0300 	.word	0x05fa0300
  202798:	e0001000 	.word	0xe0001000
  20279c:	2000084c 	.word	0x2000084c
  2027a0:	20000880 	.word	0x20000880
  2027a4:	40023800 	.word	0x40023800
  2027a8:	e0042000 	.word	0xe0042000
  2027ac:	20000f70 	.word	0x20000f70
  2027b0:	00200381 	.word	0x00200381
  2027b4:	20020008 	.word	0x20020008
  2027b8:	e000edf0 	.word	0xe000edf0
  2027bc:	c5acce55 	.word	0xc5acce55
  tp->wabase = tdp->wbase;
  2027c0:	4bc0      	ldr	r3, [pc, #768]	; (202ac4 <main+0x744>)
  tp->state     = CH_STATE_WTSTART;
  2027c2:	2102      	movs	r1, #2
  REG_INSERT(tp);
  2027c4:	696a      	ldr	r2, [r5, #20]
  2027c6:	f103 0c90 	add.w	ip, r3, #144	; 0x90
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
  2027ca:	f103 006c 	add.w	r0, r3, #108	; 0x6c
  REG_INSERT(tp);
  2027ce:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
  tp->name      = name;
  2027d2:	4abd      	ldr	r2, [pc, #756]	; (202ac8 <main+0x748>)
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
  2027d4:	f8df e338 	ldr.w	lr, [pc, #824]	; 202b10 <main+0x790>
  tp->name      = name;
  2027d8:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
  2027dc:	4abb      	ldr	r2, [pc, #748]	; (202acc <main+0x74c>)
  2027de:	f8c3 009c 	str.w	r0, [r3, #156]	; 0x9c
  chSchWakeupS(tp, MSG_OK);
  2027e2:	4660      	mov	r0, ip
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
  2027e4:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
  REG_INSERT(tp);
  2027e8:	696a      	ldr	r2, [r5, #20]
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
  2027ea:	f8c3 e06c 	str.w	lr, [r3, #108]	; 0x6c
  tqp->next = (thread_t *)tqp;
  2027ee:	f103 0ebc 	add.w	lr, r3, #188	; 0xbc
  2027f2:	671c      	str	r4, [r3, #112]	; 0x70
  tp->prio      = prio;
  2027f4:	f8c3 b098 	str.w	fp, [r3, #152]	; 0x98
  tp->flags     = CH_FLAG_MODE_STATIC;
  2027f8:	f883 40b1 	strb.w	r4, [r3, #177]	; 0xb1
  tp->realprio  = prio;
  2027fc:	f8c3 b0cc 	str.w	fp, [r3, #204]	; 0xcc
  tp->mtxlist   = NULL;
  202800:	f8c3 40c8 	str.w	r4, [r3, #200]	; 0xc8
  tp->epending  = (eventmask_t)0;
  202804:	f8c3 40c4 	str.w	r4, [r3, #196]	; 0xc4
  tp->refs      = (trefs_t)1;
  202808:	f883 b0b2 	strb.w	fp, [r3, #178]	; 0xb2
  REG_INSERT(tp);
  20280c:	f8c3 50a0 	str.w	r5, [r3, #160]	; 0xa0
  tp->wabase = tdp->wbase;
  202810:	f8c3 30ac 	str.w	r3, [r3, #172]	; 0xac
  tp->state     = CH_STATE_WTSTART;
  202814:	f883 10b0 	strb.w	r1, [r3, #176]	; 0xb0
  REG_INSERT(tp);
  202818:	f8c2 c010 	str.w	ip, [r2, #16]
  tlp->next = (thread_t *)tlp;
  20281c:	f10c 0228 	add.w	r2, ip, #40	; 0x28
  tqp->next = (thread_t *)tqp;
  202820:	f8c3 e0bc 	str.w	lr, [r3, #188]	; 0xbc
  tlp->next = (thread_t *)tlp;
  202824:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
  tqp->prev = (thread_t *)tqp;
  202828:	f8c3 e0c0 	str.w	lr, [r3, #192]	; 0xc0
  tp->state     = CH_STATE_WTSTART;
  20282c:	9100      	str	r1, [sp, #0]
  REG_INSERT(tp);
  20282e:	f8c5 c014 	str.w	ip, [r5, #20]
  chSchWakeupS(tp, MSG_OK);
  202832:	f001 f83d 	bl	2038b0 <chSchWakeupS.constprop.40>
  202836:	f384 8811 	msr	BASEPRI, r4
  sdup->vmt = &vmt;
  20283a:	4ba5      	ldr	r3, [pc, #660]	; (202ad0 <main+0x750>)
  obqp->notify    = onfy;
  20283c:	4aa5      	ldr	r2, [pc, #660]	; (202ad4 <main+0x754>)
  20283e:	469e      	mov	lr, r3
  obqp->btop      = bp + ((size + sizeof (size_t)) * n);
  202840:	f203 4c8c 	addw	ip, r3, #1164	; 0x48c
  obqp->notify    = onfy;
  202844:	675a      	str	r2, [r3, #116]	; 0x74
  202846:	4aa4      	ldr	r2, [pc, #656]	; (202ad8 <main+0x758>)
  ibqp->notify    = infy;
  202848:	48a4      	ldr	r0, [pc, #656]	; (202adc <main+0x75c>)
  20284a:	f84e 2b04 	str.w	r2, [lr], #4
  ibqp->brdptr    = bp;
  20284e:	f103 027c 	add.w	r2, r3, #124	; 0x7c
  ibqp->bn        = n;
  202852:	9900      	ldr	r1, [sp, #0]
  sdup->state = SDU_STOP;
  202854:	f883 b008 	strb.w	fp, [r3, #8]
  ibqp->suspended = suspended;
  202858:	f883 b014 	strb.w	fp, [r3, #20]
  obqp->suspended = suspended;
  20285c:	f883 b04c 	strb.w	fp, [r3, #76]	; 0x4c
  tqp->next = (thread_t *)tqp;
  202860:	f103 0b0c 	add.w	fp, r3, #12
  ibqp->notify    = infy;
  202864:	63d8      	str	r0, [r3, #60]	; 0x3c
  ibqp->btop      = bp + ((size + sizeof (size_t)) * n);
  202866:	f503 7021 	add.w	r0, r3, #644	; 0x284
  obqp->btop      = bp + ((size + sizeof (size_t)) * n);
  20286a:	f8c3 c05c 	str.w	ip, [r3, #92]	; 0x5c
  20286e:	f103 0c44 	add.w	ip, r3, #68	; 0x44
  ibqp->brdptr    = bp;
  202872:	621a      	str	r2, [r3, #32]
  ibqp->bwrptr    = bp;
  202874:	61da      	str	r2, [r3, #28]
  ibqp->buffers   = bp;
  202876:	631a      	str	r2, [r3, #48]	; 0x30
  ibqp->bsize     = size + sizeof (size_t);
  202878:	f44f 7282 	mov.w	r2, #260	; 0x104
  ibqp->bcounter  = 0;
  20287c:	619c      	str	r4, [r3, #24]
  ibqp->bsize     = size + sizeof (size_t);
  20287e:	629a      	str	r2, [r3, #40]	; 0x28
  obqp->bsize     = size + sizeof (size_t);
  202880:	661a      	str	r2, [r3, #96]	; 0x60
  202882:	2220      	movs	r2, #32
  ibqp->bn        = n;
  202884:	62d9      	str	r1, [r3, #44]	; 0x2c
  ibqp->ptr       = NULL;
  202886:	635c      	str	r4, [r3, #52]	; 0x34
  ibqp->top       = NULL;
  202888:	639c      	str	r4, [r3, #56]	; 0x38
  obqp->bcounter  = n;
  20288a:	6519      	str	r1, [r3, #80]	; 0x50
  obqp->bn        = n;
  20288c:	6659      	str	r1, [r3, #100]	; 0x64
  obqp->ptr       = NULL;
  20288e:	66dc      	str	r4, [r3, #108]	; 0x6c
  obqp->top       = NULL;
  202890:	671c      	str	r4, [r3, #112]	; 0x70
  ibqp->link      = link;
  202892:	641b      	str	r3, [r3, #64]	; 0x40
  obqp->link      = link;
  202894:	679b      	str	r3, [r3, #120]	; 0x78
  202896:	f8c3 b00c 	str.w	fp, [r3, #12]
  tqp->prev = (thread_t *)tqp;
  20289a:	f8c3 b010 	str.w	fp, [r3, #16]
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->next = (event_listener_t *)esp;
  20289e:	f8c3 e004 	str.w	lr, [r3, #4]
  ibqp->btop      = bp + ((size + sizeof (size_t)) * n);
  2028a2:	6258      	str	r0, [r3, #36]	; 0x24
  obqp->brdptr    = bp;
  2028a4:	6598      	str	r0, [r3, #88]	; 0x58
  obqp->bwrptr    = bp;
  2028a6:	6558      	str	r0, [r3, #84]	; 0x54
  obqp->buffers   = bp;
  2028a8:	6698      	str	r0, [r3, #104]	; 0x68
  tqp->next = (thread_t *)tqp;
  2028aa:	f8c3 c044 	str.w	ip, [r3, #68]	; 0x44
  tqp->prev = (thread_t *)tqp;
  2028ae:	f8c3 c048 	str.w	ip, [r3, #72]	; 0x48
  2028b2:	f382 8811 	msr	BASEPRI, r2
  sdup->config = config;
  2028b6:	488a      	ldr	r0, [pc, #552]	; (202ae0 <main+0x760>)
  usbp->in_params[config->bulk_in - 1U]   = sdup;
  2028b8:	6273      	str	r3, [r6, #36]	; 0x24
  usbp->out_params[config->bulk_out - 1U] = sdup;
  2028ba:	63b3      	str	r3, [r6, #56]	; 0x38
    usbp->in_params[config->int_in - 1U]  = sdup;
  2028bc:	62b3      	str	r3, [r6, #40]	; 0x28
  sdup->state = SDU_READY;
  2028be:	7219      	strb	r1, [r3, #8]
  sdup->config = config;
  2028c0:	f8c3 048c 	str.w	r0, [r3, #1164]	; 0x48c
  2028c4:	f384 8811 	msr	BASEPRI, r4
    /*
     * Activates the USB driver and then the USB bus pull-up on D+.
     * Note, a delay is inserted in order to not have to disconnect the cable
     * after a reset.
     */
    usbDisconnectBus(serusbcfg.usbp);
  2028c8:	6ef1      	ldr	r1, [r6, #108]	; 0x6c
    chThdSleepMilliseconds(1000);
  2028ca:	f242 7010 	movw	r0, #10000	; 0x2710
    usbDisconnectBus(serusbcfg.usbp);
  2028ce:	f8d1 3804 	ldr.w	r3, [r1, #2052]	; 0x804
  2028d2:	f043 0302 	orr.w	r3, r3, #2
  2028d6:	f8c1 3804 	str.w	r3, [r1, #2052]	; 0x804
    chThdSleepMilliseconds(1000);
  2028da:	f7fe fd01 	bl	2012e0 <chThdSleep>
  2028de:	2320      	movs	r3, #32
  2028e0:	f383 8811 	msr	BASEPRI, r3
  if (usbp->state == USB_STOP) {
  2028e4:	7832      	ldrb	r2, [r6, #0]
  usbp->config = config;
  2028e6:	4b7f      	ldr	r3, [pc, #508]	; (202ae4 <main+0x764>)
  2028e8:	2a01      	cmp	r2, #1
  2028ea:	9200      	str	r2, [sp, #0]
    usbp->epc[i] = NULL;
  2028ec:	60f4      	str	r4, [r6, #12]
  2028ee:	6134      	str	r4, [r6, #16]
  2028f0:	6174      	str	r4, [r6, #20]
  2028f2:	61b4      	str	r4, [r6, #24]
  2028f4:	61f4      	str	r4, [r6, #28]
  2028f6:	6234      	str	r4, [r6, #32]
  usbp->config = config;
  2028f8:	6073      	str	r3, [r6, #4]
  stm32_otg_t *otgp = usbp->otg;
  2028fa:	f8d6 b06c 	ldr.w	fp, [r6, #108]	; 0x6c
  if (usbp->state == USB_STOP) {
  2028fe:	9a01      	ldr	r2, [sp, #4]
  202900:	f000 8110 	beq.w	202b24 <main+0x7a4>
  usbp->state = USB_READY;
  202904:	f04f 0a02 	mov.w	sl, #2
  202908:	2400      	movs	r4, #0
  20290a:	f886 a000 	strb.w	sl, [r6]
  20290e:	f384 8811 	msr	BASEPRI, r4
    usbStart(serusbcfg.usbp, &usbcfg);
    usbConnectBus(serusbcfg.usbp);
  202912:	6ef2      	ldr	r2, [r6, #108]	; 0x6c

      /*
      * Setting up analog inputs used by the demo.
      */
     //settings from F4 ipv F7!!!!   ->					memory layout
     palSetPadMode(GPIOA, 0, PAL_MODE_INPUT_ANALOG); //samples[0+i*3]
  202914:	2001      	movs	r0, #1
  202916:	2620      	movs	r6, #32
    usbConnectBus(serusbcfg.usbp);
  202918:	f8d2 3804 	ldr.w	r3, [r2, #2052]	; 0x804
  20291c:	f023 0302 	bic.w	r3, r3, #2
  202920:	f8c2 3804 	str.w	r3, [r2, #2052]	; 0x804
     palSetPadMode(GPIOA, 0, PAL_MODE_INPUT_ANALOG); //samples[0+i*3]
  202924:	f000 fffc 	bl	203920 <_pal_lld_setgroupmode.constprop.9>
     palSetPadMode(GPIOA, 1, PAL_MODE_INPUT_ANALOG); //samples[1+i*3]
  202928:	4650      	mov	r0, sl
  20292a:	f000 fff9 	bl	203920 <_pal_lld_setgroupmode.constprop.9>
     palSetPadMode(GPIOA, 2, PAL_MODE_INPUT_ANALOG); //samples[2+i*3]
  20292e:	2004      	movs	r0, #4
  202930:	f000 fff6 	bl	203920 <_pal_lld_setgroupmode.constprop.9>
  202934:	f386 8811 	msr	BASEPRI, r6
  tp->wabase = (stkalign_t *)wsp;
  202938:	4b6b      	ldr	r3, [pc, #428]	; (202ae8 <main+0x768>)
  tp->refs      = (trefs_t)1;
  20293a:	f04f 0e01 	mov.w	lr, #1
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
  20293e:	496b      	ldr	r1, [pc, #428]	; (202aec <main+0x76c>)
  tp->prio      = prio;
  202940:	2080      	movs	r0, #128	; 0x80
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
  202942:	f103 0cdc 	add.w	ip, r3, #220	; 0xdc
  tp->refs      = (trefs_t)1;
  202946:	f883 e122 	strb.w	lr, [r3, #290]	; 0x122
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
  20294a:	4a60      	ldr	r2, [pc, #384]	; (202acc <main+0x74c>)
  tp->name      = name;
  20294c:	f8df e1c4 	ldr.w	lr, [pc, #452]	; 202b14 <main+0x794>
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
  202950:	f8c3 20fc 	str.w	r2, [r3, #252]	; 0xfc
  REG_INSERT(tp);
  202954:	f503 7280 	add.w	r2, r3, #256	; 0x100
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
  202958:	f8c3 c10c 	str.w	ip, [r3, #268]	; 0x10c
  tlp->next = (thread_t *)tlp;
  20295c:	f503 7c94 	add.w	ip, r3, #296	; 0x128
  202960:	f8c3 10dc 	str.w	r1, [r3, #220]	; 0xdc
  tqp->next = (thread_t *)tqp;
  202964:	f503 7196 	add.w	r1, r3, #300	; 0x12c
  tp->name      = name;
  202968:	f8c3 e118 	str.w	lr, [r3, #280]	; 0x118
  REG_INSERT(tp);
  20296c:	f8d5 e014 	ldr.w	lr, [r5, #20]
  tp->prio      = prio;
  202970:	f8c3 0108 	str.w	r0, [r3, #264]	; 0x108
  tp->realprio  = prio;
  202974:	f8c3 013c 	str.w	r0, [r3, #316]	; 0x13c
  chSchWakeupS(tp, MSG_OK);
  202978:	4610      	mov	r0, r2
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
  20297a:	f8c3 40e0 	str.w	r4, [r3, #224]	; 0xe0
  tp->state     = CH_STATE_WTSTART;
  20297e:	f883 a120 	strb.w	sl, [r3, #288]	; 0x120
  tp->flags     = CH_FLAG_MODE_STATIC;
  202982:	f883 4121 	strb.w	r4, [r3, #289]	; 0x121
  tp->mtxlist   = NULL;
  202986:	f8c3 4138 	str.w	r4, [r3, #312]	; 0x138
  tp->epending  = (eventmask_t)0;
  20298a:	f8c3 4134 	str.w	r4, [r3, #308]	; 0x134
  REG_INSERT(tp);
  20298e:	f8c3 5110 	str.w	r5, [r3, #272]	; 0x110
  tp->wabase = (stkalign_t *)wsp;
  202992:	f8c3 311c 	str.w	r3, [r3, #284]	; 0x11c
  REG_INSERT(tp);
  202996:	f8c3 e114 	str.w	lr, [r3, #276]	; 0x114
  20299a:	f8ce 2010 	str.w	r2, [lr, #16]
  tlp->next = (thread_t *)tlp;
  20299e:	f8c3 c128 	str.w	ip, [r3, #296]	; 0x128
  tqp->next = (thread_t *)tqp;
  2029a2:	f8c3 112c 	str.w	r1, [r3, #300]	; 0x12c
  tqp->prev = (thread_t *)tqp;
  2029a6:	f8c3 1130 	str.w	r1, [r3, #304]	; 0x130
  2029aa:	616a      	str	r2, [r5, #20]
  chSchWakeupS(tp, MSG_OK);
  2029ac:	f000 ff80 	bl	2038b0 <chSchWakeupS.constprop.40>
  2029b0:	f384 8811 	msr	BASEPRI, r4
  2029b4:	f386 8811 	msr	BASEPRI, r6
 */
void adc_multi_lld_start(void) {
  ADCDriver *adcp = &ADCD1;

  /* If in stopped state then enables the ADC and DMA clocks.*/
  if (adcp->state == ADC_STOP) {
  2029b8:	783b      	ldrb	r3, [r7, #0]
  2029ba:	2b01      	cmp	r3, #1
  2029bc:	f000 8127 	beq.w	202c0e <main+0x88e>

  chSysLock();
  /*chDbgAssert((adcp->state == ADC_STOP) || (adcp->state == ADC_READY),
              "adcStart(), #1", "invalid state");*/
  adc_multi_lld_start();
  adcp->state = ADC_READY;
  2029c0:	2202      	movs	r2, #2
  2029c2:	2300      	movs	r3, #0
  2029c4:	703a      	strb	r2, [r7, #0]
  ADCD2.state = ADC_READY;
  2029c6:	f889 2000 	strb.w	r2, [r9]
  ADCD3.state = ADC_READY;
  2029ca:	f888 2000 	strb.w	r2, [r8]
  2029ce:	f383 8811 	msr	BASEPRI, r3
  2029d2:	2220      	movs	r2, #32
  2029d4:	f382 8811 	msr	BASEPRI, r2
                        adcsample_t *samples,
                        size_t depth) {

  chSysLock();
  // Multi-DMA mode tuning
  ADC->CCR |= ADC_CCR_DMA_0 | ADC_CCR_DDS \
  2029d8:	4d45      	ldr	r5, [pc, #276]	; (202af0 <main+0x770>)
  2029da:	f246 0016 	movw	r0, #24598	; 0x6016
              | (ADC_CCR_MULTI_TRIPLE | ADC_CCR_MULTI_REGULAR_SIMUL);
  // DMA Mode 1
  // Triple mode: ADC1, 2 and 3 working together
  // 10110: Regular simultaneous mode only

  ADCD2.grpp = grpp2;
  2029de:	4e45      	ldr	r6, [pc, #276]	; (202af4 <main+0x774>)
  ADCD2.state    = ADC_ACTIVE;
  2029e0:	2103      	movs	r1, #3
  ADC->CCR |= ADC_CCR_DMA_0 | ADC_CCR_DDS \
  2029e2:	686a      	ldr	r2, [r5, #4]
  /* ADC setup.*/
  ADCD2.adc->SR    = 0;
  ADCD2.adc->SMPR1 = grpp2->smpr1;
  ADCD2.adc->SMPR2 = grpp2->smpr2;
  ADCD2.adc->SQR1  = grpp2->sqr1;
  2029e4:	f44f 1480 	mov.w	r4, #1048576	; 0x100000
  ADCD2.grpp = grpp2;
  2029e8:	f8c9 6010 	str.w	r6, [r9, #16]
  ADCD2.adc->SQR2  = grpp2->sqr2;
  ADCD2.adc->SQR3  = grpp2->sqr3;
  2029ec:	f240 1e41 	movw	lr, #321	; 0x141
  ADC->CCR |= ADC_CCR_DMA_0 | ADC_CCR_DDS \
  2029f0:	4310      	orrs	r0, r2
  ADCD2.adc->CR1   = grpp2->cr1 | ADC_CR1_OVRIE | ADC_CR1_SCAN;
  2029f2:	4e41      	ldr	r6, [pc, #260]	; (202af8 <main+0x778>)
  ADCD2.adc->SR    = 0;
  2029f4:	f8d9 2028 	ldr.w	r2, [r9, #40]	; 0x28
  ADCD3.adc->SR    = 0;
  ADCD3.adc->SMPR1 = grpp3->smpr1;
  ADCD3.adc->SMPR2 = grpp3->smpr2;
  ADCD3.adc->SQR1  = grpp3->sqr1;
  ADCD3.adc->SQR2  = grpp3->sqr2;
  ADCD3.adc->SQR3  = grpp3->sqr3;
  2029f8:	f44f 7cb1 	mov.w	ip, #354	; 0x162
  ADC->CCR |= ADC_CCR_DMA_0 | ADC_CCR_DDS \
  2029fc:	6068      	str	r0, [r5, #4]
  ADCD3.grpp = grpp3;
  2029fe:	483f      	ldr	r0, [pc, #252]	; (202afc <main+0x77c>)
  mode = adcp->dmamode;
  202a00:	6b3d      	ldr	r5, [r7, #48]	; 0x30
  ADCD2.state    = ADC_ACTIVE;
  202a02:	f889 1000 	strb.w	r1, [r9]
  adcp->depth    = depth;
  202a06:	f04f 090c 	mov.w	r9, #12
  ADCD2.adc->SR    = 0;
  202a0a:	6013      	str	r3, [r2, #0]
      mode |= STM32_DMA_CR_HTIE;
  202a0c:	f445 7584 	orr.w	r5, r5, #264	; 0x108
  ADCD2.adc->SMPR1 = grpp2->smpr1;
  202a10:	60d3      	str	r3, [r2, #12]
  ADCD2.adc->SMPR2 = grpp2->smpr2;
  202a12:	6113      	str	r3, [r2, #16]
  ADCD2.adc->SQR1  = grpp2->sqr1;
  202a14:	62d4      	str	r4, [r2, #44]	; 0x2c
  ADCD2.adc->SQR2  = grpp2->sqr2;
  202a16:	6313      	str	r3, [r2, #48]	; 0x30
  ADCD2.adc->SQR3  = grpp2->sqr3;
  202a18:	f8c2 e034 	str.w	lr, [r2, #52]	; 0x34
  dmaStreamSetTransactionSize(adcp->dmastp, (uint32_t)grpp->num_channels *
  202a1c:	f04f 0e18 	mov.w	lr, #24
  ADCD2.adc->CR1   = grpp2->cr1 | ADC_CR1_OVRIE | ADC_CR1_SCAN;
  202a20:	6056      	str	r6, [r2, #4]
  ADCD2.adc->CR2   = grpp2->cr2 | ADC_CR2_CONT  | ADC_CR2_ADON;
  202a22:	6091      	str	r1, [r2, #8]
  ADCD3.adc->SR    = 0;
  202a24:	f8d8 2028 	ldr.w	r2, [r8, #40]	; 0x28
  ADCD3.grpp = grpp3;
  202a28:	f8c8 0010 	str.w	r0, [r8, #16]
  dmaStreamSetMemory0(adcp->dmastp, adcp->samples);
  202a2c:	6af8      	ldr	r0, [r7, #44]	; 0x2c
  ADCD3.state    = ADC_ACTIVE;
  202a2e:	f888 1000 	strb.w	r1, [r8]
  ADCD3.adc->SR    = 0;
  202a32:	6013      	str	r3, [r2, #0]
  adcp->state    = ADC_ACTIVE;
  202a34:	7039      	strb	r1, [r7, #0]
  dmaStreamSetMemory0(adcp->dmastp, adcp->samples);
  202a36:	6800      	ldr	r0, [r0, #0]
  ADCD3.adc->SMPR1 = grpp3->smpr1;
  202a38:	60d3      	str	r3, [r2, #12]
  ADCD3.adc->SMPR2 = grpp3->smpr2;
  202a3a:	6113      	str	r3, [r2, #16]
  ADCD3.adc->SQR1  = grpp3->sqr1;
  202a3c:	62d4      	str	r4, [r2, #44]	; 0x2c
  ADCD3.adc->SQR2  = grpp3->sqr2;
  202a3e:	6313      	str	r3, [r2, #48]	; 0x30
  ADCD3.adc->SQR3  = grpp3->sqr3;
  202a40:	f8c2 c034 	str.w	ip, [r2, #52]	; 0x34
  adcp->adc->SQR3  = grpp->sqr3;
  202a44:	f04f 0c60 	mov.w	ip, #96	; 0x60
  ADCD3.adc->CR1   = grpp3->cr1 | ADC_CR1_OVRIE | ADC_CR1_SCAN;
  202a48:	6056      	str	r6, [r2, #4]
  ADCD3.adc->CR2   = grpp3->cr2 | ADC_CR2_CONT  | ADC_CR2_ADON;
  202a4a:	6091      	str	r1, [r2, #8]
  adcp->samples  = samples;
  202a4c:	4e2c      	ldr	r6, [pc, #176]	; (202b00 <main+0x780>)
  adcp->grpp     = grpp;
  202a4e:	4a2d      	ldr	r2, [pc, #180]	; (202b04 <main+0x784>)
  adcp->depth    = depth;
  202a50:	f8c7 900c 	str.w	r9, [r7, #12]
  adcp->grpp     = grpp;
  202a54:	613a      	str	r2, [r7, #16]
  adcp->samples  = samples;
  202a56:	60be      	str	r6, [r7, #8]
  dmaStreamSetMemory0(adcp->dmastp, adcp->samples);
  202a58:	60c6      	str	r6, [r0, #12]
  dmaStreamSetTransactionSize(adcp->dmastp, (uint32_t)grpp->num_channels *
  202a5a:	f8c0 e004 	str.w	lr, [r0, #4]
  dmaStreamSetMode(adcp->dmastp, mode);
  202a5e:	6005      	str	r5, [r0, #0]
  dmaStreamEnable(adcp->dmastp);
  202a60:	6805      	ldr	r5, [r0, #0]
  adcp->adc->SR    = 0;
  202a62:	6aba      	ldr	r2, [r7, #40]	; 0x28
  dmaStreamEnable(adcp->dmastp);
  202a64:	f045 0501 	orr.w	r5, r5, #1
  202a68:	6005      	str	r5, [r0, #0]
  adcp->adc->SR    = 0;
  202a6a:	6013      	str	r3, [r2, #0]
  adcp->adc->SMPR1 = grpp->smpr1;
  202a6c:	60d3      	str	r3, [r2, #12]
  adcp->adc->SMPR2 = grpp->smpr2;
  202a6e:	6113      	str	r3, [r2, #16]
  adcp->adc->SQR1  = grpp->sqr1;
  202a70:	62d4      	str	r4, [r2, #44]	; 0x2c
  adcp->adc->SQR2  = grpp->sqr2;
  202a72:	6313      	str	r3, [r2, #48]	; 0x30
  adcp->adc->SQR3  = grpp->sqr3;
  202a74:	f8c2 c034 	str.w	ip, [r2, #52]	; 0x34
    adcp->adc->CR2 = (grpp->cr2 & ~ADC_CR2_SWSTART) | ADC_CR2_ADON | ADC_CR2_CONT;
  202a78:	6091      	str	r1, [r2, #8]
    adcp->adc->CR2 |= ADC_CR2_SWSTART;
  202a7a:	6891      	ldr	r1, [r2, #8]
  202a7c:	f041 4180 	orr.w	r1, r1, #1073741824	; 0x40000000
  202a80:	6091      	str	r1, [r2, #8]
  202a82:	f383 8811 	msr	BASEPRI, r3
  202a86:	f8df a090 	ldr.w	sl, [pc, #144]	; 202b18 <main+0x798>
  202a8a:	368e      	adds	r6, #142	; 0x8e
  202a8c:	f8df 908c 	ldr.w	r9, [pc, #140]	; 202b1c <main+0x79c>
  //int u=0;
  while (true) {
	  chThdSleepMilliseconds(10);
	  //chprintf(chp, "\r\n(%8u,%8u): [%4u,%4u,%4u,%4u]\r\n", nx, ny, samples[0],samples[3],samples[6],samples[9]);

	  	chprintf(chp, "\r\n(%8u,%4u): ", nx, avg_PC1);
  202a90:	f8df 808c 	ldr.w	r8, [pc, #140]	; 202b20 <main+0x7a0>
  202a94:	4d0e      	ldr	r5, [pc, #56]	; (202ad0 <main+0x750>)
	    for (n = 0; n < ADC_GRP1_NUM_CHANNELS_PER_ADC * ADC_N_ADCS * ADC_GRP1_BUF_DEPTH; n++) {
	       chprintf(chp, "%4u,", samples[n]);
  202a96:	4f1c      	ldr	r7, [pc, #112]	; (202b08 <main+0x788>)
	  chThdSleepMilliseconds(10);
  202a98:	2064      	movs	r0, #100	; 0x64
  202a9a:	4c1c      	ldr	r4, [pc, #112]	; (202b0c <main+0x78c>)
  202a9c:	f7fe fc20 	bl	2012e0 <chThdSleep>
	  	chprintf(chp, "\r\n(%8u,%4u): ", nx, avg_PC1);
  202aa0:	f8ba 3000 	ldrh.w	r3, [sl]
  202aa4:	f8d9 2000 	ldr.w	r2, [r9]
  202aa8:	4641      	mov	r1, r8
  202aaa:	4628      	mov	r0, r5
  202aac:	f000 fad8 	bl	203060 <chprintf>
	       chprintf(chp, "%4u,", samples[n]);
  202ab0:	f834 2f02 	ldrh.w	r2, [r4, #2]!
  202ab4:	4639      	mov	r1, r7
  202ab6:	4628      	mov	r0, r5
  202ab8:	f000 fad2 	bl	203060 <chprintf>
	    for (n = 0; n < ADC_GRP1_NUM_CHANNELS_PER_ADC * ADC_N_ADCS * ADC_GRP1_BUF_DEPTH; n++) {
  202abc:	42b4      	cmp	r4, r6
  202abe:	d1f7      	bne.n	202ab0 <main+0x730>
  202ac0:	e7ea      	b.n	202a98 <main+0x718>
  202ac2:	bf00      	nop
  202ac4:	20000e90 	.word	0x20000e90
  202ac8:	08003dc4 	.word	0x08003dc4
  202acc:	002002f1 	.word	0x002002f1
  202ad0:	200008b4 	.word	0x200008b4
  202ad4:	00200fe1 	.word	0x00200fe1
  202ad8:	08003e04 	.word	0x08003e04
  202adc:	00200fb1 	.word	0x00200fb1
  202ae0:	08003dec 	.word	0x08003dec
  202ae4:	08003df4 	.word	0x08003df4
  202ae8:	200010a8 	.word	0x200010a8
  202aec:	00202321 	.word	0x00202321
  202af0:	40012300 	.word	0x40012300
  202af4:	08003d50 	.word	0x08003d50
  202af8:	04000100 	.word	0x04000100
  202afc:	08003d78 	.word	0x08003d78
  202b00:	20001014 	.word	0x20001014
  202b04:	08003d28 	.word	0x08003d28
  202b08:	08003de4 	.word	0x08003de4
  202b0c:	20001012 	.word	0x20001012
  202b10:	002004a1 	.word	0x002004a1
  202b14:	08003dcc 	.word	0x08003dcc
  202b18:	20000e44 	.word	0x20000e44
  202b1c:	20001010 	.word	0x20001010
  202b20:	08003dd4 	.word	0x08003dd4
      rccEnableOTG_FS(true);
  202b24:	f8da 3034 	ldr.w	r3, [sl, #52]	; 0x34
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  202b28:	2108      	movs	r1, #8
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  202b2a:	f04f 0ce0 	mov.w	ip, #224	; 0xe0
    otgp->GOTGCTL = GOTGCTL_BVALOEN | GOTGCTL_BVALOVAL;
  202b2e:	f04f 0ec0 	mov.w	lr, #192	; 0xc0
      rccEnableOTG_FS(true);
  202b32:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  chSysPolledDelayX(cycles);
  202b36:	2020      	movs	r0, #32
  202b38:	f8ca 3034 	str.w	r3, [sl, #52]	; 0x34
  202b3c:	f8da 3054 	ldr.w	r3, [sl, #84]	; 0x54
  202b40:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  202b44:	f8ca 3054 	str.w	r3, [sl, #84]	; 0x54
      rccResetOTG_FS();
  202b48:	f8da 3014 	ldr.w	r3, [sl, #20]
  202b4c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  202b50:	f8ca 3014 	str.w	r3, [sl, #20]
    otgp->GCCFG = GCCFG_INIT_VALUE;
  202b54:	f44f 1304 	mov.w	r3, #2162688	; 0x210000
      rccResetOTG_FS();
  202b58:	f8ca 4014 	str.w	r4, [sl, #20]
  202b5c:	f882 c343 	strb.w	ip, [r2, #835]	; 0x343
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  202b60:	f8c2 1188 	str.w	r1, [r2, #392]	; 0x188
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  202b64:	6091      	str	r1, [r2, #8]
      otgp->DCFG = 0x02200000 | DCFG_DSPD_FS11;
  202b66:	4a6d      	ldr	r2, [pc, #436]	; (202d1c <main+0x99c>)
      otgp->GUSBCFG = GUSBCFG_FDMOD | GUSBCFG_TRDT(TRDT_VALUE_FS) |
  202b68:	496d      	ldr	r1, [pc, #436]	; (202d20 <main+0x9a0>)
  202b6a:	f8cb 100c 	str.w	r1, [fp, #12]
      otgp->DCFG = 0x02200000 | DCFG_DSPD_FS11;
  202b6e:	f8cb 2800 	str.w	r2, [fp, #2048]	; 0x800
    otgp->PCGCCTL = 0;
  202b72:	f8cb 4e00 	str.w	r4, [fp, #3584]	; 0xe00
    otgp->GOTGCTL = GOTGCTL_BVALOEN | GOTGCTL_BVALOVAL;
  202b76:	f8cb e000 	str.w	lr, [fp]
    otgp->GCCFG = GCCFG_INIT_VALUE;
  202b7a:	f8cb 3038 	str.w	r3, [fp, #56]	; 0x38
  202b7e:	f7fe fc07 	bl	201390 <chSysPolledDelayX>
  otgp->GRSTCTL = GRSTCTL_CSRST;
  202b82:	9b00      	ldr	r3, [sp, #0]
  202b84:	f8cb 3010 	str.w	r3, [fp, #16]
  while ((otgp->GRSTCTL & GRSTCTL_CSRST) != 0)
  202b88:	f8db 4010 	ldr.w	r4, [fp, #16]
  202b8c:	f014 0401 	ands.w	r4, r4, #1
  202b90:	d1fa      	bne.n	202b88 <main+0x808>
  202b92:	2012      	movs	r0, #18
  202b94:	f7fe fbfc 	bl	201390 <chSysPolledDelayX>
  while ((otgp->GRSTCTL & GRSTCTL_AHBIDL) == 0)
  202b98:	f8db 3010 	ldr.w	r3, [fp, #16]
  202b9c:	2b00      	cmp	r3, #0
  202b9e:	dafb      	bge.n	202b98 <main+0x818>
    otgp->GAHBCFG = 0;
  202ba0:	2000      	movs	r0, #0
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
  202ba2:	6f33      	ldr	r3, [r6, #112]	; 0x70
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
  202ba4:	f04f 3eff 	mov.w	lr, #4294967295
  202ba8:	6ef1      	ldr	r1, [r6, #108]	; 0x6c
    otgp->ie[i].DIEPCTL = 0;
  202baa:	4602      	mov	r2, r0
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
  202bac:	689b      	ldr	r3, [r3, #8]
    otgp->GAHBCFG = 0;
  202bae:	f8cb 0008 	str.w	r0, [fp, #8]
  202bb2:	eb01 1044 	add.w	r0, r1, r4, lsl #5
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
  202bb6:	3401      	adds	r4, #1
  202bb8:	42a3      	cmp	r3, r4
    otgp->ie[i].DIEPCTL = 0;
  202bba:	f8c0 2900 	str.w	r2, [r0, #2304]	; 0x900
    otgp->ie[i].DIEPTSIZ = 0;
  202bbe:	f8c0 2910 	str.w	r2, [r0, #2320]	; 0x910
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
  202bc2:	f8c0 e908 	str.w	lr, [r0, #2312]	; 0x908
    otgp->oe[i].DOEPCTL = 0;
  202bc6:	f8c0 2b00 	str.w	r2, [r0, #2816]	; 0xb00
    otgp->oe[i].DOEPTSIZ = 0;
  202bca:	f8c0 2b10 	str.w	r2, [r0, #2832]	; 0xb10
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
  202bce:	f8c0 eb08 	str.w	lr, [r0, #2824]	; 0xb08
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
  202bd2:	d2ee      	bcs.n	202bb2 <main+0x832>
    if (usbp->config->sof_cb == NULL)
  202bd4:	6873      	ldr	r3, [r6, #4]
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
  202bd6:	f04f 1001 	mov.w	r0, #65537	; 0x10001
    if (usbp->config->sof_cb == NULL)
  202bda:	68db      	ldr	r3, [r3, #12]
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
  202bdc:	f8c1 081c 	str.w	r0, [r1, #2076]	; 0x81c
    otgp->DIEPMSK  = 0;
  202be0:	f8cb 2810 	str.w	r2, [fp, #2064]	; 0x810
    otgp->DOEPMSK  = 0;
  202be4:	f8cb 2814 	str.w	r2, [fp, #2068]	; 0x814
    otgp->DAINTMSK = 0;
  202be8:	f8cb 281c 	str.w	r2, [fp, #2076]	; 0x81c
    if (usbp->config->sof_cb == NULL)
  202bec:	2b00      	cmp	r3, #0
  202bee:	f000 8091 	beq.w	202d14 <main+0x994>
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM | GINTMSK_USBSUSPM |
  202bf2:	4b4c      	ldr	r3, [pc, #304]	; (202d24 <main+0x9a4>)
  202bf4:	f8cb 3018 	str.w	r3, [fp, #24]
    otgp->GINTSTS  = 0xFFFFFFFF;
  202bf8:	f04f 33ff 	mov.w	r3, #4294967295
  202bfc:	f8cb 3014 	str.w	r3, [fp, #20]
    otgp->GAHBCFG |= GAHBCFG_GINTMSK;
  202c00:	f8db 3008 	ldr.w	r3, [fp, #8]
  202c04:	f043 0301 	orr.w	r3, r3, #1
  202c08:	f8cb 3008 	str.w	r3, [fp, #8]
  202c0c:	e67a      	b.n	202904 <main+0x584>
                       void *param) {

  osalDbgCheck(dmastp != NULL);

  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
  202c0e:	4a46      	ldr	r2, [pc, #280]	; (202d28 <main+0x9a8>)
    dmaStreamAllocate(adcp->dmastp,
  202c10:	6af9      	ldr	r1, [r7, #44]	; 0x2c
  202c12:	6810      	ldr	r0, [r2, #0]
  202c14:	7a4a      	ldrb	r2, [r1, #9]
  202c16:	4093      	lsls	r3, r2
  202c18:	4203      	tst	r3, r0
  202c1a:	d147      	bne.n	202cac <main+0x92c>
    return true;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
  dma_isr_redir[dmastp->selfindex].dma_param = param;
  dma_streams_mask |= (1U << dmastp->selfindex);
  202c1c:	4303      	orrs	r3, r0
  202c1e:	4d42      	ldr	r5, [pc, #264]	; (202d28 <main+0x9a8>)
  dma_isr_redir[dmastp->selfindex].dma_param = param;
  202c20:	4842      	ldr	r0, [pc, #264]	; (202d2c <main+0x9ac>)
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
  202c22:	4c43      	ldr	r4, [pc, #268]	; (202d30 <main+0x9b0>)

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) != 0U) {
  202c24:	f013 0fff 	tst.w	r3, #255	; 0xff
  dma_isr_redir[dmastp->selfindex].dma_param = param;
  202c28:	eb00 00c2 	add.w	r0, r0, r2, lsl #3
  dma_streams_mask |= (1U << dmastp->selfindex);
  202c2c:	602b      	str	r3, [r5, #0]
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
  202c2e:	4d3f      	ldr	r5, [pc, #252]	; (202d2c <main+0x9ac>)
  dma_isr_redir[dmastp->selfindex].dma_param = param;
  202c30:	6047      	str	r7, [r0, #4]
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
  202c32:	f845 4032 	str.w	r4, [r5, r2, lsl #3]
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) != 0U) {
  202c36:	d008      	beq.n	202c4a <main+0x8ca>
    rccEnableDMA1(true);
  202c38:	4a3e      	ldr	r2, [pc, #248]	; (202d34 <main+0x9b4>)
  202c3a:	6b10      	ldr	r0, [r2, #48]	; 0x30
  202c3c:	f440 1000 	orr.w	r0, r0, #2097152	; 0x200000
  202c40:	6310      	str	r0, [r2, #48]	; 0x30
  202c42:	6d10      	ldr	r0, [r2, #80]	; 0x50
  202c44:	f440 1000 	orr.w	r0, r0, #2097152	; 0x200000
  202c48:	6510      	str	r0, [r2, #80]	; 0x50
  }
  if ((dma_streams_mask & STM32_DMA2_STREAMS_MASK) != 0U) {
  202c4a:	f413 4f7f 	tst.w	r3, #65280	; 0xff00
  202c4e:	d008      	beq.n	202c62 <main+0x8e2>
    rccEnableDMA2(true);
  202c50:	4b38      	ldr	r3, [pc, #224]	; (202d34 <main+0x9b4>)
  202c52:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  202c54:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
  202c58:	631a      	str	r2, [r3, #48]	; 0x30
  202c5a:	6d1a      	ldr	r2, [r3, #80]	; 0x50
  202c5c:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
  202c60:	651a      	str	r2, [r3, #80]	; 0x50
  }

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
  202c62:	680a      	ldr	r2, [r1, #0]
  202c64:	6813      	ldr	r3, [r2, #0]
  202c66:	f023 031f 	bic.w	r3, r3, #31
  202c6a:	6013      	str	r3, [r2, #0]
  202c6c:	6813      	ldr	r3, [r2, #0]
  202c6e:	f013 0301 	ands.w	r3, r3, #1
  202c72:	d1fb      	bne.n	202c6c <main+0x8ec>
  202c74:	7a08      	ldrb	r0, [r1, #8]
  202c76:	263d      	movs	r6, #61	; 0x3d
  dmastp->stream->CR = STM32_DMA_CR_RESET_VALUE;
  dmastp->stream->FCR = STM32_DMA_FCR_RESET_VALUE;
  202c78:	2421      	movs	r4, #33	; 0x21
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  202c7a:	4d2f      	ldr	r5, [pc, #188]	; (202d38 <main+0x9b8>)
  dmaStreamDisable(dmastp);
  202c7c:	4086      	lsls	r6, r0
  202c7e:	6848      	ldr	r0, [r1, #4]
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  202c80:	f04f 0e01 	mov.w	lr, #1
  202c84:	6006      	str	r6, [r0, #0]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  202c86:	2660      	movs	r6, #96	; 0x60
  dmastp->stream->CR = STM32_DMA_CR_RESET_VALUE;
  202c88:	6013      	str	r3, [r2, #0]
  dmastp->stream->FCR = STM32_DMA_FCR_RESET_VALUE;
  202c8a:	6154      	str	r4, [r2, #20]

  /* Enables the associated IRQ vector if a callback is defined.*/
  if (func != NULL) {
    nvicEnableVector(dmastp->vector, priority);
  202c8c:	7a8b      	ldrb	r3, [r1, #10]
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  202c8e:	095c      	lsrs	r4, r3, #5
  202c90:	f003 011f 	and.w	r1, r3, #31
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  202c94:	442b      	add	r3, r5
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  202c96:	fa0e f101 	lsl.w	r1, lr, r1
  202c9a:	eb05 0084 	add.w	r0, r5, r4, lsl #2
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  202c9e:	f883 6300 	strb.w	r6, [r3, #768]	; 0x300
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  202ca2:	f8c0 1180 	str.w	r1, [r0, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  202ca6:	f845 1024 	str.w	r1, [r5, r4, lsl #2]
  202caa:	e000      	b.n	202cae <main+0x92e>
  202cac:	680a      	ldr	r2, [r1, #0]
    rccEnableADC1(FALSE);
  202cae:	4b21      	ldr	r3, [pc, #132]	; (202d34 <main+0x9b4>)
    adcp->adc->CR1 = 0;
  202cb0:	2100      	movs	r1, #0
    dmaStreamSetPeripheral(adcp->dmastp, &ADC->CDR);
  202cb2:	4c22      	ldr	r4, [pc, #136]	; (202d3c <main+0x9bc>)
    adcp->adc->CR2 = ADC_CR2_ADON;
  202cb4:	2001      	movs	r0, #1
    adcp->adc->CR1 = 0;
  202cb6:	6abd      	ldr	r5, [r7, #40]	; 0x28
    dmaStreamSetPeripheral(adcp->dmastp, &ADC->CDR);
  202cb8:	6094      	str	r4, [r2, #8]
    rccEnableADC1(FALSE);
  202cba:	6c5a      	ldr	r2, [r3, #68]	; 0x44
    ADC->CCR = (ADC->CCR & (ADC_CCR_TSVREFE | ADC_CCR_VBATE)) |
  202cbc:	4e20      	ldr	r6, [pc, #128]	; (202d40 <main+0x9c0>)
    rccEnableADC1(FALSE);
  202cbe:	f442 7280 	orr.w	r2, r2, #256	; 0x100
    adcp->adc->CR1 = 0;
  202cc2:	f8d9 4028 	ldr.w	r4, [r9, #40]	; 0x28
    rccEnableADC1(FALSE);
  202cc6:	645a      	str	r2, [r3, #68]	; 0x44
  202cc8:	6e5a      	ldr	r2, [r3, #100]	; 0x64
  202cca:	f422 7280 	bic.w	r2, r2, #256	; 0x100
  202cce:	665a      	str	r2, [r3, #100]	; 0x64
    rccEnableADC2(FALSE);
  202cd0:	6c5a      	ldr	r2, [r3, #68]	; 0x44
  202cd2:	f442 7200 	orr.w	r2, r2, #512	; 0x200
  202cd6:	645a      	str	r2, [r3, #68]	; 0x44
  202cd8:	6e5a      	ldr	r2, [r3, #100]	; 0x64
  202cda:	f422 7200 	bic.w	r2, r2, #512	; 0x200
  202cde:	665a      	str	r2, [r3, #100]	; 0x64
    rccEnableADC3(FALSE);
  202ce0:	6c5a      	ldr	r2, [r3, #68]	; 0x44
  202ce2:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
  202ce6:	645a      	str	r2, [r3, #68]	; 0x44
  202ce8:	6e5a      	ldr	r2, [r3, #100]	; 0x64
  202cea:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
  202cee:	665a      	str	r2, [r3, #100]	; 0x64
    ADC->CCR = (ADC->CCR & (ADC_CCR_TSVREFE | ADC_CCR_VBATE)) |
  202cf0:	6873      	ldr	r3, [r6, #4]
    adcp->adc->CR1 = 0;
  202cf2:	f8d8 2028 	ldr.w	r2, [r8, #40]	; 0x28
    ADC->CCR = (ADC->CCR & (ADC_CCR_TSVREFE | ADC_CCR_VBATE)) |
  202cf6:	f403 0340 	and.w	r3, r3, #12582912	; 0xc00000
  202cfa:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
  202cfe:	6073      	str	r3, [r6, #4]
    adcp->adc->CR1 = 0;
  202d00:	6069      	str	r1, [r5, #4]
    adcp->adc->CR2 = 0;
  202d02:	60a9      	str	r1, [r5, #8]
    adcp->adc->CR2 = ADC_CR2_ADON;
  202d04:	60a8      	str	r0, [r5, #8]
    adcp->adc->CR1 = 0;
  202d06:	6061      	str	r1, [r4, #4]
    adcp->adc->CR2 = 0;
  202d08:	60a1      	str	r1, [r4, #8]
    adcp->adc->CR2 = ADC_CR2_ADON;
  202d0a:	60a0      	str	r0, [r4, #8]
    adcp->adc->CR1 = 0;
  202d0c:	6051      	str	r1, [r2, #4]
    adcp->adc->CR2 = 0;
  202d0e:	6091      	str	r1, [r2, #8]
    adcp->adc->CR2 = ADC_CR2_ADON;
  202d10:	6090      	str	r0, [r2, #8]
  202d12:	e655      	b.n	2029c0 <main+0x640>
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM | GINTMSK_USBSUSPM |
  202d14:	4b0b      	ldr	r3, [pc, #44]	; (202d44 <main+0x9c4>)
  202d16:	f8cb 3018 	str.w	r3, [fp, #24]
  202d1a:	e76d      	b.n	202bf8 <main+0x878>
  202d1c:	02200003 	.word	0x02200003
  202d20:	40001440 	.word	0x40001440
  202d24:	c0303c08 	.word	0xc0303c08
  202d28:	2000100c 	.word	0x2000100c
  202d2c:	20000f8c 	.word	0x20000f8c
  202d30:	00202e11 	.word	0x00202e11
  202d34:	40023800 	.word	0x40023800
  202d38:	e000e100 	.word	0xe000e100
  202d3c:	40012308 	.word	0x40012308
  202d40:	40012300 	.word	0x40012300
  202d44:	c0303c00 	.word	0xc0303c00
	...

00202d50 <adcerrorcallback.lto_priv.49>:
  202d50:	4770      	bx	lr
  202d52:	bf00      	nop
	...

00202d60 <adccallback.lto_priv.48>:
  nz++;
  202d60:	4813      	ldr	r0, [pc, #76]	; (202db0 <adccallback.lto_priv.48+0x50>)
static void adccallback(ADCDriver *adcp, adcsample_t *buffer, size_t n) {
  202d62:	b430      	push	{r4, r5}
  nz++;
  202d64:	6803      	ldr	r3, [r0, #0]
  if (samples == buffer) { //compare pointers
  202d66:	4c13      	ldr	r4, [pc, #76]	; (202db4 <adccallback.lto_priv.48+0x54>)
  nz++;
  202d68:	3301      	adds	r3, #1
  if (samples == buffer) { //compare pointers
  202d6a:	42a1      	cmp	r1, r4
  nz++;
  202d6c:	6003      	str	r3, [r0, #0]
  if (samples == buffer) { //compare pointers
  202d6e:	d005      	beq.n	202d7c <adccallback.lto_priv.48+0x1c>
    ny += n;
  202d70:	4911      	ldr	r1, [pc, #68]	; (202db8 <adccallback.lto_priv.48+0x58>)
  202d72:	680b      	ldr	r3, [r1, #0]
  202d74:	4413      	add	r3, r2
}
  202d76:	bc30      	pop	{r4, r5}
    ny += n;
  202d78:	600b      	str	r3, [r1, #0]
}
  202d7a:	4770      	bx	lr
    nx += n; //n = ADC_GRP1_BUF_DEPTH / 2
  202d7c:	4d0f      	ldr	r5, [pc, #60]	; (202dbc <adccallback.lto_priv.48+0x5c>)
  202d7e:	2300      	movs	r3, #0
  202d80:	f101 0018 	add.w	r0, r1, #24
  202d84:	682c      	ldr	r4, [r5, #0]
  202d86:	4422      	add	r2, r4
  202d88:	602a      	str	r2, [r5, #0]
    for (n = 0; n < ADC_GRP1_BUF_DEPTH; n++) avg_PC1 += samples[n];
  202d8a:	f831 2b02 	ldrh.w	r2, [r1], #2
  202d8e:	4413      	add	r3, r2
  202d90:	4281      	cmp	r1, r0
  202d92:	b29b      	uxth	r3, r3
  202d94:	d1f9      	bne.n	202d8a <adccallback.lto_priv.48+0x2a>
    avg_PC1 /= ADC_GRP1_BUF_DEPTH;
  202d96:	4a0a      	ldr	r2, [pc, #40]	; (202dc0 <adccallback.lto_priv.48+0x60>)
  202d98:	490a      	ldr	r1, [pc, #40]	; (202dc4 <adccallback.lto_priv.48+0x64>)
  202d9a:	fba2 2303 	umull	r2, r3, r2, r3
    palToggleLine(LINE_LED3);
  202d9e:	4a0a      	ldr	r2, [pc, #40]	; (202dc8 <adccallback.lto_priv.48+0x68>)
    avg_PC1 /= ADC_GRP1_BUF_DEPTH;
  202da0:	08db      	lsrs	r3, r3, #3
  202da2:	800b      	strh	r3, [r1, #0]
    palToggleLine(LINE_LED3);
  202da4:	6953      	ldr	r3, [r2, #20]
  202da6:	f483 4380 	eor.w	r3, r3, #16384	; 0x4000
}
  202daa:	bc30      	pop	{r4, r5}
    palToggleLine(LINE_LED3);
  202dac:	6153      	str	r3, [r2, #20]
}
  202dae:	4770      	bx	lr
  202db0:	20001224 	.word	0x20001224
  202db4:	20001014 	.word	0x20001014
  202db8:	20001220 	.word	0x20001220
  202dbc:	20001010 	.word	0x20001010
  202dc0:	aaaaaaab 	.word	0xaaaaaaab
  202dc4:	20000e44 	.word	0x20000e44
  202dc8:	40020400 	.word	0x40020400
  202dcc:	00000000 	.word	0x00000000

00202dd0 <get_descriptor.lto_priv.46>:
                                           uint8_t dindex,
                                           uint16_t lang) {

  (void)usbp;
  (void)lang;
  switch (dtype) {
  202dd0:	2902      	cmp	r1, #2
  202dd2:	d006      	beq.n	202de2 <get_descriptor.lto_priv.46+0x12>
  202dd4:	2903      	cmp	r1, #3
  202dd6:	d006      	beq.n	202de6 <get_descriptor.lto_priv.46+0x16>
  202dd8:	2901      	cmp	r1, #1
    return &vcom_configuration_descriptor;
  case USB_DESCRIPTOR_STRING:
    if (dindex < 4)
      return &vcom_strings[dindex];
  }
  return NULL;
  202dda:	4807      	ldr	r0, [pc, #28]	; (202df8 <get_descriptor.lto_priv.46+0x28>)
  202ddc:	bf18      	it	ne
  202dde:	2000      	movne	r0, #0
  202de0:	4770      	bx	lr
    return &vcom_configuration_descriptor;
  202de2:	4806      	ldr	r0, [pc, #24]	; (202dfc <get_descriptor.lto_priv.46+0x2c>)
  202de4:	4770      	bx	lr
    if (dindex < 4)
  202de6:	2a03      	cmp	r2, #3
  202de8:	d803      	bhi.n	202df2 <get_descriptor.lto_priv.46+0x22>
      return &vcom_strings[dindex];
  202dea:	4805      	ldr	r0, [pc, #20]	; (202e00 <get_descriptor.lto_priv.46+0x30>)
  202dec:	eb00 00c2 	add.w	r0, r0, r2, lsl #3
  202df0:	4770      	bx	lr
  return NULL;
  202df2:	2000      	movs	r0, #0
}
  202df4:	4770      	bx	lr
  202df6:	bf00      	nop
  202df8:	08003ec4 	.word	0x08003ec4
  202dfc:	08003e78 	.word	0x08003e78
  202e00:	08003f4c 	.word	0x08003f4c
	...

00202e10 <adc_lld_serve_rx_interrupt.lto_priv.41>:
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
  202e10:	f011 0f0c 	tst.w	r1, #12
static void adc_lld_serve_rx_interrupt(ADCDriver *adcp, uint32_t flags) {
  202e14:	b570      	push	{r4, r5, r6, lr}
  202e16:	4604      	mov	r4, r0
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
  202e18:	d118      	bne.n	202e4c <adc_lld_serve_rx_interrupt.lto_priv.41+0x3c>
    if (adcp->grpp != NULL) {
  202e1a:	6903      	ldr	r3, [r0, #16]
  202e1c:	b1ab      	cbz	r3, 202e4a <adc_lld_serve_rx_interrupt.lto_priv.41+0x3a>
      if ((flags & STM32_DMA_ISR_TCIF) != 0) {
  202e1e:	068d      	lsls	r5, r1, #26
  202e20:	d511      	bpl.n	202e46 <adc_lld_serve_rx_interrupt.lto_priv.41+0x36>
        _adc_isr_full_code(adcp);
  202e22:	781a      	ldrb	r2, [r3, #0]
  202e24:	2a00      	cmp	r2, #0
  202e26:	d03f      	beq.n	202ea8 <adc_lld_serve_rx_interrupt.lto_priv.41+0x98>
  202e28:	685d      	ldr	r5, [r3, #4]
  202e2a:	b175      	cbz	r5, 202e4a <adc_lld_serve_rx_interrupt.lto_priv.41+0x3a>
  202e2c:	68c2      	ldr	r2, [r0, #12]
  202e2e:	2a01      	cmp	r2, #1
  202e30:	d935      	bls.n	202e9e <adc_lld_serve_rx_interrupt.lto_priv.41+0x8e>
  202e32:	0852      	lsrs	r2, r2, #1
  202e34:	8859      	ldrh	r1, [r3, #2]
  202e36:	6883      	ldr	r3, [r0, #8]
  202e38:	0054      	lsls	r4, r2, #1
  202e3a:	fb04 3101 	mla	r1, r4, r1, r3
  202e3e:	462b      	mov	r3, r5
}
  202e40:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        _adc_isr_full_code(adcp);
  202e44:	4718      	bx	r3
      else if ((flags & STM32_DMA_ISR_HTIF) != 0) {
  202e46:	06ca      	lsls	r2, r1, #27
  202e48:	d41d      	bmi.n	202e86 <adc_lld_serve_rx_interrupt.lto_priv.41+0x76>
  202e4a:	bd70      	pop	{r4, r5, r6, pc}
    _adc_isr_error_code(adcp, ADC_ERR_DMAFAILURE);
  202e4c:	f7fe ffd0 	bl	201df0 <adc_lld_stop_conversion>
  202e50:	6923      	ldr	r3, [r4, #16]
  202e52:	689b      	ldr	r3, [r3, #8]
  202e54:	2b00      	cmp	r3, #0
  202e56:	d046      	beq.n	202ee6 <adc_lld_serve_rx_interrupt.lto_priv.41+0xd6>
  202e58:	2205      	movs	r2, #5
  202e5a:	2100      	movs	r1, #0
  202e5c:	4620      	mov	r0, r4
  202e5e:	7022      	strb	r2, [r4, #0]
  202e60:	4798      	blx	r3
  202e62:	7823      	ldrb	r3, [r4, #0]
  202e64:	2b05      	cmp	r3, #5
  202e66:	d017      	beq.n	202e98 <adc_lld_serve_rx_interrupt.lto_priv.41+0x88>
  202e68:	2300      	movs	r3, #0
  202e6a:	6123      	str	r3, [r4, #16]
  202e6c:	2320      	movs	r3, #32
  202e6e:	f383 8811 	msr	BASEPRI, r3
  chThdResumeI(trp, msg);
  202e72:	f04f 31ff 	mov.w	r1, #4294967295
  202e76:	f104 0014 	add.w	r0, r4, #20
  202e7a:	f7fe fa21 	bl	2012c0 <chThdResumeI>
  202e7e:	2300      	movs	r3, #0
  202e80:	f383 8811 	msr	BASEPRI, r3
  202e84:	bd70      	pop	{r4, r5, r6, pc}
        _adc_isr_half_code(adcp);
  202e86:	685b      	ldr	r3, [r3, #4]
  202e88:	2b00      	cmp	r3, #0
  202e8a:	d0de      	beq.n	202e4a <adc_lld_serve_rx_interrupt.lto_priv.41+0x3a>
  202e8c:	68c2      	ldr	r2, [r0, #12]
  202e8e:	6881      	ldr	r1, [r0, #8]
  202e90:	0852      	lsrs	r2, r2, #1
}
  202e92:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        _adc_isr_half_code(adcp);
  202e96:	4718      	bx	r3
    _adc_isr_error_code(adcp, ADC_ERR_DMAFAILURE);
  202e98:	2302      	movs	r3, #2
  202e9a:	7023      	strb	r3, [r4, #0]
  202e9c:	e7e4      	b.n	202e68 <adc_lld_serve_rx_interrupt.lto_priv.41+0x58>
        _adc_isr_full_code(adcp);
  202e9e:	462b      	mov	r3, r5
  202ea0:	6881      	ldr	r1, [r0, #8]
}
  202ea2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        _adc_isr_full_code(adcp);
  202ea6:	4718      	bx	r3
  202ea8:	f7fe ffa2 	bl	201df0 <adc_lld_stop_conversion>
  202eac:	6923      	ldr	r3, [r4, #16]
  202eae:	685b      	ldr	r3, [r3, #4]
  202eb0:	b1a3      	cbz	r3, 202edc <adc_lld_serve_rx_interrupt.lto_priv.41+0xcc>
  202eb2:	2504      	movs	r5, #4
  202eb4:	68e2      	ldr	r2, [r4, #12]
  202eb6:	68a1      	ldr	r1, [r4, #8]
  202eb8:	4620      	mov	r0, r4
  202eba:	7025      	strb	r5, [r4, #0]
  202ebc:	4798      	blx	r3
  202ebe:	7823      	ldrb	r3, [r4, #0]
  202ec0:	42ab      	cmp	r3, r5
  202ec2:	d00b      	beq.n	202edc <adc_lld_serve_rx_interrupt.lto_priv.41+0xcc>
  202ec4:	2320      	movs	r3, #32
  202ec6:	f383 8811 	msr	BASEPRI, r3
  202eca:	2100      	movs	r1, #0
  202ecc:	f104 0014 	add.w	r0, r4, #20
  202ed0:	f7fe f9f6 	bl	2012c0 <chThdResumeI>
  202ed4:	2300      	movs	r3, #0
  202ed6:	f383 8811 	msr	BASEPRI, r3
  202eda:	bd70      	pop	{r4, r5, r6, pc}
  202edc:	2202      	movs	r2, #2
  202ede:	2300      	movs	r3, #0
  202ee0:	7022      	strb	r2, [r4, #0]
  202ee2:	6123      	str	r3, [r4, #16]
  202ee4:	e7ee      	b.n	202ec4 <adc_lld_serve_rx_interrupt.lto_priv.41+0xb4>
    _adc_isr_error_code(adcp, ADC_ERR_DMAFAILURE);
  202ee6:	2202      	movs	r2, #2
  202ee8:	6123      	str	r3, [r4, #16]
  202eea:	7022      	strb	r2, [r4, #0]
  202eec:	e7be      	b.n	202e6c <adc_lld_serve_rx_interrupt.lto_priv.41+0x5c>
  202eee:	bf00      	nop

00202ef0 <sof_handler.lto_priv.47>:
}

/*
 * Handles the USB driver global events.
 */
static void sof_handler(USBDriver *usbp) {
  202ef0:	b510      	push	{r4, lr}
  202ef2:	2320      	movs	r3, #32
  202ef4:	b082      	sub	sp, #8
  202ef6:	f383 8811 	msr	BASEPRI, r3
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
  202efa:	4c1f      	ldr	r4, [pc, #124]	; (202f78 <sof_handler.lto_priv.47+0x88>)
  202efc:	f8d4 248c 	ldr.w	r2, [r4, #1164]	; 0x48c
  202f00:	6813      	ldr	r3, [r2, #0]
  202f02:	7819      	ldrb	r1, [r3, #0]
  202f04:	2904      	cmp	r1, #4
  202f06:	d004      	beq.n	202f12 <sof_handler.lto_priv.47+0x22>
  202f08:	2300      	movs	r3, #0
  202f0a:	f383 8811 	msr	BASEPRI, r3
  (void)usbp;

  osalSysLockFromISR();
  sduSOFHookI(&SDU1);
  osalSysUnlockFromISR();
}
  202f0e:	b002      	add	sp, #8
  202f10:	bd10      	pop	{r4, pc}
  202f12:	7a21      	ldrb	r1, [r4, #8]
  202f14:	2902      	cmp	r1, #2
  202f16:	d1f7      	bne.n	202f08 <sof_handler.lto_priv.47+0x18>
  if (usbGetTransmitStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
  202f18:	7910      	ldrb	r0, [r2, #4]
  202f1a:	2201      	movs	r2, #1
  202f1c:	8919      	ldrh	r1, [r3, #8]
  202f1e:	fa02 f300 	lsl.w	r3, r2, r0
  202f22:	420b      	tst	r3, r1
  202f24:	d1f0      	bne.n	202f08 <sof_handler.lto_priv.47+0x18>

  osalDbgCheckClassI();

  /* If queue is empty and there is a buffer partially filled and
     it is not being written.*/
  if (obqIsEmptyI(obqp) && (obqp->ptr != NULL)) {
  202f26:	6d63      	ldr	r3, [r4, #84]	; 0x54
  202f28:	6da2      	ldr	r2, [r4, #88]	; 0x58
  202f2a:	4293      	cmp	r3, r2
  202f2c:	d1ec      	bne.n	202f08 <sof_handler.lto_priv.47+0x18>
  202f2e:	6d22      	ldr	r2, [r4, #80]	; 0x50
  202f30:	2a00      	cmp	r2, #0
  202f32:	d0e9      	beq.n	202f08 <sof_handler.lto_priv.47+0x18>
  202f34:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
  202f36:	2a00      	cmp	r2, #0
  202f38:	d0e6      	beq.n	202f08 <sof_handler.lto_priv.47+0x18>
    size_t size = (size_t)obqp->ptr - ((size_t)obqp->bwrptr + sizeof (size_t));
  202f3a:	3a04      	subs	r2, #4

    if (size > 0U) {
  202f3c:	1ad2      	subs	r2, r2, r3
  202f3e:	d0e3      	beq.n	202f08 <sof_handler.lto_priv.47+0x18>

      /* Writing size field in the buffer.*/
      *((size_t *)obqp->bwrptr) = size;
  202f40:	601a      	str	r2, [r3, #0]

      /* Posting the buffer in the queue.*/
      obqp->bcounter--;
      obqp->bwrptr += obqp->bsize;
  202f42:	6e20      	ldr	r0, [r4, #96]	; 0x60
      obqp->bcounter--;
  202f44:	6d22      	ldr	r2, [r4, #80]	; 0x50
      obqp->bwrptr += obqp->bsize;
  202f46:	4403      	add	r3, r0
      if (obqp->bwrptr >= obqp->btop) {
  202f48:	6de1      	ldr	r1, [r4, #92]	; 0x5c
      obqp->bcounter--;
  202f4a:	3a01      	subs	r2, #1
      if (obqp->bwrptr >= obqp->btop) {
  202f4c:	428b      	cmp	r3, r1
      obqp->bwrptr += obqp->bsize;
  202f4e:	6563      	str	r3, [r4, #84]	; 0x54
      obqp->bcounter--;
  202f50:	6522      	str	r2, [r4, #80]	; 0x50
      if (obqp->bwrptr >= obqp->btop) {
  202f52:	d301      	bcc.n	202f58 <sof_handler.lto_priv.47+0x68>
        obqp->bwrptr = obqp->buffers;
  202f54:	6ea3      	ldr	r3, [r4, #104]	; 0x68
  202f56:	6563      	str	r3, [r4, #84]	; 0x54
      }

      /* No "current" buffer.*/
      obqp->ptr = NULL;
  202f58:	2300      	movs	r3, #0
    uint8_t *buf = obqGetFullBufferI(&sdup->obqueue, &n);
  202f5a:	a901      	add	r1, sp, #4
  202f5c:	4807      	ldr	r0, [pc, #28]	; (202f7c <sof_handler.lto_priv.47+0x8c>)
  202f5e:	66e3      	str	r3, [r4, #108]	; 0x6c
  202f60:	f7fe f82e 	bl	200fc0 <obqGetFullBufferI>
    usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in, buf, n);
  202f64:	f8d4 448c 	ldr.w	r4, [r4, #1164]	; 0x48c
  202f68:	4602      	mov	r2, r0
  202f6a:	9b01      	ldr	r3, [sp, #4]
  202f6c:	7921      	ldrb	r1, [r4, #4]
  202f6e:	6820      	ldr	r0, [r4, #0]
  202f70:	f7fd ffce 	bl	200f10 <usbStartTransmitI>
  202f74:	e7c8      	b.n	202f08 <sof_handler.lto_priv.47+0x18>
  202f76:	bf00      	nop
  202f78:	200008b4 	.word	0x200008b4
  202f7c:	200008f8 	.word	0x200008f8

00202f80 <usb_event.lto_priv.45>:
static void usb_event(USBDriver *usbp, usbevent_t event) {
  202f80:	b538      	push	{r3, r4, r5, lr}
  switch (event) {
  202f82:	2905      	cmp	r1, #5
  202f84:	d812      	bhi.n	202fac <usb_event.lto_priv.45+0x2c>
  202f86:	e8df f001 	tbb	[pc, r1]
  202f8a:	1147      	.short	0x1147
  202f8c:	03474712 	.word	0x03474712
  202f90:	2320      	movs	r3, #32
  202f92:	f383 8811 	msr	BASEPRI, r3
  chEvtBroadcastFlagsI(esp, flags);
  202f96:	2101      	movs	r1, #1
  202f98:	482d      	ldr	r0, [pc, #180]	; (203050 <usb_event.lto_priv.45+0xd0>)
  202f9a:	f7fe f889 	bl	2010b0 <chEvtBroadcastFlagsI>
  bqResumeX(&sdup->ibqueue);
  202f9e:	4a2d      	ldr	r2, [pc, #180]	; (203054 <usb_event.lto_priv.45+0xd4>)
  202fa0:	2300      	movs	r3, #0
  202fa2:	7513      	strb	r3, [r2, #20]
  bqResumeX(&sdup->obqueue);
  202fa4:	f882 304c 	strb.w	r3, [r2, #76]	; 0x4c
  202fa8:	f383 8811 	msr	BASEPRI, r3
  202fac:	bd38      	pop	{r3, r4, r5, pc}
  202fae:	4605      	mov	r5, r0
  202fb0:	2320      	movs	r3, #32
  202fb2:	f383 8811 	msr	BASEPRI, r3
  ibqp->bcounter  = 0;
  202fb6:	4c27      	ldr	r4, [pc, #156]	; (203054 <usb_event.lto_priv.45+0xd4>)
    usbInitEndpointI(usbp, USBD2_DATA_REQUEST_EP, &ep1config);
  202fb8:	2101      	movs	r1, #1
  202fba:	4a27      	ldr	r2, [pc, #156]	; (203058 <usb_event.lto_priv.45+0xd8>)
  202fbc:	f7fe f9f8 	bl	2013b0 <usbInitEndpointI>
    usbInitEndpointI(usbp, USBD2_INTERRUPT_REQUEST_EP, &ep2config);
  202fc0:	4628      	mov	r0, r5
  202fc2:	4a26      	ldr	r2, [pc, #152]	; (20305c <usb_event.lto_priv.45+0xdc>)
  202fc4:	2102      	movs	r1, #2
  202fc6:	f7fe f9f3 	bl	2013b0 <usbInitEndpointI>
  202fca:	2500      	movs	r5, #0
  ibqp->brdptr    = ibqp->buffers;
  202fcc:	6b23      	ldr	r3, [r4, #48]	; 0x30
  chThdDequeueAllI(tqp, msg);
  202fce:	f104 000c 	add.w	r0, r4, #12
  202fd2:	f06f 0101 	mvn.w	r1, #1
  ibqp->bcounter  = 0;
  202fd6:	61a5      	str	r5, [r4, #24]
  ibqp->brdptr    = ibqp->buffers;
  202fd8:	6223      	str	r3, [r4, #32]
  ibqp->bwrptr    = ibqp->buffers;
  202fda:	61e3      	str	r3, [r4, #28]
  ibqp->ptr       = NULL;
  202fdc:	6365      	str	r5, [r4, #52]	; 0x34
  ibqp->top       = NULL;
  202fde:	63a5      	str	r5, [r4, #56]	; 0x38
  202fe0:	f7fe f956 	bl	201290 <chThdDequeueAllI>
  obqp->brdptr    = obqp->buffers;
  202fe4:	6ea3      	ldr	r3, [r4, #104]	; 0x68
  obqp->bcounter  = bqSizeX(obqp);
  202fe6:	6e62      	ldr	r2, [r4, #100]	; 0x64
  202fe8:	f104 0044 	add.w	r0, r4, #68	; 0x44
  obqp->brdptr    = obqp->buffers;
  202fec:	65a3      	str	r3, [r4, #88]	; 0x58
  202fee:	f06f 0101 	mvn.w	r1, #1
  obqp->bcounter  = bqSizeX(obqp);
  202ff2:	6522      	str	r2, [r4, #80]	; 0x50
  obqp->bwrptr    = obqp->buffers;
  202ff4:	6563      	str	r3, [r4, #84]	; 0x54
  obqp->ptr       = NULL;
  202ff6:	66e5      	str	r5, [r4, #108]	; 0x6c
  obqp->top       = NULL;
  202ff8:	6725      	str	r5, [r4, #112]	; 0x70
  bqResumeX(&sdup->ibqueue);
  202ffa:	7525      	strb	r5, [r4, #20]
  202ffc:	f7fe f948 	bl	201290 <chThdDequeueAllI>
  chEvtBroadcastFlagsI(esp, flags);
  203000:	1d20      	adds	r0, r4, #4
  203002:	2101      	movs	r1, #1
  bqResumeX(&sdup->obqueue);
  203004:	f884 504c 	strb.w	r5, [r4, #76]	; 0x4c
  203008:	f7fe f852 	bl	2010b0 <chEvtBroadcastFlagsI>
  (void) sdu_start_receive(sdup);
  20300c:	4620      	mov	r0, r4
  20300e:	f7fd ff97 	bl	200f40 <sdu_start_receive.lto_priv.61>
  203012:	f385 8811 	msr	BASEPRI, r5
  203016:	bd38      	pop	{r3, r4, r5, pc}
  203018:	2320      	movs	r3, #32
  20301a:	f383 8811 	msr	BASEPRI, r3
  bqSuspendI(&sdup->ibqueue);
  20301e:	4c0d      	ldr	r4, [pc, #52]	; (203054 <usb_event.lto_priv.45+0xd4>)
  203020:	2501      	movs	r5, #1
  203022:	2102      	movs	r1, #2
  203024:	1d20      	adds	r0, r4, #4
  203026:	f7fe f843 	bl	2010b0 <chEvtBroadcastFlagsI>
  chThdDequeueAllI(tqp, msg);
  20302a:	f104 000c 	add.w	r0, r4, #12
  20302e:	f06f 0101 	mvn.w	r1, #1
  203032:	7525      	strb	r5, [r4, #20]
  203034:	f7fe f92c 	bl	201290 <chThdDequeueAllI>
  203038:	f104 0044 	add.w	r0, r4, #68	; 0x44
  20303c:	f06f 0101 	mvn.w	r1, #1
  bqSuspendI(&sdup->obqueue);
  203040:	f884 504c 	strb.w	r5, [r4, #76]	; 0x4c
  203044:	f7fe f924 	bl	201290 <chThdDequeueAllI>
  203048:	2300      	movs	r3, #0
  20304a:	f383 8811 	msr	BASEPRI, r3
  20304e:	bd38      	pop	{r3, r4, r5, pc}
  203050:	200008b8 	.word	0x200008b8
  203054:	200008b4 	.word	0x200008b4
  203058:	08003e30 	.word	0x08003e30
  20305c:	08003e54 	.word	0x08003e54

00203060 <chprintf>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
  203060:	b40e      	push	{r1, r2, r3}
  203062:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  203066:	b086      	sub	sp, #24
  int n = 0;
  203068:	f04f 0900 	mov.w	r9, #0
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
  20306c:	4682      	mov	sl, r0
  20306e:	ab0f      	add	r3, sp, #60	; 0x3c
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
  203070:	46cb      	mov	fp, r9
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
  203072:	f853 5b04 	ldr.w	r5, [r3], #4
  203076:	461e      	mov	r6, r3
  va_start(ap, fmt);
  203078:	9302      	str	r3, [sp, #8]
    c = *fmt++;
  20307a:	7829      	ldrb	r1, [r5, #0]
  20307c:	1c6a      	adds	r2, r5, #1
    if (c == 0)
  20307e:	b169      	cbz	r1, 20309c <chprintf+0x3c>
    if (c != '%') {
  203080:	2925      	cmp	r1, #37	; 0x25
  203082:	d011      	beq.n	2030a8 <chprintf+0x48>
      streamPut(chp, (uint8_t)c);
  203084:	f8da 3000 	ldr.w	r3, [sl]
    c = *fmt++;
  203088:	4615      	mov	r5, r2
      streamPut(chp, (uint8_t)c);
  20308a:	4650      	mov	r0, sl
      n++;
  20308c:	f10b 0b01 	add.w	fp, fp, #1
      streamPut(chp, (uint8_t)c);
  203090:	689b      	ldr	r3, [r3, #8]
  203092:	4798      	blx	r3
    c = *fmt++;
  203094:	7829      	ldrb	r1, [r5, #0]
  203096:	1c6a      	adds	r2, r5, #1
    if (c == 0)
  203098:	2900      	cmp	r1, #0
  20309a:	d1f1      	bne.n	203080 <chprintf+0x20>
  formatted_bytes = chvprintf(chp, fmt, ap);
  va_end(ap);

  return formatted_bytes;
}
  20309c:	4658      	mov	r0, fp
  20309e:	b006      	add	sp, #24
  2030a0:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  2030a4:	b003      	add	sp, #12
  2030a6:	4770      	bx	lr
    if (*fmt == '-') {
  2030a8:	7869      	ldrb	r1, [r5, #1]
  2030aa:	292d      	cmp	r1, #45	; 0x2d
  2030ac:	f000 8184 	beq.w	2033b8 <chprintf+0x358>
    left_align = FALSE;
  2030b0:	f04f 0c00 	mov.w	ip, #0
    if (*fmt == '0') {
  2030b4:	2930      	cmp	r1, #48	; 0x30
  2030b6:	f000 817a 	beq.w	2033ae <chprintf+0x34e>
    filler = ' ';
  2030ba:	f04f 0820 	mov.w	r8, #32
  2030be:	3201      	adds	r2, #1
    width = 0;
  2030c0:	2400      	movs	r4, #0
  2030c2:	e005      	b.n	2030d0 <chprintf+0x70>
        c = va_arg(ap, int);
  2030c4:	7833      	ldrb	r3, [r6, #0]
  2030c6:	3604      	adds	r6, #4
  2030c8:	f812 1b01 	ldrb.w	r1, [r2], #1
      width = width * 10 + c;
  2030cc:	eb03 0440 	add.w	r4, r3, r0, lsl #1
      if (c >= '0' && c <= '9')
  2030d0:	f1a1 0330 	sub.w	r3, r1, #48	; 0x30
      c = *fmt++;
  2030d4:	4615      	mov	r5, r2
      width = width * 10 + c;
  2030d6:	eb04 0084 	add.w	r0, r4, r4, lsl #2
      if (c >= '0' && c <= '9')
  2030da:	b2db      	uxtb	r3, r3
  2030dc:	2b09      	cmp	r3, #9
  2030de:	d9f3      	bls.n	2030c8 <chprintf+0x68>
      else if (c == '*')
  2030e0:	292a      	cmp	r1, #42	; 0x2a
  2030e2:	d0ef      	beq.n	2030c4 <chprintf+0x64>
    if (c == '.') {
  2030e4:	292e      	cmp	r1, #46	; 0x2e
  2030e6:	f04f 0200 	mov.w	r2, #0
  2030ea:	d047      	beq.n	20317c <chprintf+0x11c>
    if (c == 'l' || c == 'L') {
  2030ec:	f001 03df 	and.w	r3, r1, #223	; 0xdf
  2030f0:	2b4c      	cmp	r3, #76	; 0x4c
  2030f2:	d152      	bne.n	20319a <chprintf+0x13a>
      if (*fmt)
  2030f4:	782b      	ldrb	r3, [r5, #0]
  2030f6:	b10b      	cbz	r3, 2030fc <chprintf+0x9c>
        c = *fmt++;
  2030f8:	3501      	adds	r5, #1
  2030fa:	4619      	mov	r1, r3
    switch (c) {
  2030fc:	f1a1 0344 	sub.w	r3, r1, #68	; 0x44
  203100:	2b34      	cmp	r3, #52	; 0x34
  203102:	f200 8147 	bhi.w	203394 <chprintf+0x334>
  203106:	e8df f013 	tbh	[pc, r3, lsl #1]
  20310a:	011d      	.short	0x011d
  20310c:	01450145 	.word	0x01450145
  203110:	01450145 	.word	0x01450145
  203114:	0145011d 	.word	0x0145011d
  203118:	01450145 	.word	0x01450145
  20311c:	01450145 	.word	0x01450145
  203120:	014500f3 	.word	0x014500f3
  203124:	01450145 	.word	0x01450145
  203128:	01450145 	.word	0x01450145
  20312c:	01450084 	.word	0x01450084
  203130:	011a0145 	.word	0x011a0145
  203134:	01450145 	.word	0x01450145
  203138:	01450145 	.word	0x01450145
  20313c:	01450145 	.word	0x01450145
  203140:	01450145 	.word	0x01450145
  203144:	01450145 	.word	0x01450145
  203148:	011d010f 	.word	0x011d010f
  20314c:	01450145 	.word	0x01450145
  203150:	01450145 	.word	0x01450145
  203154:	0145011d 	.word	0x0145011d
  203158:	01450145 	.word	0x01450145
  20315c:	01450145 	.word	0x01450145
  203160:	014500f3 	.word	0x014500f3
  203164:	01450145 	.word	0x01450145
  203168:	014500f6 	.word	0x014500f6
  20316c:	01450084 	.word	0x01450084
  203170:	011a0145 	.word	0x011a0145
          c = va_arg(ap, int);
  203174:	7833      	ldrb	r3, [r6, #0]
  203176:	3604      	adds	r6, #4
        precision += c;
  203178:	eb03 0240 	add.w	r2, r3, r0, lsl #1
        c = *fmt++;
  20317c:	f815 1b01 	ldrb.w	r1, [r5], #1
        precision *= 10;
  203180:	eb02 0082 	add.w	r0, r2, r2, lsl #2
        if (c >= '0' && c <= '9')
  203184:	f1a1 0330 	sub.w	r3, r1, #48	; 0x30
  203188:	b2db      	uxtb	r3, r3
  20318a:	2b09      	cmp	r3, #9
  20318c:	d9f4      	bls.n	203178 <chprintf+0x118>
        else if (c == '*')
  20318e:	292a      	cmp	r1, #42	; 0x2a
  203190:	d0f0      	beq.n	203174 <chprintf+0x114>
    if (c == 'l' || c == 'L') {
  203192:	f001 03df 	and.w	r3, r1, #223	; 0xdf
  203196:	2b4c      	cmp	r3, #76	; 0x4c
  203198:	d0ac      	beq.n	2030f4 <chprintf+0x94>
    switch (c) {
  20319a:	f1a1 0044 	sub.w	r0, r1, #68	; 0x44
  20319e:	2834      	cmp	r0, #52	; 0x34
  2031a0:	f200 80f8 	bhi.w	203394 <chprintf+0x334>
  2031a4:	e8df f010 	tbh	[pc, r0, lsl #1]
  2031a8:	00f600ce 	.word	0x00f600ce
  2031ac:	00f600f6 	.word	0x00f600f6
  2031b0:	00ce00f6 	.word	0x00ce00f6
  2031b4:	00f600f6 	.word	0x00f600f6
  2031b8:	00f600f6 	.word	0x00f600f6
  2031bc:	00a400f6 	.word	0x00a400f6
  2031c0:	00f600f6 	.word	0x00f600f6
  2031c4:	00f600f6 	.word	0x00f600f6
  2031c8:	003500f6 	.word	0x003500f6
  2031cc:	00f600f6 	.word	0x00f600f6
  2031d0:	00f600cb 	.word	0x00f600cb
  2031d4:	00f600f6 	.word	0x00f600f6
  2031d8:	00f600f6 	.word	0x00f600f6
  2031dc:	00f600f6 	.word	0x00f600f6
  2031e0:	00f600f6 	.word	0x00f600f6
  2031e4:	00c000f6 	.word	0x00c000f6
  2031e8:	00f600ce 	.word	0x00f600ce
  2031ec:	00f600f6 	.word	0x00f600f6
  2031f0:	00ce00f6 	.word	0x00ce00f6
  2031f4:	00f600f6 	.word	0x00f600f6
  2031f8:	00f600f6 	.word	0x00f600f6
  2031fc:	00a400f6 	.word	0x00a400f6
  203200:	00f600f6 	.word	0x00f600f6
  203204:	00a700f6 	.word	0x00a700f6
  203208:	003500f6 	.word	0x003500f6
  20320c:	00f600f6 	.word	0x00f600f6
  203210:	00cb      	.short	0x00cb
  203212:	f04f 0e0a 	mov.w	lr, #10
        l = va_arg(ap, unsigned int);
  203216:	6837      	ldr	r7, [r6, #0]
  q = p + MAX_FILLER;
  203218:	f10d 0117 	add.w	r1, sp, #23
        l = va_arg(ap, unsigned int);
  20321c:	3604      	adds	r6, #4
  20321e:	e000      	b.n	203222 <chprintf+0x1c2>
  } while ((ll /= radix) != 0);
  203220:	4601      	mov	r1, r0
    *--q = i;
  203222:	1e48      	subs	r0, r1, #1
    i = (int)(l % radix);
  203224:	fbb7 f2fe 	udiv	r2, r7, lr
  203228:	fb0e 7912 	mls	r9, lr, r2, r7
    l /= radix;
  20322c:	4617      	mov	r7, r2
    i += '0';
  20322e:	f109 0330 	add.w	r3, r9, #48	; 0x30
    if (i > '9')
  203232:	2b39      	cmp	r3, #57	; 0x39
      i += 'A' - '0' - 10;
  203234:	bfc8      	it	gt
  203236:	f109 0337 	addgt.w	r3, r9, #55	; 0x37
    *--q = i;
  20323a:	b2db      	uxtb	r3, r3
  20323c:	f801 3c01 	strb.w	r3, [r1, #-1]
  } while ((ll /= radix) != 0);
  203240:	2a00      	cmp	r2, #0
  203242:	d1ed      	bne.n	203220 <chprintf+0x1c0>
  i = (int)(p + MAX_FILLER - q);
  203244:	f10d 0217 	add.w	r2, sp, #23
  203248:	af03      	add	r7, sp, #12
  20324a:	1a12      	subs	r2, r2, r0
  20324c:	46be      	mov	lr, r7
  20324e:	4410      	add	r0, r2
  203250:	e001      	b.n	203256 <chprintf+0x1f6>
  203252:	f811 3b01 	ldrb.w	r3, [r1], #1
  while (--i);
  203256:	4288      	cmp	r0, r1
    *p++ = *q++;
  203258:	f80e 3b01 	strb.w	r3, [lr], #1
  while (--i);
  20325c:	d1f9      	bne.n	203252 <chprintf+0x1f2>
  20325e:	1e53      	subs	r3, r2, #1
  203260:	9301      	str	r3, [sp, #4]
    if ((width -= i) < 0)
  203262:	1aa4      	subs	r4, r4, r2
  203264:	d43e      	bmi.n	2032e4 <chprintf+0x284>
    if (left_align == FALSE)
  203266:	f1bc 0f00 	cmp.w	ip, #0
  20326a:	f040 809b 	bne.w	2033a4 <chprintf+0x344>
  20326e:	f1c4 0900 	rsb	r9, r4, #0
    if (width < 0) {
  203272:	2c00      	cmp	r4, #0
  203274:	f000 8095 	beq.w	2033a2 <chprintf+0x342>
      if (*s == '-' && filler == '0') {
  203278:	783b      	ldrb	r3, [r7, #0]
  20327a:	2b2d      	cmp	r3, #45	; 0x2d
  20327c:	d103      	bne.n	203286 <chprintf+0x226>
  20327e:	f1b8 0f30 	cmp.w	r8, #48	; 0x30
  203282:	f000 80ae 	beq.w	2033e2 <chprintf+0x382>
        streamPut(chp, (uint8_t)filler);
  203286:	f8da 3000 	ldr.w	r3, [sl]
  20328a:	4641      	mov	r1, r8
  20328c:	4650      	mov	r0, sl
  20328e:	689b      	ldr	r3, [r3, #8]
  203290:	4798      	blx	r3
      } while (++width != 0);
  203292:	f119 0901 	adds.w	r9, r9, #1
  203296:	d1f6      	bne.n	203286 <chprintf+0x226>
    while (--i >= 0) {
  203298:	9b01      	ldr	r3, [sp, #4]
  20329a:	44a3      	add	fp, r4
  20329c:	2b00      	cmp	r3, #0
  20329e:	f6ff aeec 	blt.w	20307a <chprintf+0x1a>
  2032a2:	464c      	mov	r4, r9
  2032a4:	f8dd 9004 	ldr.w	r9, [sp, #4]
      streamPut(chp, (uint8_t)*s++);
  2032a8:	f8da 3000 	ldr.w	r3, [sl]
    while (--i >= 0) {
  2032ac:	f109 39ff 	add.w	r9, r9, #4294967295
      streamPut(chp, (uint8_t)*s++);
  2032b0:	f817 1b01 	ldrb.w	r1, [r7], #1
  2032b4:	4650      	mov	r0, sl
  2032b6:	689b      	ldr	r3, [r3, #8]
  2032b8:	4798      	blx	r3
    while (--i >= 0) {
  2032ba:	f1b9 3fff 	cmp.w	r9, #4294967295
  2032be:	d1f3      	bne.n	2032a8 <chprintf+0x248>
  2032c0:	f10b 0b01 	add.w	fp, fp, #1
  2032c4:	9b01      	ldr	r3, [sp, #4]
  2032c6:	449b      	add	fp, r3
    while (width) {
  2032c8:	2c00      	cmp	r4, #0
  2032ca:	f43f aed6 	beq.w	20307a <chprintf+0x1a>
  2032ce:	4627      	mov	r7, r4
      streamPut(chp, (uint8_t)filler);
  2032d0:	f8da 3000 	ldr.w	r3, [sl]
  2032d4:	4641      	mov	r1, r8
  2032d6:	4650      	mov	r0, sl
  2032d8:	689b      	ldr	r3, [r3, #8]
  2032da:	4798      	blx	r3
    while (width) {
  2032dc:	3f01      	subs	r7, #1
  2032de:	d1f7      	bne.n	2032d0 <chprintf+0x270>
  2032e0:	44a3      	add	fp, r4
  2032e2:	e6ca      	b.n	20307a <chprintf+0x1a>
    while (--i >= 0) {
  2032e4:	9b01      	ldr	r3, [sp, #4]
  2032e6:	2b00      	cmp	r3, #0
  2032e8:	f6ff aec7 	blt.w	20307a <chprintf+0x1a>
      width = 0;
  2032ec:	2400      	movs	r4, #0
  2032ee:	e7d9      	b.n	2032a4 <chprintf+0x244>
    switch (c) {
  2032f0:	f04f 0e08 	mov.w	lr, #8
  2032f4:	e78f      	b.n	203216 <chprintf+0x1b6>
      if ((s = va_arg(ap, char *)) == 0)
  2032f6:	6837      	ldr	r7, [r6, #0]
  2032f8:	3604      	adds	r6, #4
  2032fa:	2f00      	cmp	r7, #0
  2032fc:	d06c      	beq.n	2033d8 <chprintf+0x378>
      for (p = s; *p && (--precision >= 0); p++)
  2032fe:	783b      	ldrb	r3, [r7, #0]
      if (precision == 0)
  203300:	2a00      	cmp	r2, #0
  203302:	d15e      	bne.n	2033c2 <chprintf+0x362>
      for (p = s; *p && (--precision >= 0); p++)
  203304:	2b00      	cmp	r3, #0
  203306:	d079      	beq.n	2033fc <chprintf+0x39c>
  203308:	f647 73fe 	movw	r3, #32766	; 0x7ffe
  20330c:	463a      	mov	r2, r7
  20330e:	e001      	b.n	203314 <chprintf+0x2b4>
  203310:	3b01      	subs	r3, #1
  203312:	d403      	bmi.n	20331c <chprintf+0x2bc>
  203314:	f812 1f01 	ldrb.w	r1, [r2, #1]!
  203318:	2900      	cmp	r1, #0
  20331a:	d1f9      	bne.n	203310 <chprintf+0x2b0>
  20331c:	1bd2      	subs	r2, r2, r7
      filler = ' ';
  20331e:	f04f 0820 	mov.w	r8, #32
  203322:	1e53      	subs	r3, r2, #1
  203324:	9301      	str	r3, [sp, #4]
  203326:	e79c      	b.n	203262 <chprintf+0x202>
      *p++ = va_arg(ap, int);
  203328:	6833      	ldr	r3, [r6, #0]
  20332a:	2200      	movs	r2, #0
  20332c:	af06      	add	r7, sp, #24
  20332e:	3604      	adds	r6, #4
  203330:	9201      	str	r2, [sp, #4]
      filler = ' ';
  203332:	f04f 0820 	mov.w	r8, #32
      *p++ = va_arg(ap, int);
  203336:	f807 3d0c 	strb.w	r3, [r7, #-12]!
  20333a:	2201      	movs	r2, #1
  20333c:	e791      	b.n	203262 <chprintf+0x202>
    switch (c) {
  20333e:	f04f 0e10 	mov.w	lr, #16
  203342:	e768      	b.n	203216 <chprintf+0x1b6>
        l = va_arg(ap, int);
  203344:	6831      	ldr	r1, [r6, #0]
  203346:	3604      	adds	r6, #4
      if (l < 0) {
  203348:	2900      	cmp	r1, #0
  20334a:	db3d      	blt.n	2033c8 <chprintf+0x368>
    p = tmpbuf;
  20334c:	af03      	add	r7, sp, #12
  20334e:	463a      	mov	r2, r7
  q = p + MAX_FILLER;
  203350:	f102 030b 	add.w	r3, r2, #11
  203354:	4618      	mov	r0, r3
  203356:	9301      	str	r3, [sp, #4]
    i = (int)(l % radix);
  203358:	4b2b      	ldr	r3, [pc, #172]	; (203408 <chprintf+0x3a8>)
  20335a:	fba3 e301 	umull	lr, r3, r3, r1
  20335e:	08db      	lsrs	r3, r3, #3
  203360:	eb03 0983 	add.w	r9, r3, r3, lsl #2
  203364:	469e      	mov	lr, r3
  203366:	eba1 0349 	sub.w	r3, r1, r9, lsl #1
  } while ((ll /= radix) != 0);
  20336a:	4671      	mov	r1, lr
    i += '0';
  20336c:	3330      	adds	r3, #48	; 0x30
    *--q = i;
  20336e:	b2db      	uxtb	r3, r3
  203370:	f800 3d01 	strb.w	r3, [r0, #-1]!
  } while ((ll /= radix) != 0);
  203374:	2900      	cmp	r1, #0
  203376:	d1ef      	bne.n	203358 <chprintf+0x2f8>
  i = (int)(p + MAX_FILLER - q);
  203378:	9901      	ldr	r1, [sp, #4]
  20337a:	1a09      	subs	r1, r1, r0
  20337c:	4411      	add	r1, r2
  20337e:	e001      	b.n	203384 <chprintf+0x324>
  203380:	f810 3f01 	ldrb.w	r3, [r0, #1]!
    *p++ = *q++;
  203384:	f802 3b01 	strb.w	r3, [r2], #1
  while (--i);
  203388:	428a      	cmp	r2, r1
  20338a:	d1f9      	bne.n	203380 <chprintf+0x320>
  20338c:	1bd2      	subs	r2, r2, r7
  20338e:	1e53      	subs	r3, r2, #1
  203390:	9301      	str	r3, [sp, #4]
  203392:	e766      	b.n	203262 <chprintf+0x202>
      *p++ = c;
  203394:	af06      	add	r7, sp, #24
  203396:	2300      	movs	r3, #0
  203398:	2201      	movs	r2, #1
  20339a:	9301      	str	r3, [sp, #4]
  20339c:	f807 1d0c 	strb.w	r1, [r7, #-12]!
  2033a0:	e75f      	b.n	203262 <chprintf+0x202>
    if (width < 0) {
  2033a2:	464c      	mov	r4, r9
    while (--i >= 0) {
  2033a4:	9b01      	ldr	r3, [sp, #4]
  2033a6:	2b00      	cmp	r3, #0
  2033a8:	f6bf af7c 	bge.w	2032a4 <chprintf+0x244>
  2033ac:	e78c      	b.n	2032c8 <chprintf+0x268>
  2033ae:	7851      	ldrb	r1, [r2, #1]
      filler = '0';
  2033b0:	f04f 0830 	mov.w	r8, #48	; 0x30
      fmt++;
  2033b4:	3201      	adds	r2, #1
  2033b6:	e682      	b.n	2030be <chprintf+0x5e>
      fmt++;
  2033b8:	1caa      	adds	r2, r5, #2
  2033ba:	78a9      	ldrb	r1, [r5, #2]
      left_align = TRUE;
  2033bc:	f04f 0c01 	mov.w	ip, #1
  2033c0:	e678      	b.n	2030b4 <chprintf+0x54>
      for (p = s; *p && (--precision >= 0); p++)
  2033c2:	b1db      	cbz	r3, 2033fc <chprintf+0x39c>
  2033c4:	1e53      	subs	r3, r2, #1
  2033c6:	e7a1      	b.n	20330c <chprintf+0x2ac>
        *p++ = '-';
  2033c8:	232d      	movs	r3, #45	; 0x2d
        l = -l;
  2033ca:	4249      	negs	r1, r1
        *p++ = '-';
  2033cc:	f10d 020d 	add.w	r2, sp, #13
  2033d0:	af03      	add	r7, sp, #12
  2033d2:	f88d 300c 	strb.w	r3, [sp, #12]
  2033d6:	e7bb      	b.n	203350 <chprintf+0x2f0>
      if (precision == 0)
  2033d8:	b90a      	cbnz	r2, 2033de <chprintf+0x37e>
        precision = 32767;
  2033da:	f647 72ff 	movw	r2, #32767	; 0x7fff
        s = "(null)";
  2033de:	4f0b      	ldr	r7, [pc, #44]	; (20340c <chprintf+0x3ac>)
  2033e0:	e7f0      	b.n	2033c4 <chprintf+0x364>
  2033e2:	9a01      	ldr	r2, [sp, #4]
        streamPut(chp, (uint8_t)*s++);
  2033e4:	212d      	movs	r1, #45	; 0x2d
  2033e6:	f8da 3000 	ldr.w	r3, [sl]
  2033ea:	4650      	mov	r0, sl
  2033ec:	3a01      	subs	r2, #1
  2033ee:	3701      	adds	r7, #1
  2033f0:	689b      	ldr	r3, [r3, #8]
        n++;
  2033f2:	f10b 0b01 	add.w	fp, fp, #1
  2033f6:	9201      	str	r2, [sp, #4]
        streamPut(chp, (uint8_t)*s++);
  2033f8:	4798      	blx	r3
  2033fa:	e744      	b.n	203286 <chprintf+0x226>
      for (p = s; *p && (--precision >= 0); p++)
  2033fc:	f04f 33ff 	mov.w	r3, #4294967295
  203400:	f04f 0820 	mov.w	r8, #32
  203404:	9301      	str	r3, [sp, #4]
  203406:	e72e      	b.n	203266 <chprintf+0x206>
  203408:	cccccccd 	.word	0xcccccccd
  20340c:	08003e28 	.word	0x08003e28

00203410 <__early_init>:

static void stm32_gpio_init(void) {

  /* Enabling GPIO-related clocks, the mask comes from the
     registry header file.*/
  rccResetAHB1(STM32_GPIO_EN_MASK);
  203410:	4a91      	ldr	r2, [pc, #580]	; (203658 <__early_init+0x248>)
  203412:	2300      	movs	r3, #0
  gpiop->ODR     = config->odr;
  203414:	f64f 70ff 	movw	r0, #65535	; 0xffff
  203418:	f64b 7c7e 	movw	ip, #49022	; 0xbf7e
  gpiop->OTYPER  = config->otyper;
  20341c:	498f      	ldr	r1, [pc, #572]	; (20365c <__early_init+0x24c>)
/**
 * @brief   Early initialization code.
 * @details GPIO ports and system clocks are initialized before everything
 *          else.
 */
void __early_init(void) {
  20341e:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  rccResetAHB1(STM32_GPIO_EN_MASK);
  203422:	6915      	ldr	r5, [r2, #16]
  203424:	f240 7eff 	movw	lr, #2047	; 0x7ff
  gpiop->OTYPER  = config->otyper;
  203428:	4c8d      	ldr	r4, [pc, #564]	; (203660 <__early_init+0x250>)
  gpiop->OSPEEDR = config->ospeedr;
  20342a:	f04f 36ff 	mov.w	r6, #4294967295
  rccResetAHB1(STM32_GPIO_EN_MASK);
  20342e:	ea45 050e 	orr.w	r5, r5, lr
  gpiop->AFRH    = config->afrh;
  203432:	f8df 8274 	ldr.w	r8, [pc, #628]	; 2036a8 <__early_init+0x298>
  203436:	f44f 0730 	mov.w	r7, #11534336	; 0xb00000
  gpiop->OSPEEDR = config->ospeedr;
  20343a:	f06f 4970 	mvn.w	r9, #4026531840	; 0xf0000000
  rccResetAHB1(STM32_GPIO_EN_MASK);
  20343e:	6115      	str	r5, [r2, #16]
  203440:	6113      	str	r3, [r2, #16]
  rccEnableAHB1(STM32_GPIO_EN_MASK, true);
  203442:	6b15      	ldr	r5, [r2, #48]	; 0x30
  203444:	ea45 050e 	orr.w	r5, r5, lr
  203448:	6315      	str	r5, [r2, #48]	; 0x30
  20344a:	6d15      	ldr	r5, [r2, #80]	; 0x50
  20344c:	ea45 050e 	orr.w	r5, r5, lr
  gpiop->PUPDR   = config->pupdr;
  203450:	f8df e258 	ldr.w	lr, [pc, #600]	; 2036ac <__early_init+0x29c>
  rccEnableAHB1(STM32_GPIO_EN_MASK, true);
  203454:	6515      	str	r5, [r2, #80]	; 0x50
  gpiop->MODER   = config->moder;
  203456:	f640 2508 	movw	r5, #2568	; 0xa08
  gpiop->OTYPER  = config->otyper;
  20345a:	6063      	str	r3, [r4, #4]
  gpiop->OSPEEDR = config->ospeedr;
  20345c:	60a6      	str	r6, [r4, #8]
  gpiop->PUPDR   = config->pupdr;
  20345e:	f8c4 e00c 	str.w	lr, [r4, #12]
  gpiop->AFRL    = config->afrl;
  203462:	f8df e24c 	ldr.w	lr, [pc, #588]	; 2036b0 <__early_init+0x2a0>
  gpiop->ODR     = config->odr;
  203466:	6160      	str	r0, [r4, #20]
  gpiop->AFRL    = config->afrl;
  203468:	f8c4 e020 	str.w	lr, [r4, #32]
  gpiop->OSPEEDR = config->ospeedr;
  20346c:	f46f 1e40 	mvn.w	lr, #3145728	; 0x300000
  gpiop->AFRH    = config->afrh;
  203470:	f8c4 8024 	str.w	r8, [r4, #36]	; 0x24
  gpiop->MODER   = config->moder;
  203474:	f8df 823c 	ldr.w	r8, [pc, #572]	; 2036b4 <__early_init+0x2a4>
  203478:	f8c4 8000 	str.w	r8, [r4]
  gpiop->AFRH    = config->afrh;
  20347c:	f04f 0877 	mov.w	r8, #119	; 0x77
  gpiop->OTYPER  = config->otyper;
  203480:	f8c4 3404 	str.w	r3, [r4, #1028]	; 0x404
  gpiop->OSPEEDR = config->ospeedr;
  203484:	f8c4 6408 	str.w	r6, [r4, #1032]	; 0x408
  gpiop->PUPDR   = config->pupdr;
  203488:	f106 468a 	add.w	r6, r6, #1157627904	; 0x45000000
  20348c:	f106 1655 	add.w	r6, r6, #5570645	; 0x550055
  203490:	f506 56a8 	add.w	r6, r6, #5376	; 0x1500
  203494:	f8c4 640c 	str.w	r6, [r4, #1036]	; 0x40c
  gpiop->MODER   = config->moder;
  203498:	4e72      	ldr	r6, [pc, #456]	; (203664 <__early_init+0x254>)
  gpiop->ODR     = config->odr;
  20349a:	f8c4 c414 	str.w	ip, [r4, #1044]	; 0x414
  gpiop->MODER   = config->moder;
  20349e:	f44f 2c20 	mov.w	ip, #655360	; 0xa0000
  gpiop->AFRL    = config->afrl;
  2034a2:	f8c4 3420 	str.w	r3, [r4, #1056]	; 0x420
  gpiop->AFRH    = config->afrh;
  2034a6:	f8c4 7424 	str.w	r7, [r4, #1060]	; 0x424
  gpiop->PUPDR   = config->pupdr;
  2034aa:	f04f 3755 	mov.w	r7, #1431655765	; 0x55555555
  gpiop->MODER   = config->moder;
  2034ae:	f8c4 6400 	str.w	r6, [r4, #1024]	; 0x400
  2034b2:	f04f 6608 	mov.w	r6, #142606336	; 0x8800000
  gpiop->OTYPER  = config->otyper;
  2034b6:	f8c4 3804 	str.w	r3, [r4, #2052]	; 0x804
  gpiop->OSPEEDR = config->ospeedr;
  2034ba:	f8c4 9808 	str.w	r9, [r4, #2056]	; 0x808
  gpiop->PUPDR   = config->pupdr;
  2034be:	f8df 91f8 	ldr.w	r9, [pc, #504]	; 2036b8 <__early_init+0x2a8>
  2034c2:	f8c4 980c 	str.w	r9, [r4, #2060]	; 0x80c
  gpiop->AFRL    = config->afrl;
  2034c6:	f8df 91f4 	ldr.w	r9, [pc, #500]	; 2036bc <__early_init+0x2ac>
  gpiop->ODR     = config->odr;
  2034ca:	f8c4 0814 	str.w	r0, [r4, #2068]	; 0x814
  gpiop->AFRL    = config->afrl;
  2034ce:	f8c4 9820 	str.w	r9, [r4, #2080]	; 0x820
  gpiop->AFRH    = config->afrh;
  2034d2:	f8c4 3824 	str.w	r3, [r4, #2084]	; 0x824
  gpiop->MODER   = config->moder;
  2034d6:	f8c4 5800 	str.w	r5, [r4, #2048]	; 0x800
  gpiop->OSPEEDR = config->ospeedr;
  2034da:	250f      	movs	r5, #15
  gpiop->PUPDR   = config->pupdr;
  2034dc:	4c62      	ldr	r4, [pc, #392]	; (203668 <__early_init+0x258>)
  gpiop->OTYPER  = config->otyper;
  2034de:	604b      	str	r3, [r1, #4]
  gpiop->OSPEEDR = config->ospeedr;
  2034e0:	f8c1 e008 	str.w	lr, [r1, #8]
#else
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
#endif

  /* PWR initialization.*/
  PWR->CR1 = STM32_VOS;
  2034e4:	f44f 4e40 	mov.w	lr, #49152	; 0xc000
  gpiop->PUPDR   = config->pupdr;
  2034e8:	60cc      	str	r4, [r1, #12]
  gpiop->OSPEEDR = config->ospeedr;
  2034ea:	4c60      	ldr	r4, [pc, #384]	; (20366c <__early_init+0x25c>)
  gpiop->ODR     = config->odr;
  2034ec:	6148      	str	r0, [r1, #20]
  gpiop->AFRL    = config->afrl;
  2034ee:	620b      	str	r3, [r1, #32]
  gpiop->AFRH    = config->afrh;
  2034f0:	f8c1 8024 	str.w	r8, [r1, #36]	; 0x24
  gpiop->MODER   = config->moder;
  2034f4:	f8c1 c000 	str.w	ip, [r1]
  gpiop->OTYPER  = config->otyper;
  2034f8:	f8c1 3404 	str.w	r3, [r1, #1028]	; 0x404
  gpiop->OSPEEDR = config->ospeedr;
  2034fc:	f8c1 4408 	str.w	r4, [r1, #1032]	; 0x408
  gpiop->PUPDR   = config->pupdr;
  203500:	f8c1 740c 	str.w	r7, [r1, #1036]	; 0x40c
  gpiop->OTYPER  = config->otyper;
  203504:	4c5a      	ldr	r4, [pc, #360]	; (203670 <__early_init+0x260>)
  gpiop->ODR     = config->odr;
  203506:	f8c1 0414 	str.w	r0, [r1, #1044]	; 0x414
  gpiop->AFRL    = config->afrl;
  20350a:	f8c1 3420 	str.w	r3, [r1, #1056]	; 0x420
  gpiop->AFRH    = config->afrh;
  20350e:	f8c1 3424 	str.w	r3, [r1, #1060]	; 0x424
  gpiop->MODER   = config->moder;
  203512:	f8c1 3400 	str.w	r3, [r1, #1024]	; 0x400
  gpiop->OSPEEDR = config->ospeedr;
  203516:	4957      	ldr	r1, [pc, #348]	; (203674 <__early_init+0x264>)
  gpiop->OTYPER  = config->otyper;
  203518:	6063      	str	r3, [r4, #4]
  gpiop->OSPEEDR = config->ospeedr;
  20351a:	60a1      	str	r1, [r4, #8]
  gpiop->PUPDR   = config->pupdr;
  20351c:	60e7      	str	r7, [r4, #12]
  gpiop->OTYPER  = config->otyper;
  20351e:	4956      	ldr	r1, [pc, #344]	; (203678 <__early_init+0x268>)
  gpiop->ODR     = config->odr;
  203520:	6160      	str	r0, [r4, #20]
  gpiop->AFRL    = config->afrl;
  203522:	6223      	str	r3, [r4, #32]
  gpiop->AFRH    = config->afrh;
  203524:	6263      	str	r3, [r4, #36]	; 0x24
  gpiop->MODER   = config->moder;
  203526:	6023      	str	r3, [r4, #0]
  gpiop->OSPEEDR = config->ospeedr;
  203528:	4c54      	ldr	r4, [pc, #336]	; (20367c <__early_init+0x26c>)
  gpiop->OTYPER  = config->otyper;
  20352a:	604b      	str	r3, [r1, #4]
  gpiop->PUPDR   = config->pupdr;
  20352c:	f8df c190 	ldr.w	ip, [pc, #400]	; 2036c0 <__early_init+0x2b0>
  gpiop->OSPEEDR = config->ospeedr;
  203530:	608c      	str	r4, [r1, #8]
  gpiop->AFRH    = config->afrh;
  203532:	4c53      	ldr	r4, [pc, #332]	; (203680 <__early_init+0x270>)
  gpiop->PUPDR   = config->pupdr;
  203534:	f8c1 c00c 	str.w	ip, [r1, #12]
  gpiop->ODR     = config->odr;
  203538:	6148      	str	r0, [r1, #20]
  gpiop->AFRL    = config->afrl;
  20353a:	620b      	str	r3, [r1, #32]
  gpiop->AFRH    = config->afrh;
  20353c:	624c      	str	r4, [r1, #36]	; 0x24
  gpiop->OTYPER  = config->otyper;
  20353e:	4c51      	ldr	r4, [pc, #324]	; (203684 <__early_init+0x274>)
  gpiop->MODER   = config->moder;
  203540:	600e      	str	r6, [r1, #0]

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
  while (!(RCC->CR & RCC_CR_HSIRDY))
  203542:	4611      	mov	r1, r2
  gpiop->PUPDR   = config->pupdr;
  203544:	4e50      	ldr	r6, [pc, #320]	; (203688 <__early_init+0x278>)
  gpiop->OTYPER  = config->otyper;
  203546:	6063      	str	r3, [r4, #4]
  gpiop->OSPEEDR = config->ospeedr;
  203548:	60a5      	str	r5, [r4, #8]
  gpiop->OTYPER  = config->otyper;
  20354a:	4d50      	ldr	r5, [pc, #320]	; (20368c <__early_init+0x27c>)
  gpiop->PUPDR   = config->pupdr;
  20354c:	60e6      	str	r6, [r4, #12]
  gpiop->OTYPER  = config->otyper;
  20354e:	4e50      	ldr	r6, [pc, #320]	; (203690 <__early_init+0x280>)
  gpiop->ODR     = config->odr;
  203550:	6160      	str	r0, [r4, #20]
  gpiop->AFRL    = config->afrl;
  203552:	6223      	str	r3, [r4, #32]
  gpiop->AFRH    = config->afrh;
  203554:	6263      	str	r3, [r4, #36]	; 0x24
  gpiop->MODER   = config->moder;
  203556:	6023      	str	r3, [r4, #0]
  gpiop->OTYPER  = config->otyper;
  203558:	6073      	str	r3, [r6, #4]
  gpiop->OSPEEDR = config->ospeedr;
  20355a:	60b3      	str	r3, [r6, #8]
  gpiop->PUPDR   = config->pupdr;
  20355c:	60f7      	str	r7, [r6, #12]
  gpiop->ODR     = config->odr;
  20355e:	6170      	str	r0, [r6, #20]
  gpiop->AFRL    = config->afrl;
  203560:	6233      	str	r3, [r6, #32]
  gpiop->AFRH    = config->afrh;
  203562:	6273      	str	r3, [r6, #36]	; 0x24
  gpiop->MODER   = config->moder;
  203564:	6033      	str	r3, [r6, #0]
  gpiop->OTYPER  = config->otyper;
  203566:	606b      	str	r3, [r5, #4]
  RCC->APB1ENR = RCC_APB1ENR_PWREN | RCC_APB1ENR_RTCEN;
  203568:	4e4a      	ldr	r6, [pc, #296]	; (203694 <__early_init+0x284>)
  gpiop->OSPEEDR = config->ospeedr;
  20356a:	60ab      	str	r3, [r5, #8]
  gpiop->PUPDR   = config->pupdr;
  20356c:	60ef      	str	r7, [r5, #12]
  gpiop->ODR     = config->odr;
  20356e:	6168      	str	r0, [r5, #20]
  gpiop->AFRL    = config->afrl;
  203570:	622b      	str	r3, [r5, #32]
  gpiop->AFRH    = config->afrh;
  203572:	626b      	str	r3, [r5, #36]	; 0x24
  gpiop->MODER   = config->moder;
  203574:	602b      	str	r3, [r5, #0]
  PWR->CR1 = STM32_VOS;
  203576:	f5a5 35da 	sub.w	r5, r5, #111616	; 0x1b400
  gpiop->OTYPER  = config->otyper;
  20357a:	f8c4 3c04 	str.w	r3, [r4, #3076]	; 0xc04
  gpiop->OSPEEDR = config->ospeedr;
  20357e:	f8c4 3c08 	str.w	r3, [r4, #3080]	; 0xc08
  gpiop->PUPDR   = config->pupdr;
  203582:	f8c4 7c0c 	str.w	r7, [r4, #3084]	; 0xc0c
  gpiop->ODR     = config->odr;
  203586:	f8c4 0c14 	str.w	r0, [r4, #3092]	; 0xc14
  gpiop->AFRL    = config->afrl;
  20358a:	f8c4 3c20 	str.w	r3, [r4, #3104]	; 0xc20
  gpiop->AFRH    = config->afrh;
  20358e:	f8c4 3c24 	str.w	r3, [r4, #3108]	; 0xc24
  gpiop->MODER   = config->moder;
  203592:	f8c4 3c00 	str.w	r3, [r4, #3072]	; 0xc00
  RCC->APB1ENR = RCC_APB1ENR_PWREN | RCC_APB1ENR_RTCEN;
  203596:	6416      	str	r6, [r2, #64]	; 0x40
  PWR->CR1 = STM32_VOS;
  203598:	f8c5 e000 	str.w	lr, [r5]
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
  20359c:	6813      	ldr	r3, [r2, #0]
  20359e:	f043 0301 	orr.w	r3, r3, #1
  2035a2:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
  2035a4:	680b      	ldr	r3, [r1, #0]
  2035a6:	079e      	lsls	r6, r3, #30
  2035a8:	d5fc      	bpl.n	2035a4 <__early_init+0x194>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
  2035aa:	688b      	ldr	r3, [r1, #8]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
  2035ac:	4a2a      	ldr	r2, [pc, #168]	; (203658 <__early_init+0x248>)
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
  2035ae:	f023 0303 	bic.w	r3, r3, #3
  2035b2:	608b      	str	r3, [r1, #8]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
  2035b4:	688b      	ldr	r3, [r1, #8]
  2035b6:	608b      	str	r3, [r1, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
  2035b8:	6893      	ldr	r3, [r2, #8]
  2035ba:	f013 030c 	ands.w	r3, r3, #12
  2035be:	d1fb      	bne.n	2035b8 <__early_init+0x1a8>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
  2035c0:	6810      	ldr	r0, [r2, #0]
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
#endif
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
  2035c2:	4925      	ldr	r1, [pc, #148]	; (203658 <__early_init+0x248>)
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
  2035c4:	f000 00f9 	and.w	r0, r0, #249	; 0xf9
  2035c8:	6010      	str	r0, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
  2035ca:	6093      	str	r3, [r2, #8]
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
  2035cc:	6813      	ldr	r3, [r2, #0]
  2035ce:	f443 23a0 	orr.w	r3, r3, #327680	; 0x50000
  2035d2:	6013      	str	r3, [r2, #0]
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
  2035d4:	680b      	ldr	r3, [r1, #0]
  2035d6:	039d      	lsls	r5, r3, #14
  2035d8:	d5fc      	bpl.n	2035d4 <__early_init+0x1c4>
    ;                           /* Waits until LSI is stable.               */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
  2035da:	4b2f      	ldr	r3, [pc, #188]	; (203698 <__early_init+0x288>)
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;

  /* Synchronization with voltage regulator stabilization.*/
  while ((PWR->CSR1 & PWR_CSR1_VOSRDY) == 0)
  2035dc:	482f      	ldr	r0, [pc, #188]	; (20369c <__early_init+0x28c>)
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
  2035de:	604b      	str	r3, [r1, #4]
  RCC->CR |= RCC_CR_PLLON;
  2035e0:	680b      	ldr	r3, [r1, #0]
  2035e2:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
  2035e6:	600b      	str	r3, [r1, #0]
  while ((PWR->CSR1 & PWR_CSR1_VOSRDY) == 0)
  2035e8:	6843      	ldr	r3, [r0, #4]
  2035ea:	045c      	lsls	r4, r3, #17
  2035ec:	d5fc      	bpl.n	2035e8 <__early_init+0x1d8>
    ;                           /* Waits until power regulator is stable.   */

#if STM32_OVERDRIVE_REQUIRED
  /* Overdrive activation performed after activating the PLL in order to save
     time as recommended in RM in "Entering Over-drive mode" paragraph.*/
  PWR->CR1 |= PWR_CR1_ODEN;
  2035ee:	6803      	ldr	r3, [r0, #0]
  while (!(PWR->CSR1 & PWR_CSR1_ODRDY))
  2035f0:	4a2a      	ldr	r2, [pc, #168]	; (20369c <__early_init+0x28c>)
  PWR->CR1 |= PWR_CR1_ODEN;
  2035f2:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
  2035f6:	6003      	str	r3, [r0, #0]
  while (!(PWR->CSR1 & PWR_CSR1_ODRDY))
  2035f8:	6853      	ldr	r3, [r2, #4]
  2035fa:	03d9      	lsls	r1, r3, #15
  2035fc:	d5fc      	bpl.n	2035f8 <__early_init+0x1e8>
      ;
  PWR->CR1 |= PWR_CR1_ODSWEN;
  2035fe:	6813      	ldr	r3, [r2, #0]
  while (!(PWR->CSR1 & PWR_CSR1_ODSWRDY))
  203600:	4926      	ldr	r1, [pc, #152]	; (20369c <__early_init+0x28c>)
  PWR->CR1 |= PWR_CR1_ODSWEN;
  203602:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  203606:	6013      	str	r3, [r2, #0]
  while (!(PWR->CSR1 & PWR_CSR1_ODSWRDY))
  203608:	684b      	ldr	r3, [r1, #4]
  20360a:	039a      	lsls	r2, r3, #14
  20360c:	d5fc      	bpl.n	203608 <__early_init+0x1f8>
      ;
#endif /* STM32_OVERDRIVE_REQUIRED */

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLRDY))
  20360e:	4a12      	ldr	r2, [pc, #72]	; (203658 <__early_init+0x248>)
  203610:	6813      	ldr	r3, [r2, #0]
  203612:	019b      	lsls	r3, r3, #6
  203614:	d5fc      	bpl.n	203610 <__early_init+0x200>
                  STM32_UART8SEL  | STM32_UART7SEL  | STM32_USART6SEL |
                  STM32_UART5SEL  | STM32_UART4SEL  | STM32_USART3SEL |
                  STM32_USART2SEL | STM32_USART1SEL;

  /* Flash setup.*/
  FLASH->ACR = FLASH_ACR_ARTEN | FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  203616:	4b22      	ldr	r3, [pc, #136]	; (2036a0 <__early_init+0x290>)
  203618:	f240 3109 	movw	r1, #777	; 0x309
  RCC->CFGR = STM32_MCO2SEL | STM32_MCO2PRE | STM32_MCO1PRE | STM32_I2SSRC |
  20361c:	4d21      	ldr	r5, [pc, #132]	; (2036a4 <__early_init+0x294>)
    RCC->DCKCFGR1 = dckcfgr1;
  20361e:	f240 1401 	movw	r4, #257	; 0x101
  RCC->DCKCFGR2 = STM32_SDMMC2SEL | STM32_SDMMC1SEL | STM32_CK48MSEL  |
  203622:	2000      	movs	r0, #0
  RCC->CFGR = STM32_MCO2SEL | STM32_MCO2PRE | STM32_MCO1PRE | STM32_I2SSRC |
  203624:	6095      	str	r5, [r2, #8]
    RCC->DCKCFGR1 = dckcfgr1;
  203626:	f8c2 408c 	str.w	r4, [r2, #140]	; 0x8c
  RCC->DCKCFGR2 = STM32_SDMMC2SEL | STM32_SDMMC1SEL | STM32_CK48MSEL  |
  20362a:	f8c2 0090 	str.w	r0, [r2, #144]	; 0x90
  FLASH->ACR = FLASH_ACR_ARTEN | FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  20362e:	6019      	str	r1, [r3, #0]

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
  203630:	6893      	ldr	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
  203632:	4909      	ldr	r1, [pc, #36]	; (203658 <__early_init+0x248>)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
  203634:	f043 0302 	orr.w	r3, r3, #2
  203638:	6093      	str	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
  20363a:	688b      	ldr	r3, [r1, #8]
  20363c:	f003 030c 	and.w	r3, r3, #12
  203640:	2b08      	cmp	r3, #8
  203642:	d1fa      	bne.n	20363a <__early_init+0x22a>
#endif
#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, true);
  203644:	6c4b      	ldr	r3, [r1, #68]	; 0x44
  203646:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
  20364a:	644b      	str	r3, [r1, #68]	; 0x44
  20364c:	6e4b      	ldr	r3, [r1, #100]	; 0x64
  20364e:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
  203652:	664b      	str	r3, [r1, #100]	; 0x64
  203654:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  203658:	40023800 	.word	0x40023800
  20365c:	40020c00 	.word	0x40020c00
  203660:	40020000 	.word	0x40020000
  203664:	18004001 	.word	0x18004001
  203668:	55505555 	.word	0x55505555
  20366c:	cffffff3 	.word	0xcffffff3
  203670:	40021400 	.word	0x40021400
  203674:	003fcfff 	.word	0x003fcfff
  203678:	40021800 	.word	0x40021800
  20367c:	3cccf000 	.word	0x3cccf000
  203680:	00b0b000 	.word	0x00b0b000
  203684:	40021c00 	.word	0x40021c00
  203688:	55555550 	.word	0x55555550
  20368c:	40022400 	.word	0x40022400
  203690:	40022000 	.word	0x40022000
  203694:	10000400 	.word	0x10000400
  203698:	09406c08 	.word	0x09406c08
  20369c:	40007000 	.word	0x40007000
  2036a0:	40023c00 	.word	0x40023c00
  2036a4:	30999400 	.word	0x30999400
  2036a8:	000aaa0a 	.word	0x000aaa0a
  2036ac:	40005551 	.word	0x40005551
  2036b0:	b0000bb0 	.word	0xb0000bb0
  2036b4:	2aae8028 	.word	0x2aae8028
  2036b8:	01555051 	.word	0x01555051
  2036bc:	00bb00b0 	.word	0x00bb00b0
  2036c0:	51155555 	.word	0x51155555
	...

002036d0 <VectorB0>:
OSAL_IRQ_HANDLER(ST_HANDLER) {
  2036d0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
  2036d4:	f04f 4680 	mov.w	r6, #1073741824	; 0x40000000
  2036d8:	6933      	ldr	r3, [r6, #16]
  2036da:	079b      	lsls	r3, r3, #30
  2036dc:	d403      	bmi.n	2036e6 <VectorB0+0x16>
}
  2036de:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  OSAL_IRQ_EPILOGUE();
  2036e2:	f7fd bca5 	b.w	201030 <_port_irq_epilogue>
    STM32_ST_TIM->SR = 0U;
  2036e6:	2300      	movs	r3, #0
  2036e8:	2220      	movs	r2, #32
  2036ea:	6133      	str	r3, [r6, #16]
  2036ec:	f382 8811 	msr	BASEPRI, r2
  virtual_timer_t *vtp;
  systime_t now;
  sysinterval_t delta, nowdelta;

  /* Looping through timers.*/
  vtp = ch.vtlist.next;
  2036f0:	4c1e      	ldr	r4, [pc, #120]	; (20376c <VectorB0+0x9c>)
  2036f2:	46b1      	mov	r9, r6
      nowdelta -= vtp->delta;

      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
      ch.vtlist.next = vtp->next;
      fn = vtp->func;
      vtp->func = NULL;
  2036f4:	4698      	mov	r8, r3
  vtp = ch.vtlist.next;
  2036f6:	4626      	mov	r6, r4
  2036f8:	f856 3f1c 	ldr.w	r3, [r6, #28]!
  2036fc:	689a      	ldr	r2, [r3, #8]
  2036fe:	f8d9 0024 	ldr.w	r0, [r9, #36]	; 0x24
    nowdelta = chTimeDiffX(ch.vtlist.lasttime, now);
  203702:	6aa1      	ldr	r1, [r4, #40]	; 0x28
  203704:	1a47      	subs	r7, r0, r1
    if (nowdelta < vtp->delta) {
  203706:	4297      	cmp	r7, r2
  203708:	d31a      	bcc.n	203740 <VectorB0+0x70>
  20370a:	2520      	movs	r5, #32
  20370c:	e00a      	b.n	203724 <VectorB0+0x54>
  20370e:	f388 8811 	msr	BASEPRI, r8
        port_timer_stop_alarm();
      }

      /* The callback is invoked outside the kernel critical zone.*/
      chSysUnlockFromISR();
      fn(vtp->par);
  203712:	6918      	ldr	r0, [r3, #16]
  203714:	4790      	blx	r2
  203716:	f385 8811 	msr	BASEPRI, r5
      chSysLockFromISR();

      /* Next element in the list.*/
      vtp = ch.vtlist.next;
  20371a:	69e3      	ldr	r3, [r4, #28]
    }
    while (vtp->delta <= nowdelta);
  20371c:	689a      	ldr	r2, [r3, #8]
  20371e:	4297      	cmp	r7, r2
  203720:	d3ed      	bcc.n	2036fe <VectorB0+0x2e>
  203722:	6aa1      	ldr	r1, [r4, #40]	; 0x28
      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
  203724:	6818      	ldr	r0, [r3, #0]
      ch.vtlist.lasttime += vtp->delta;
  203726:	4411      	add	r1, r2
      nowdelta -= vtp->delta;
  203728:	1abf      	subs	r7, r7, r2
      fn = vtp->func;
  20372a:	68da      	ldr	r2, [r3, #12]
      if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
  20372c:	42b0      	cmp	r0, r6
      ch.vtlist.lasttime += vtp->delta;
  20372e:	62a1      	str	r1, [r4, #40]	; 0x28
      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
  203730:	6046      	str	r6, [r0, #4]
      ch.vtlist.next = vtp->next;
  203732:	61e0      	str	r0, [r4, #28]
      vtp->func = NULL;
  203734:	f8c3 800c 	str.w	r8, [r3, #12]
      if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
  203738:	d1e9      	bne.n	20370e <VectorB0+0x3e>
  STM32_ST_TIM->DIER = 0;
  20373a:	f8c9 800c 	str.w	r8, [r9, #12]
  20373e:	e7e6      	b.n	20370e <VectorB0+0x3e>
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
  203740:	69e2      	ldr	r2, [r4, #28]
  203742:	42b2      	cmp	r2, r6
  203744:	d00a      	beq.n	20375c <VectorB0+0x8c>
  }

  /* The "unprocessed nowdelta" time slice is added to "last time"
     and subtracted to next timer's delta.*/
  ch.vtlist.lasttime += nowdelta;
  ch.vtlist.next->delta -= nowdelta;
  203746:	6891      	ldr	r1, [r2, #8]
  ch.vtlist.lasttime += nowdelta;
  203748:	62a0      	str	r0, [r4, #40]	; 0x28
  ch.vtlist.next->delta -= nowdelta;
  20374a:	1bcf      	subs	r7, r1, r7
  20374c:	6097      	str	r7, [r2, #8]
  return systime + (systime_t)interval;
  20374e:	689b      	ldr	r3, [r3, #8]
  203750:	2b02      	cmp	r3, #2
  203752:	bf2c      	ite	cs
  203754:	18c0      	addcs	r0, r0, r3
  203756:	3002      	addcc	r0, #2
  STM32_ST_TIM->CCR[0] = (uint32_t)time;
  203758:	f8c9 0034 	str.w	r0, [r9, #52]	; 0x34
  20375c:	2300      	movs	r3, #0
  20375e:	f383 8811 	msr	BASEPRI, r3
}
  203762:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  OSAL_IRQ_EPILOGUE();
  203766:	f7fd bc63 	b.w	201030 <_port_irq_epilogue>
  20376a:	bf00      	nop
  20376c:	200012a0 	.word	0x200012a0

00203770 <usb_lld_start_in>:
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
  203770:	eb00 0381 	add.w	r3, r0, r1, lsl #2
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
  203774:	b4f0      	push	{r4, r5, r6, r7}
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
  203776:	68dc      	ldr	r4, [r3, #12]
  203778:	6962      	ldr	r2, [r4, #20]
  isp->totsize = isp->txsize;
  20377a:	6813      	ldr	r3, [r2, #0]
  20377c:	60d3      	str	r3, [r2, #12]
  if (isp->txsize == 0) {
  20377e:	b34b      	cbz	r3, 2037d4 <usb_lld_start_in+0x64>
    if ((ep == 0) && (isp->txsize > EP0_MAX_INSIZE))
  203780:	2900      	cmp	r1, #0
  203782:	d146      	bne.n	203812 <usb_lld_start_in+0xa2>
  203784:	2b40      	cmp	r3, #64	; 0x40
  203786:	d944      	bls.n	203812 <usb_lld_start_in+0xa2>
      isp->txsize = EP0_MAX_INSIZE;
  203788:	2640      	movs	r6, #64	; 0x40
  20378a:	4d23      	ldr	r5, [pc, #140]	; (203818 <usb_lld_start_in+0xa8>)
  20378c:	4633      	mov	r3, r6
  20378e:	6016      	str	r6, [r2, #0]
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
  203790:	8a26      	ldrh	r6, [r4, #16]
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
  203792:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
  203794:	1e70      	subs	r0, r6, #1
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
  203796:	eb02 1741 	add.w	r7, r2, r1, lsl #5
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
  20379a:	4403      	add	r3, r0
  20379c:	fbb3 f3f6 	udiv	r3, r3, r6
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
  2037a0:	ea45 43c3 	orr.w	r3, r5, r3, lsl #19
  2037a4:	f8c7 3910 	str.w	r3, [r7, #2320]	; 0x910
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
  2037a8:	6823      	ldr	r3, [r4, #0]
  2037aa:	f003 0303 	and.w	r3, r3, #3
  2037ae:	2b01      	cmp	r3, #1
  2037b0:	d11c      	bne.n	2037ec <usb_lld_start_in+0x7c>
  2037b2:	b208      	sxth	r0, r1
    if (usbp->otg->DSTS & DSTS_FNSOF_ODD)
  2037b4:	f8d2 3808 	ldr.w	r3, [r2, #2056]	; 0x808
  2037b8:	eb02 1440 	add.w	r4, r2, r0, lsl #5
  2037bc:	f413 7f80 	tst.w	r3, #256	; 0x100
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SEVNFRM;
  2037c0:	f8d4 3900 	ldr.w	r3, [r4, #2304]	; 0x900
  2037c4:	bf14      	ite	ne
  2037c6:	f043 5380 	orrne.w	r3, r3, #268435456	; 0x10000000
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SODDFRM;
  2037ca:	f043 5300 	orreq.w	r3, r3, #536870912	; 0x20000000
  2037ce:	f8c4 3900 	str.w	r3, [r4, #2304]	; 0x900
  2037d2:	e00c      	b.n	2037ee <usb_lld_start_in+0x7e>
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(1) | DIEPTSIZ_XFRSIZ(0);
  2037d4:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
  2037d6:	f44f 2000 	mov.w	r0, #524288	; 0x80000
  2037da:	eb02 1341 	add.w	r3, r2, r1, lsl #5
  2037de:	f8c3 0910 	str.w	r0, [r3, #2320]	; 0x910
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
  2037e2:	6823      	ldr	r3, [r4, #0]
  2037e4:	f003 0303 	and.w	r3, r3, #3
  2037e8:	2b01      	cmp	r3, #1
  2037ea:	d0e2      	beq.n	2037b2 <usb_lld_start_in+0x42>
  2037ec:	b208      	sxth	r0, r1
  2037ee:	eb02 1040 	add.w	r0, r2, r0, lsl #5
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
  2037f2:	2301      	movs	r3, #1
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
  2037f4:	f8d0 4900 	ldr.w	r4, [r0, #2304]	; 0x900
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
  2037f8:	fa03 f101 	lsl.w	r1, r3, r1
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
  2037fc:	f044 4404 	orr.w	r4, r4, #2214592512	; 0x84000000
  203800:	f8c0 4900 	str.w	r4, [r0, #2304]	; 0x900
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
  203804:	f8d2 3834 	ldr.w	r3, [r2, #2100]	; 0x834
  203808:	4319      	orrs	r1, r3
}
  20380a:	bcf0      	pop	{r4, r5, r6, r7}
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
  20380c:	f8c2 1834 	str.w	r1, [r2, #2100]	; 0x834
}
  203810:	4770      	bx	lr
  203812:	f043 5500 	orr.w	r5, r3, #536870912	; 0x20000000
  203816:	e7bb      	b.n	203790 <usb_lld_start_in+0x20>
  203818:	20000040 	.word	0x20000040
  20381c:	00000000 	.word	0x00000000

00203820 <usb_lld_start_out>:
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
  203820:	eb00 0381 	add.w	r3, r0, r1, lsl #2
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {
  203824:	b470      	push	{r4, r5, r6}
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
  203826:	68dc      	ldr	r4, [r3, #12]
  203828:	69a3      	ldr	r3, [r4, #24]
  osp->totsize = osp->rxsize;
  20382a:	681e      	ldr	r6, [r3, #0]
  20382c:	60de      	str	r6, [r3, #12]
  if ((ep == 0) && (osp->rxsize > EP0_MAX_OUTSIZE))
  20382e:	b921      	cbnz	r1, 20383a <usb_lld_start_out+0x1a>
  203830:	2e40      	cmp	r6, #64	; 0x40
  203832:	d902      	bls.n	20383a <usb_lld_start_out+0x1a>
      osp->rxsize = EP0_MAX_OUTSIZE;
  203834:	2240      	movs	r2, #64	; 0x40
  203836:	4616      	mov	r6, r2
  203838:	601a      	str	r2, [r3, #0]
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
  20383a:	8a63      	ldrh	r3, [r4, #18]
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
  20383c:	6824      	ldr	r4, [r4, #0]
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
  20383e:	1e5a      	subs	r2, r3, #1
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
  203840:	6ec0      	ldr	r0, [r0, #108]	; 0x6c
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
  203842:	f004 0403 	and.w	r4, r4, #3
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
  203846:	4432      	add	r2, r6
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
  203848:	eb00 1541 	add.w	r5, r0, r1, lsl #5
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
  20384c:	2c01      	cmp	r4, #1
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
  20384e:	fbb2 f2f3 	udiv	r2, r2, r3
  rxsize = (pcnt * usbp->epc[ep]->out_maxsize + 3U) & 0xFFFFFFFCU;
  203852:	fb02 f303 	mul.w	r3, r2, r3
  203856:	f103 0303 	add.w	r3, r3, #3
  20385a:	f023 0303 	bic.w	r3, r3, #3
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
  20385e:	ea43 43c2 	orr.w	r3, r3, r2, lsl #19
  203862:	f043 43c0 	orr.w	r3, r3, #1610612736	; 0x60000000
  203866:	f8c5 3b10 	str.w	r3, [r5, #2832]	; 0xb10
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
  20386a:	d00a      	beq.n	203882 <usb_lld_start_out+0x62>
  20386c:	b209      	sxth	r1, r1
  20386e:	eb00 1141 	add.w	r1, r0, r1, lsl #5
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_EPENA | DOEPCTL_CNAK;
  203872:	f8d1 3b00 	ldr.w	r3, [r1, #2816]	; 0xb00
  203876:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
}
  20387a:	bc70      	pop	{r4, r5, r6}
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_EPENA | DOEPCTL_CNAK;
  20387c:	f8c1 3b00 	str.w	r3, [r1, #2816]	; 0xb00
}
  203880:	4770      	bx	lr
  203882:	b209      	sxth	r1, r1
    if (usbp->otg->DSTS & DSTS_FNSOF_ODD)
  203884:	f8d0 3808 	ldr.w	r3, [r0, #2056]	; 0x808
  203888:	eb00 1241 	add.w	r2, r0, r1, lsl #5
  20388c:	f413 7f80 	tst.w	r3, #256	; 0x100
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SEVNFRM;
  203890:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	; 0xb00
  203894:	bf14      	ite	ne
  203896:	f043 5380 	orrne.w	r3, r3, #268435456	; 0x10000000
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SODDFRM;
  20389a:	f043 5300 	orreq.w	r3, r3, #536870912	; 0x20000000
  20389e:	f8c2 3b00 	str.w	r3, [r2, #2816]	; 0xb00
  2038a2:	e7e4      	b.n	20386e <usb_lld_start_out+0x4e>
	...

002038b0 <chSchWakeupS.constprop.40>:
  thread_t *otp = currp;
  2038b0:	4b15      	ldr	r3, [pc, #84]	; (203908 <chSchWakeupS.constprop.40+0x58>)
  if (ntp->prio <= otp->prio) {
  2038b2:	6881      	ldr	r1, [r0, #8]
void chSchWakeupS(thread_t *ntp, msg_t msg) {
  2038b4:	b4f0      	push	{r4, r5, r6, r7}
  ntp->u.rdymsg = msg;
  2038b6:	2600      	movs	r6, #0
  thread_t *otp = currp;
  2038b8:	699d      	ldr	r5, [r3, #24]
void chSchWakeupS(thread_t *ntp, msg_t msg) {
  2038ba:	4604      	mov	r4, r0
  ntp->u.rdymsg = msg;
  2038bc:	6246      	str	r6, [r0, #36]	; 0x24
  if (ntp->prio <= otp->prio) {
  2038be:	68a8      	ldr	r0, [r5, #8]
  2038c0:	4281      	cmp	r1, r0
  2038c2:	d80c      	bhi.n	2038de <chSchWakeupS.constprop.40+0x2e>
  tp->state = CH_STATE_READY;
  2038c4:	f884 6020 	strb.w	r6, [r4, #32]
    cp = cp->queue.next;
  2038c8:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
  2038ca:	689a      	ldr	r2, [r3, #8]
  2038cc:	4291      	cmp	r1, r2
  2038ce:	d9fb      	bls.n	2038c8 <chSchWakeupS.constprop.40+0x18>
  tp->queue.prev             = cp->queue.prev;
  2038d0:	685a      	ldr	r2, [r3, #4]
  tp->queue.next             = cp;
  2038d2:	6023      	str	r3, [r4, #0]
  tp->queue.prev             = cp->queue.prev;
  2038d4:	6062      	str	r2, [r4, #4]
  tp->queue.prev->queue.next = tp;
  2038d6:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
  2038d8:	605c      	str	r4, [r3, #4]
}
  2038da:	bcf0      	pop	{r4, r5, r6, r7}
  2038dc:	4770      	bx	lr
  cp = (thread_t *)&ch.rlist.queue;
  2038de:	461a      	mov	r2, r3
  tp->state = CH_STATE_READY;
  2038e0:	f885 6020 	strb.w	r6, [r5, #32]
    cp = cp->queue.next;
  2038e4:	6812      	ldr	r2, [r2, #0]
  } while (cp->prio >= tp->prio);
  2038e6:	6891      	ldr	r1, [r2, #8]
  2038e8:	4288      	cmp	r0, r1
  2038ea:	d9fb      	bls.n	2038e4 <chSchWakeupS.constprop.40+0x34>
  tp->queue.prev             = cp->queue.prev;
  2038ec:	6856      	ldr	r6, [r2, #4]
    ntp->state = CH_STATE_CURRENT;
  2038ee:	2701      	movs	r7, #1
  tp->queue.next             = cp;
  2038f0:	602a      	str	r2, [r5, #0]
    chSysSwitch(ntp, otp);
  2038f2:	4629      	mov	r1, r5
  tp->queue.prev             = cp->queue.prev;
  2038f4:	606e      	str	r6, [r5, #4]
    chSysSwitch(ntp, otp);
  2038f6:	4620      	mov	r0, r4
  tp->queue.prev->queue.next = tp;
  2038f8:	6035      	str	r5, [r6, #0]
  cp->queue.prev             = tp;
  2038fa:	6055      	str	r5, [r2, #4]
    ntp->state = CH_STATE_CURRENT;
  2038fc:	f884 7020 	strb.w	r7, [r4, #32]
    currp = ntp;
  203900:	619c      	str	r4, [r3, #24]
}
  203902:	bcf0      	pop	{r4, r5, r6, r7}
    chSysSwitch(ntp, otp);
  203904:	f7fc bcec 	b.w	2002e0 <_port_switch>
  203908:	200012a0 	.word	0x200012a0
  20390c:	00000000 	.word	0x00000000

00203910 <chTMStartMeasurementX.constprop.35>:
  return DWT->CYCCNT;
  203910:	4b01      	ldr	r3, [pc, #4]	; (203918 <chTMStartMeasurementX.constprop.35+0x8>)
  203912:	685b      	ldr	r3, [r3, #4]
  tmp->last = chSysGetRealtimeCounterX();
  203914:	6083      	str	r3, [r0, #8]
  203916:	4770      	bx	lr
  203918:	e0001000 	.word	0xe0001000
  20391c:	00000000 	.word	0x00000000

00203920 <_pal_lld_setgroupmode.constprop.9>:
 * @param[in] mask      the group mask
 * @param[in] mode      the mode
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
  203920:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
                           ioportmask_t mask,
                           iomode_t mode) {

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
  203924:	2503      	movs	r5, #3
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
  203926:	2100      	movs	r1, #0
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
  203928:	f04f 0e0f 	mov.w	lr, #15
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
  20392c:	4c22      	ldr	r4, [pc, #136]	; (2039b8 <_pal_lld_setgroupmode.constprop.9+0x98>)
      m2 = 3 << (bit * 2);
  20392e:	462f      	mov	r7, r5
      m1 = 1 << bit;
  203930:	2601      	movs	r6, #1
  203932:	e009      	b.n	203948 <_pal_lld_setgroupmode.constprop.9+0x28>
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
  203934:	6a23      	ldr	r3, [r4, #32]
  203936:	ea23 0202 	bic.w	r2, r3, r2
  20393a:	6222      	str	r2, [r4, #32]
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
      }
    }
    mask >>= 1;
    if (!mask)
  20393c:	0840      	lsrs	r0, r0, #1
      return;
    otyper <<= 1;
    ospeedr <<= 2;
    pupdr <<= 2;
    moder <<= 2;
    bit++;
  20393e:	f101 0101 	add.w	r1, r1, #1
    moder <<= 2;
  203942:	ea4f 0585 	mov.w	r5, r5, lsl #2
    if (!mask)
  203946:	d034      	beq.n	2039b2 <_pal_lld_setgroupmode.constprop.9+0x92>
      m2 = 3 << (bit * 2);
  203948:	004b      	lsls	r3, r1, #1
      altrmask = altr << ((bit & 7) * 4);
  20394a:	f001 0207 	and.w	r2, r1, #7
    if ((mask & 1) != 0) {
  20394e:	f010 0f01 	tst.w	r0, #1
      m1 = 1 << bit;
  203952:	fa06 fc01 	lsl.w	ip, r6, r1
      m2 = 3 << (bit * 2);
  203956:	fa07 f303 	lsl.w	r3, r7, r3
      altrmask = altr << ((bit & 7) * 4);
  20395a:	ea4f 0282 	mov.w	r2, r2, lsl #2
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
  20395e:	ea6f 0303 	mvn.w	r3, r3
    if ((mask & 1) != 0) {
  203962:	d0eb      	beq.n	20393c <_pal_lld_setgroupmode.constprop.9+0x1c>
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
  203964:	f8d4 8004 	ldr.w	r8, [r4, #4]
        if (bit < 8)
  203968:	2907      	cmp	r1, #7
      m4 = 15 << ((bit & 7) * 4);
  20396a:	fa0e f202 	lsl.w	r2, lr, r2
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
  20396e:	ea28 0c0c 	bic.w	ip, r8, ip
  203972:	f8c4 c004 	str.w	ip, [r4, #4]
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
  203976:	f8d4 c008 	ldr.w	ip, [r4, #8]
  20397a:	ea0c 0c03 	and.w	ip, ip, r3
  20397e:	f8c4 c008 	str.w	ip, [r4, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
  203982:	f8d4 c00c 	ldr.w	ip, [r4, #12]
  203986:	ea03 0c0c 	and.w	ip, r3, ip
  20398a:	f8c4 c00c 	str.w	ip, [r4, #12]
        port->MODER   = (port->MODER & ~m2) | moder;
  20398e:	f8d4 c000 	ldr.w	ip, [r4]
  203992:	ea03 030c 	and.w	r3, r3, ip
  203996:	ea43 0305 	orr.w	r3, r3, r5
  20399a:	6023      	str	r3, [r4, #0]
        if (bit < 8)
  20399c:	d9ca      	bls.n	203934 <_pal_lld_setgroupmode.constprop.9+0x14>
          port->AFRH = (port->AFRH & ~m4) | altrmask;
  20399e:	6a63      	ldr	r3, [r4, #36]	; 0x24
    if (!mask)
  2039a0:	0840      	lsrs	r0, r0, #1
    bit++;
  2039a2:	f101 0101 	add.w	r1, r1, #1
    moder <<= 2;
  2039a6:	ea4f 0585 	mov.w	r5, r5, lsl #2
          port->AFRH = (port->AFRH & ~m4) | altrmask;
  2039aa:	ea23 0202 	bic.w	r2, r3, r2
  2039ae:	6262      	str	r2, [r4, #36]	; 0x24
    if (!mask)
  2039b0:	d1ca      	bne.n	203948 <_pal_lld_setgroupmode.constprop.9+0x28>
  }
}
  2039b2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  2039b6:	bf00      	nop
  2039b8:	40020000 	.word	0x40020000
  2039bc:	00000000 	.word	0x00000000

002039c0 <otg_txfifo_handler.constprop.7>:
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize) {
  2039c0:	4a27      	ldr	r2, [pc, #156]	; (203a60 <otg_txfifo_handler.constprop.7+0xa0>)
  2039c2:	eb02 0380 	add.w	r3, r2, r0, lsl #2
  2039c6:	68d9      	ldr	r1, [r3, #12]
static bool otg_txfifo_handler(USBDriver *usbp, usbep_t ep) {
  2039c8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize) {
  2039cc:	f8d1 e014 	ldr.w	lr, [r1, #20]
  2039d0:	f8d2 906c 	ldr.w	r9, [r2, #108]	; 0x6c
  2039d4:	e89e 0060 	ldmia.w	lr, {r5, r6}
  2039d8:	42b5      	cmp	r5, r6
  2039da:	d935      	bls.n	203a48 <otg_txfifo_handler.constprop.7+0x88>
    n = usbp->epc[ep]->in_state->txsize - usbp->epc[ep]->in_state->txcnt;
  2039dc:	1bad      	subs	r5, r5, r6
    if (n > usbp->epc[ep]->in_maxsize)
  2039de:	f8b1 8010 	ldrh.w	r8, [r1, #16]
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
  2039e2:	eb09 1c40 	add.w	ip, r9, r0, lsl #5
  2039e6:	4545      	cmp	r5, r8
  2039e8:	f8dc 3918 	ldr.w	r3, [ip, #2328]	; 0x918
  2039ec:	bf28      	it	cs
  2039ee:	4645      	movcs	r5, r8
  2039f0:	b29b      	uxth	r3, r3
  2039f2:	ebb5 0f83 	cmp.w	r5, r3, lsl #2
  2039f6:	d824      	bhi.n	203a42 <otg_txfifo_handler.constprop.7+0x82>
  2039f8:	1c44      	adds	r4, r0, #1
  2039fa:	f8de 7008 	ldr.w	r7, [lr, #8]
  2039fe:	eb09 3404 	add.w	r4, r9, r4, lsl #12
    *fifop = *((uint32_t *)buf);
  203a02:	683b      	ldr	r3, [r7, #0]
    if (n <= 4) {
  203a04:	2d04      	cmp	r5, #4
    *fifop = *((uint32_t *)buf);
  203a06:	6023      	str	r3, [r4, #0]
    if (n <= 4) {
  203a08:	d907      	bls.n	203a1a <otg_txfifo_handler.constprop.7+0x5a>
  203a0a:	462b      	mov	r3, r5
  203a0c:	463a      	mov	r2, r7
    n -= 4;
  203a0e:	3b04      	subs	r3, #4
    *fifop = *((uint32_t *)buf);
  203a10:	f852 1f04 	ldr.w	r1, [r2, #4]!
    if (n <= 4) {
  203a14:	2b04      	cmp	r3, #4
    *fifop = *((uint32_t *)buf);
  203a16:	6021      	str	r1, [r4, #0]
    if (n <= 4) {
  203a18:	d8f9      	bhi.n	203a0e <otg_txfifo_handler.constprop.7+0x4e>
    usbp->epc[ep]->in_state->txcnt += n;
  203a1a:	442e      	add	r6, r5
    usbp->epc[ep]->in_state->txbuf += n;
  203a1c:	442f      	add	r7, r5
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize) {
  203a1e:	f8de 5000 	ldr.w	r5, [lr]
    usbp->epc[ep]->in_state->txbuf += n;
  203a22:	f8ce 7008 	str.w	r7, [lr, #8]
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize) {
  203a26:	42b5      	cmp	r5, r6
    usbp->epc[ep]->in_state->txcnt += n;
  203a28:	f8ce 6004 	str.w	r6, [lr, #4]
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize) {
  203a2c:	d90c      	bls.n	203a48 <otg_txfifo_handler.constprop.7+0x88>
    n = usbp->epc[ep]->in_state->txsize - usbp->epc[ep]->in_state->txcnt;
  203a2e:	1bad      	subs	r5, r5, r6
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
  203a30:	f8dc 3918 	ldr.w	r3, [ip, #2328]	; 0x918
  203a34:	4545      	cmp	r5, r8
  203a36:	b29b      	uxth	r3, r3
  203a38:	bf28      	it	cs
  203a3a:	4645      	movcs	r5, r8
  203a3c:	ebb5 0f83 	cmp.w	r5, r3, lsl #2
  203a40:	d9df      	bls.n	203a02 <otg_txfifo_handler.constprop.7+0x42>
      return false;
  203a42:	2000      	movs	r0, #0
}
  203a44:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      usbp->otg->DIEPEMPMSK &= ~DIEPEMPMSK_INEPTXFEM(ep);
  203a48:	2301      	movs	r3, #1
  203a4a:	f8d9 2834 	ldr.w	r2, [r9, #2100]	; 0x834
  203a4e:	fa03 f100 	lsl.w	r1, r3, r0
      return true;
  203a52:	4618      	mov	r0, r3
      usbp->otg->DIEPEMPMSK &= ~DIEPEMPMSK_INEPTXFEM(ep);
  203a54:	ea22 0201 	bic.w	r2, r2, r1
  203a58:	f8c9 2834 	str.w	r2, [r9, #2100]	; 0x834
  203a5c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  203a60:	20001228 	.word	0x20001228
	...

00203a70 <otg_epout_handler.constprop.4>:
static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
  203a70:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  stm32_otg_t *otgp = usbp->otg;
  203a74:	4e25      	ldr	r6, [pc, #148]	; (203b0c <otg_epout_handler.constprop.4+0x9c>)
static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
  203a76:	4605      	mov	r5, r0
  stm32_otg_t *otgp = usbp->otg;
  203a78:	6ef7      	ldr	r7, [r6, #108]	; 0x6c
  uint32_t epint = otgp->oe[ep].DOEPINT;
  203a7a:	eb07 1340 	add.w	r3, r7, r0, lsl #5
  203a7e:	f8d3 4b08 	ldr.w	r4, [r3, #2824]	; 0xb08
  if ((epint & DOEPINT_STUP) && (otgp->DOEPMSK & DOEPMSK_STUPM)) {
  203a82:	0720      	lsls	r0, r4, #28
  otgp->oe[ep].DOEPINT = epint;
  203a84:	f8c3 4b08 	str.w	r4, [r3, #2824]	; 0xb08
  if ((epint & DOEPINT_STUP) && (otgp->DOEPMSK & DOEPMSK_STUPM)) {
  203a88:	d503      	bpl.n	203a92 <otg_epout_handler.constprop.4+0x22>
  203a8a:	f8d7 3814 	ldr.w	r3, [r7, #2068]	; 0x814
  203a8e:	0719      	lsls	r1, r3, #28
  203a90:	d425      	bmi.n	203ade <otg_epout_handler.constprop.4+0x6e>
  if ((epint & DOEPINT_XFRC) && (otgp->DOEPMSK & DOEPMSK_XFRCM)) {
  203a92:	07e2      	lsls	r2, r4, #31
  203a94:	d521      	bpl.n	203ada <otg_epout_handler.constprop.4+0x6a>
  203a96:	f8d7 3814 	ldr.w	r3, [r7, #2068]	; 0x814
  203a9a:	07db      	lsls	r3, r3, #31
  203a9c:	d51d      	bpl.n	203ada <otg_epout_handler.constprop.4+0x6a>
    osp = usbp->epc[ep]->out_state;
  203a9e:	eb06 0385 	add.w	r3, r6, r5, lsl #2
  203aa2:	68d9      	ldr	r1, [r3, #12]
    if (ep == 0) {
  203aa4:	b95d      	cbnz	r5, 203abe <otg_epout_handler.constprop.4+0x4e>
    osp = usbp->epc[ep]->out_state;
  203aa6:	698a      	ldr	r2, [r1, #24]
      if (((osp->rxcnt % usbp->epc[ep]->out_maxsize) == 0) &&
  203aa8:	8a48      	ldrh	r0, [r1, #18]
  203aaa:	6854      	ldr	r4, [r2, #4]
  203aac:	fbb4 f3f0 	udiv	r3, r4, r0
  203ab0:	fb00 4313 	mls	r3, r0, r3, r4
  203ab4:	b91b      	cbnz	r3, 203abe <otg_epout_handler.constprop.4+0x4e>
          (osp->rxsize < osp->totsize)) {
  203ab6:	6810      	ldr	r0, [r2, #0]
  203ab8:	68d3      	ldr	r3, [r2, #12]
      if (((osp->rxcnt % usbp->epc[ep]->out_maxsize) == 0) &&
  203aba:	4298      	cmp	r0, r3
  203abc:	d317      	bcc.n	203aee <otg_epout_handler.constprop.4+0x7e>
    _usb_isr_invoke_out_cb(usbp, ep);
  203abe:	2201      	movs	r2, #1
  203ac0:	8973      	ldrh	r3, [r6, #10]
  203ac2:	68cc      	ldr	r4, [r1, #12]
  203ac4:	40aa      	lsls	r2, r5
  203ac6:	ea23 0302 	bic.w	r3, r3, r2
  203aca:	8173      	strh	r3, [r6, #10]
  203acc:	b12c      	cbz	r4, 203ada <otg_epout_handler.constprop.4+0x6a>
  203ace:	4629      	mov	r1, r5
  203ad0:	4623      	mov	r3, r4
  203ad2:	480e      	ldr	r0, [pc, #56]	; (203b0c <otg_epout_handler.constprop.4+0x9c>)
}
  203ad4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    _usb_isr_invoke_out_cb(usbp, ep);
  203ad8:	4718      	bx	r3
  203ada:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    _usb_isr_invoke_setup_cb(usbp, ep);
  203ade:	eb06 0385 	add.w	r3, r6, r5, lsl #2
  203ae2:	4629      	mov	r1, r5
  203ae4:	4630      	mov	r0, r6
  203ae6:	68db      	ldr	r3, [r3, #12]
  203ae8:	685b      	ldr	r3, [r3, #4]
  203aea:	4798      	blx	r3
  203aec:	e7d1      	b.n	203a92 <otg_epout_handler.constprop.4+0x22>
        osp->rxsize = osp->totsize - osp->rxsize;
  203aee:	1a1b      	subs	r3, r3, r0
        osp->rxcnt  = 0;
  203af0:	6055      	str	r5, [r2, #4]
  203af2:	2120      	movs	r1, #32
        osp->rxsize = osp->totsize - osp->rxsize;
  203af4:	6013      	str	r3, [r2, #0]
  203af6:	f381 8811 	msr	BASEPRI, r1
        usb_lld_start_out(usbp, ep);
  203afa:	4804      	ldr	r0, [pc, #16]	; (203b0c <otg_epout_handler.constprop.4+0x9c>)
  203afc:	4629      	mov	r1, r5
  203afe:	f7ff fe8f 	bl	203820 <usb_lld_start_out>
  203b02:	f385 8811 	msr	BASEPRI, r5
  203b06:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  203b0a:	bf00      	nop
  203b0c:	20001228 	.word	0x20001228

00203b10 <otg_epin_handler.constprop.3>:
  stm32_otg_t *otgp = usbp->otg;
  203b10:	4a20      	ldr	r2, [pc, #128]	; (203b94 <otg_epin_handler.constprop.3+0x84>)
static void otg_epin_handler(USBDriver *usbp, usbep_t ep) {
  203b12:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  stm32_otg_t *otgp = usbp->otg;
  203b14:	6ed6      	ldr	r6, [r2, #108]	; 0x6c
static void otg_epin_handler(USBDriver *usbp, usbep_t ep) {
  203b16:	4605      	mov	r5, r0
  uint32_t epint = otgp->ie[ep].DIEPINT;
  203b18:	eb06 1340 	add.w	r3, r6, r0, lsl #5
  203b1c:	f8d3 4908 	ldr.w	r4, [r3, #2312]	; 0x908
  if ((epint & DIEPINT_XFRC) && (otgp->DIEPMSK & DIEPMSK_XFRCM)) {
  203b20:	07e0      	lsls	r0, r4, #31
  otgp->ie[ep].DIEPINT = epint;
  203b22:	f8c3 4908 	str.w	r4, [r3, #2312]	; 0x908
  if ((epint & DIEPINT_XFRC) && (otgp->DIEPMSK & DIEPMSK_XFRCM)) {
  203b26:	d503      	bpl.n	203b30 <otg_epin_handler.constprop.3+0x20>
  203b28:	f8d6 3810 	ldr.w	r3, [r6, #2064]	; 0x810
  203b2c:	07d9      	lsls	r1, r3, #31
  203b2e:	d408      	bmi.n	203b42 <otg_epin_handler.constprop.3+0x32>
  if ((epint & DIEPINT_TXFE) &&
  203b30:	0623      	lsls	r3, r4, #24
  203b32:	d505      	bpl.n	203b40 <otg_epin_handler.constprop.3+0x30>
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
  203b34:	2301      	movs	r3, #1
  203b36:	f8d6 2834 	ldr.w	r2, [r6, #2100]	; 0x834
  203b3a:	40ab      	lsls	r3, r5
  if ((epint & DIEPINT_TXFE) &&
  203b3c:	4213      	tst	r3, r2
  203b3e:	d115      	bne.n	203b6c <otg_epin_handler.constprop.3+0x5c>
  203b40:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    USBInEndpointState *isp = usbp->epc[ep]->in_state;
  203b42:	eb02 0385 	add.w	r3, r2, r5, lsl #2
  203b46:	68d8      	ldr	r0, [r3, #12]
  203b48:	6943      	ldr	r3, [r0, #20]
    if (isp->txsize < isp->totsize) {
  203b4a:	681f      	ldr	r7, [r3, #0]
  203b4c:	68d9      	ldr	r1, [r3, #12]
  203b4e:	428f      	cmp	r7, r1
  203b50:	d311      	bcc.n	203b76 <otg_epin_handler.constprop.3+0x66>
      _usb_isr_invoke_in_cb(usbp, ep);
  203b52:	2101      	movs	r1, #1
  203b54:	8913      	ldrh	r3, [r2, #8]
  203b56:	6887      	ldr	r7, [r0, #8]
  203b58:	40a9      	lsls	r1, r5
  203b5a:	ea23 0301 	bic.w	r3, r3, r1
  203b5e:	8113      	strh	r3, [r2, #8]
  203b60:	2f00      	cmp	r7, #0
  203b62:	d0e5      	beq.n	203b30 <otg_epin_handler.constprop.3+0x20>
  203b64:	4610      	mov	r0, r2
  203b66:	4629      	mov	r1, r5
  203b68:	47b8      	blx	r7
  203b6a:	e7e1      	b.n	203b30 <otg_epin_handler.constprop.3+0x20>
    otg_txfifo_handler(usbp, ep);
  203b6c:	4628      	mov	r0, r5
}
  203b6e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    otg_txfifo_handler(usbp, ep);
  203b72:	f7ff bf25 	b.w	2039c0 <otg_txfifo_handler.constprop.7>
      isp->txsize = isp->totsize - isp->txsize;
  203b76:	1bc9      	subs	r1, r1, r7
      isp->txcnt  = 0;
  203b78:	2700      	movs	r7, #0
  203b7a:	2020      	movs	r0, #32
  203b7c:	e883 0082 	stmia.w	r3, {r1, r7}
  203b80:	f380 8811 	msr	BASEPRI, r0
      usb_lld_start_in(usbp, ep);
  203b84:	4610      	mov	r0, r2
  203b86:	4629      	mov	r1, r5
  203b88:	f7ff fdf2 	bl	203770 <usb_lld_start_in>
  203b8c:	f387 8811 	msr	BASEPRI, r7
  203b90:	e7ce      	b.n	203b30 <otg_epin_handler.constprop.3+0x20>
  203b92:	bf00      	nop
  203b94:	20001228 	.word	0x20001228

00203b98 <memcpy>:
  203b98:	b510      	push	{r4, lr}
  203b9a:	1e43      	subs	r3, r0, #1
  203b9c:	440a      	add	r2, r1
  203b9e:	4291      	cmp	r1, r2
  203ba0:	d100      	bne.n	203ba4 <memcpy+0xc>
  203ba2:	bd10      	pop	{r4, pc}
  203ba4:	f811 4b01 	ldrb.w	r4, [r1], #1
  203ba8:	f803 4f01 	strb.w	r4, [r3, #1]!
  203bac:	e7f7      	b.n	203b9e <memcpy+0x6>
